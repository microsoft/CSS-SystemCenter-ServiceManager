# This file is generated by a tool. Do not make changes. They will be overridden by the tool.


function GetToolVersion() {'1.9.0.66'}
#region EULA
function ShowEULAPopup()
{
    [void][System.Reflection.Assembly]::Load('System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
    [void][System.Reflection.Assembly]::Load('System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')

    $mode=0
    $EULA = New-Object -TypeName System.Windows.Forms.Form
    $richTextBox1 = New-Object System.Windows.Forms.RichTextBox
    $btnAcknowledge = New-Object System.Windows.Forms.Button
    $btnCancel = New-Object System.Windows.Forms.Button

    $EULA.SuspendLayout()
    $EULA.Name = "EULA"
    $EULA.Text = "Microsoft Diagnostic Tools End User License Agreement"

    $richTextBox1.Anchor = [System.Windows.Forms.AnchorStyles]::Top -bor [System.Windows.Forms.AnchorStyles]::Bottom -bor [System.Windows.Forms.AnchorStyles]::Left -bor [System.Windows.Forms.AnchorStyles]::Right
    $richTextBox1.Location = New-Object System.Drawing.Point(12,12)
    $richTextBox1.Name = "richTextBox1"
    $richTextBox1.ScrollBars = [System.Windows.Forms.RichTextBoxScrollBars]::Vertical
    $richTextBox1.Size = New-Object System.Drawing.Size(776, 397)
    $richTextBox1.TabIndex = 0
    $richTextBox1.ReadOnly=$True
    $richTextBox1.Add_LinkClicked({Start-Process -FilePath $_.LinkText})
    $richTextBox1.Rtf = @"
{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fswiss\fprq2\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}{\f2\fnil\fcharset0 Microsoft Sans Serif;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.19041}{\*\mmathPr\mdispDef1\mwrapIndent1440 }\viewkind4\uc1 
\pard\widctlpar\f0\fs19\lang1033 MICROSOFT SOFTWARE LICENSE TERMS\par
Microsoft Diagnostic Scripts and Utilities\par
\par
{\pict{\*\picprop}\wmetafile8\picw26\pich26\picwgoal32000\pichgoal15 
0100090000035000000000002700000000000400000003010800050000000b0200000000050000
000c0202000200030000001e000400000007010400040000000701040027000000410b2000cc00
010001000000000001000100000000002800000001000000010000000100010000000000000000
000000000000000000000000000000000000000000ffffff00000000ff040000002701ffff0300
00000000
}These license terms are an agreement between you and Microsoft Corporation (or one of its affiliates). IF YOU COMPLY WITH THESE LICENSE TERMS, YOU HAVE THE RIGHTS BELOW. BY USING THE SOFTWARE, YOU ACCEPT THESE TERMS.\par
{\pict{\*\picprop}\wmetafile8\picw26\pich26\picwgoal32000\pichgoal15 
0100090000035000000000002700000000000400000003010800050000000b0200000000050000
000c0202000200030000001e000400000007010400040000000701040027000000410b2000cc00
010001000000000001000100000000002800000001000000010000000100010000000000000000
000000000000000000000000000000000000000000ffffff00000000ff040000002701ffff0300
00000000
}\par
\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\fi-360\li360 INSTALLATION AND USE RIGHTS. Subject to the terms and restrictions set forth in this license, Microsoft Corporation (\ldblquote Microsoft\rdblquote ) grants you (\ldblquote Customer\rdblquote  or \ldblquote you\rdblquote ) a non-exclusive, non-assignable, fully paid-up license to use and reproduce the script or utility provided under this license (the "Software"), solely for Customer\rquote s internal business purposes, to help Microsoft troubleshoot issues with one or more Microsoft products, provided that such license to the Software does not include any rights to other Microsoft technologies (such as products or services). \ldblquote Use\rdblquote  means to copy, install, execute, access, display, run or otherwise interact with the Software. \par
\pard\widctlpar\par
\pard\widctlpar\li360 You may not sublicense the Software or any use of it through distribution, network access, or otherwise. Microsoft reserves all other rights not expressly granted herein, whether by implication, estoppel or otherwise. You may not reverse engineer, decompile or disassemble the Software, or otherwise attempt to derive the source code for the Software, except and to the extent required by third party licensing terms governing use of certain open source components that may be included in the Software, or remove, minimize, block, or modify any notices of Microsoft or its suppliers in the Software. Neither you nor your representatives may use the Software provided hereunder: (i) in a way prohibited by law, regulation, governmental order or decree; (ii) to violate the rights of others; (iii) to try to gain unauthorized access to or disrupt any service, device, data, account or network; (iv) to distribute spam or malware; (v) in a way that could harm Microsoft\rquote s IT systems or impair anyone else\rquote s use of them; (vi) in any application or situation where use of the Software could lead to the death or serious bodily injury of any person, or to physical or environmental damage; or (vii) to assist, encourage or enable anyone to do any of the above.\par
\par
\pard\widctlpar\fi-360\li360 2.\tab DATA. Customer owns all rights to data that it may elect to share with Microsoft through using the Software. You can learn more about data collection and use in the help documentation and the privacy statement at {{\field{\*\fldinst{HYPERLINK https://aka.ms/privacy }}{\fldrslt{https://aka.ms/privacy\ul0\cf0}}}}\f0\fs19 . Your use of the Software operates as your consent to these practices.\par
\pard\widctlpar\par
\pard\widctlpar\fi-360\li360 3.\tab FEEDBACK. If you give feedback about the Software to Microsoft, you grant to Microsoft, without charge, the right to use, share and commercialize your feedback in any way and for any purpose.\~ You will not provide any feedback that is subject to a license that would require Microsoft to license its software or documentation to third parties due to Microsoft including your feedback in such software or documentation. \par
\pard\widctlpar\par
\pard\widctlpar\fi-360\li360 4.\tab EXPORT RESTRICTIONS. Customer must comply with all domestic and international export laws and regulations that apply to the Software, which include restrictions on destinations, end users, and end use. For further information on export restrictions, visit {{\field{\*\fldinst{HYPERLINK https://aka.ms/exporting }}{\fldrslt{https://aka.ms/exporting\ul0\cf0}}}}\f0\fs19 .\par
\pard\widctlpar\par
\pard\widctlpar\fi-360\li360\qj 5.\tab REPRESENTATIONS AND WARRANTIES. Customer will comply with all applicable laws under this agreement, including in the delivery and use of all data. Customer or a designee agreeing to these terms on behalf of an entity represents and warrants that it (i) has the full power and authority to enter into and perform its obligations under this agreement, (ii) has full power and authority to bind its affiliates or organization to the terms of this agreement, and (iii) will secure the permission of the other party prior to providing any source code in a manner that would subject the other party\rquote s intellectual property to any other license terms or require the other party to distribute source code to any of its technologies.\par
\pard\widctlpar\par
\pard\widctlpar\fi-360\li360\qj 6.\tab DISCLAIMER OF WARRANTY. THE SOFTWARE IS PROVIDED \ldblquote AS IS,\rdblquote  WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL MICROSOFT OR ITS LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\par
\pard\widctlpar\qj\par
\pard\widctlpar\fi-360\li360\qj 7.\tab LIMITATION ON AND EXCLUSION OF DAMAGES. IF YOU HAVE ANY BASIS FOR RECOVERING DAMAGES DESPITE THE PRECEDING DISCLAIMER OF WARRANTY, YOU CAN RECOVER FROM MICROSOFT AND ITS SUPPLIERS ONLY DIRECT DAMAGES UP TO U.S. $5.00. YOU CANNOT RECOVER ANY OTHER DAMAGES, INCLUDING CONSEQUENTIAL, LOST PROFITS, SPECIAL, INDIRECT, OR INCIDENTAL DAMAGES. This limitation applies to (i) anything related to the Software, services, content (including code) on third party Internet sites, or third party applications; and (ii) claims for breach of contract, warranty, guarantee, or condition; strict liability, negligence, or other tort; or any other claim; in each case to the extent permitted by applicable law. It also applies even if Microsoft knew or should have known about the possibility of the damages. The above limitation or exclusion may not apply to you because your state, province, or country may not allow the exclusion or limitation of incidental, consequential, or other damages.\par
\pard\widctlpar\par
\pard\widctlpar\fi-360\li360 8.\tab BINDING ARBITRATION AND CLASS ACTION WAIVER. This section applies if you live in (or, if a business, your principal place of business is in) the United States.  If you and Microsoft have a dispute, you and Microsoft agree to try for 60 days to resolve it informally. If you and Microsoft can\rquote t, you and Microsoft agree to binding individual arbitration before the American Arbitration Association under the Federal Arbitration Act (\ldblquote FAA\rdblquote ), and not to sue in court in front of a judge or jury. Instead, a neutral arbitrator will decide. Class action lawsuits, class-wide arbitrations, private attorney-general actions, and any other proceeding where someone acts in a representative capacity are not allowed; nor is combining individual proceedings without the consent of all parties. The complete Arbitration Agreement contains more terms and is at {{\field{\*\fldinst{HYPERLINK https://aka.ms/arb-agreement-4 }}{\fldrslt{https://aka.ms/arb-agreement-4\ul0\cf0}}}}\f0\fs19 . You and Microsoft agree to these terms. \par
\pard\widctlpar\par
\pard\widctlpar\fi-360\li360 9.\tab LAW AND VENUE. If U.S. federal jurisdiction exists, you and Microsoft consent to exclusive jurisdiction and venue in the federal court in King County, Washington for all disputes heard in court (excluding arbitration). If not, you and Microsoft consent to exclusive jurisdiction and venue in the Superior Court of King County, Washington for all disputes heard in court (excluding arbitration).\par
\pard\widctlpar\par
\pard\widctlpar\fi-360\li360 10.\tab ENTIRE AGREEMENT. This agreement, and any other terms Microsoft may provide for supplements, updates, or third-party applications, is the entire agreement for the software.\par
\pard\sa200\sl276\slmult1\f1\fs22\lang9\par
\pard\f2\fs17\lang2057\par
}
"@
    $richTextBox1.BackColor = [System.Drawing.Color]::White
    $btnAcknowledge.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor [System.Windows.Forms.AnchorStyles]::Right
    $btnAcknowledge.Location = New-Object System.Drawing.Point(544, 415)
    $btnAcknowledge.Name = "btnAcknowledge";
    $btnAcknowledge.Size = New-Object System.Drawing.Size(119, 23)
    $btnAcknowledge.TabIndex = 1
    $btnAcknowledge.Text = "Accept"
    $btnAcknowledge.UseVisualStyleBackColor = $True
    $btnAcknowledge.Add_Click({$EULA.DialogResult=[System.Windows.Forms.DialogResult]::Yes})

    $btnCancel.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor [System.Windows.Forms.AnchorStyles]::Right
    $btnCancel.Location = New-Object System.Drawing.Point(669, 415)
    $btnCancel.Name = "btnCancel"
    $btnCancel.Size = New-Object System.Drawing.Size(119, 23)
    $btnCancel.TabIndex = 2
    if($mode -ne 0)
    {
	    $btnCancel.Text = "Close"
    }
    else
    {
	    $btnCancel.Text = "Decline"
    }
    $btnCancel.UseVisualStyleBackColor = $True
    $btnCancel.Add_Click({$EULA.DialogResult=[System.Windows.Forms.DialogResult]::No})

    $EULA.AutoScaleDimensions = New-Object System.Drawing.SizeF(6.0, 13.0)
    $EULA.AutoScaleMode = [System.Windows.Forms.AutoScaleMode]::Font
    $EULA.ClientSize = New-Object System.Drawing.Size(800, 450)
    $EULA.Controls.Add($btnCancel)
    $EULA.Controls.Add($richTextBox1)
    if($mode -ne 0)
    {
	    $EULA.AcceptButton=$btnCancel
    }
    else
    {
        $EULA.Controls.Add($btnAcknowledge)
	    $EULA.AcceptButton=$btnAcknowledge
        $EULA.CancelButton=$btnCancel
    }
    $EULA.ResumeLayout($false)
    $EULA.Size = New-Object System.Drawing.Size(800, 650)

    Return ($EULA.ShowDialog().ToString())
}

function ShowEULAIfNeeded()
{
	$eulaRegPath = "HKCU:Software\Microsoft\SCSM-Diagnostic-Tool\"
	$eulaValue = "EulaAcceptDate"

    $eulaAcceptDateStr = Get-ItemPropertyValue -Path $eulaRegPath -Name $eulaValue -ErrorAction Ignore 
    $eulaAcceptDate = [datetime]::MinValue
    if ( [datetime]::TryParseExact($eulaAcceptDateStr,"yyyy-MM-dd__HH:mm.ss.fff", $null, [System.Globalization.DateTimeStyles]::None, [ref] $eulaAcceptDate) ) {
        return $true
    }
	
	if( (ShowEULAPopup) -eq [System.Windows.Forms.DialogResult]::Yes)
	{
        if (Test-Path $eulaRegPath) { Remove-item $eulaRegPath -Recurse -Force }
	    $eulaAcceptDateStr = (Get-Date).ToUniversalTime().ToString("yyyy-MM-dd__HH:mm.ss.fff")
        New-Item -Path $eulaRegPath | Out-Null               
	    New-ItemProperty -Path $eulaRegPath -Name $eulaValue -Value $eulaAcceptDateStr -PropertyType String | Out-Null
        return $true
	}

	return $false
}

function IsEulaAccepted() {
    return ShowEULAIfNeeded
}
#endregion

function Initialize() {

    SelfUpdate #TODO

    SelfElevate
    
    #region EULA
    if (-not (IsEulaAccepted)) {
        Write-Host "End User License Agreement has been declined. Aborting." -ForegroundColor DarkGray
        return $false
    }
    #endregion

    return $true
}

function SelfElevate() {
    if (-Not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] 'Administrator')) {
        if ([int](Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty BuildNumber) -ge 6000) {
            $CommandLine = "-File `"" + $Script:MyInvocation.MyCommand.Path + "`" " + $Script:MyInvocation.UnboundArguments
            Start-Process -FilePath PowerShell.exe -Verb Runas -ArgumentList $CommandLine
            Exit
        }
    }
}

function SelfUpdate() {

}

function Collect_DateTime() {
    AppendOutputToFileInTargetFolder (Get-Date).ToUniversalTime().ToString("yyyy-MM-dd__HH:mm.ss.fff") "Get-UtcDate.txt"
    AppendOutputToFileInTargetFolder (Get-Date).ToString("yyyy-MM-dd__HH:mm.ss.fff zzz") "Get-Date.txt"
}

function Collect_DotNetFWInfo_35() {
    Reg export "HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP\v3.5" (GetFileNameInTargetFolder "DotNetFwV3.5.txt")| Out-Null
}

function Collect_DotNetFWInfo_4() {
    Reg export "HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4"   (GetFileNameInTargetFolder "DotNetFwV4.txt")| Out-Null
}

function Collect_EnvironmentVariables() {
    AppendOutputToFileInTargetFolder (dir env:* | ConvertTo-Csv -NoTypeInformation) "EnvVars.csv"
}

function Collect_HostFqdn() {
    AppendOutputToFileInTargetFolder ([System.Net.Dns]::GetHostByName($env:computerName).HostName) Hostname_fqdn.txt
}

function Collect_Hotfix() {
    AppendOutputToFileInTargetFolder (Get-HotFix | Format-table -Wrap -AutoSize)  "Get-Hotfix.txt"
}

function Collect_LanguageInfo() {
    AppendOutputToFileInTargetFolder (Invoke-Expression -Command "dism.exe /online /Get-intl") "LanguageInfo.txt"
}

function Collect_LocalSecurityPolicy() {
    (secedit.exe /export /cfg (GetFileNameInTargetFolder 'LocalSecurityPolicy_UserRightsAssignment.txt') /areas USER_RIGHTS ) | Out-Null
}

function Collect_MSINFO32() {
#Starting MSINFO32 in the background
 
    Start-Job -ScriptBlock {
        Start-Process msinfo32.exe -Wait -ArgumentList $input 
    } -InputObject  "/report ""$((GetFileNameInTargetFolder "msinfo32.txt"))""" | Out-Null
}

function Collect_Netstat() {
    AppendOutputToFileInTargetFolder (netstat /abof) "netstat_abof.txt"
}

function Collect_NonSMEventLogs() {

    (get-wmiobject win32_nteventlogfile -filter "logfilename = 'Application'").BackupEventlog((GetFileNameInTargetFolder "Application.evtx"))| Out-Null
    wevtutil archive-log (GetFileNameInTargetFolder "Application.evtx") /l:en-US

    (get-wmiobject win32_nteventlogfile -filter "logfilename = 'System'").BackupEventlog((GetFileNameInTargetFolder "System.evtx"))| Out-Null
    wevtutil archive-log (GetFileNameInTargetFolder "System.evtx") /l:en-US
}

function Collect_OSRegionSettings() {
    #to be used later by Analyzer
    AppendOutputToFileInTargetFolder ( [System.Threading.Thread]::CurrentThread.CurrentCulture.NumberFormat | ConvertTo-Csv ) CurrentCulture.NumberFormat.csv
    AppendOutputToFileInTargetFolder ( [System.Threading.Thread]::CurrentThread.CurrentCulture.DateTimeFormat | ConvertTo-Csv ) CurrentCulture.DateTimeFormat.csv
}

function Collect_PowerShellInfo() {
    AppendOutputToFileInTargetFolder ($PSVersionTable) "PSVersionTable.txt"
    AppendOutputToFileInTargetFolder ($PSVersionTable.PSCompatibleVersions) "PSCompatibleVersions.txt"   
    AppendOutputToFileInTargetFolder ( Get-ExecutionPolicy -List ) Get-ExecutionPolicy_List.txt
    AppendOutputToFileInTargetFolder "Elevated: $(IsRunningAsElevated)" IsRunningAsElevated.txt
}

function Collect_Processes() {
    if ( $PSVersionTable.PSVersion.Major -ge 3 ) { 
        $processWithAllInfo = Get-Process -IncludeUserName | ? {$_.Id -ne 0 }| select *,CurrentCPU 
    }
    else {
        $processWithAllInfo = Get-Process | ? {$_.Id -ne 0 }| select *,CurrentCPU 
    }

    $PID_CurrentCPU=Get-WmiObject Win32_PerfFormattedData_PerfProc_Process | ? {$_.IDProcess -ne 0 } | select IDProcess, @{ Name = 'PercentProcessorTime';  Expression = {$_.PercentProcessorTime / ($env:NUMBER_OF_PROCESSORS) }} 
    foreach($p in $processWithAllInfo) {  $p.CurrentCPU = ( $PID_CurrentCPU | ? {$_.IDProcess -eq $p.Id}  ).PercentProcessorTime }  
    AppendOutputToFileInTargetFolder (  $processWithAllInfo | select Handles, WS, CurrentCPU, Id, UserName, ProcessName | ft -Wrap ) Get-Process_WithCurrentCPU.txt
    AppendOutputToFileInTargetFolder (  $processWithAllInfo ) Get-Process_WithAllDetails.txt
    AppendOutputToFileInTargetFolder (  $processWithAllInfo | ? {$_.Name -eq "System" } | Select StartTime ) MachineStartTime.txt
    AppendOutputToFileInTargetFolder (  $processWithAllInfo | ? {$_.Id -ne 0  -and  $_.CurrentCPU -gt 0} | select Id,Name,CurrentCPU )  Get-Process_OnlyActiveOnes.txt
    AppendOutputToFileInTargetFolder (  $processWithAllInfo | ? {$_.Id -ne 0} | Sort-Object -Property CurrentCPU -Descending | select Id,Name,CurrentCPU -First 10  )  Get-Process_Top10_ByCPU.txt
    AppendOutputToFileInTargetFolder (  $processWithAllInfo | ? {$_.Id -ne 0} | Sort-Object -Property WS -Descending | select Id,Name,WS -First 10  )  Get-Process_Top10_ByWorkingSet.txt
}

function Collect_ProgramsInfo() {
    AppendOutputToFileInTargetFolder (Get-WmiObject -Class Win32_Product | Select-Object Version, Name, InstallDate ) "ProgramVersions.txt"
}

function Collect_RAMInfo() {    
    
    [System.Reflection.Assembly]::LoadWithPartialName("Microsoft.VisualBasic") | Out-Null
    [long]$totalRamMB = ( [Microsoft.VisualBasic.Devices.ComputerInfo]::new().TotalPhysicalMemory / 1mb )
    AppendOutputToFileInTargetFolder $totalRamMB TotalRAM.txt

}

function Collect_ServiceInfo() {
    AppendOutputToFileInTargetFolder (gwmi win32_service | Select-Object Name, StartMode, State, DisplayName, StartName, pathname | ConvertTo-Csv -NoTypeInformation ) Get-Service.csv
}

function Collect_TimeDiffBetweenDC() {
    $compNameToCheckTimeDiff = ($env:LOGONSERVER).Replace("\\","")
    $result = Run2ndOnlyIf1stSucceeds {
        InvokeCommand -computerName $compNameToCheckTimeDiff -scriptBlock {Get-Date}
        }{
        New-TimeSpan -Start (Get-Date) -End $resultOf1 
    }
    AppendOutputToFileInTargetFolder ( $result ) "TimeDiff_BtwDC.txt"
    AppendOutputToFileInTargetFolder ( w32tm.exe /stripchart /dataonly /samples:1 /computer:$compNameToCheckTimeDiff 2>&1 ) "TimeDiff_BtwDC_viaWin32tm.txt"
}

function Collect_TLS() {
    CreateNewFolderInTargetFolder "TLS"

    Reg export "HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders" (GetFileNameInTargetFolder "TLS\SecurityProviders.txt")| Out-Null
    Reg export "HKLM\SOFTWARE\Microsoft\.NETFramework" (GetFileNameInTargetFolder "TLS\NETFramework.txt")| Out-Null
    Reg export "HKLM\SOFTWARE\WOW6432Node\Microsoft\.NETFramework" (GetFileNameInTargetFolder "TLS\WOW6432Node_NETFramework.txt")| Out-Null 
}

function Collect_NonScsmSpecificMachineInfo() {
    
    Collect_Processes # We intentionally collect all process info before collecting anything else, in order to exclude Collector's overhead.
    Collect_MSINFO32 # we start msinfo32 immediately as a background job, because it can take long

    Collect_DotNetFWInfo_35
    Collect_DotNetFWInfo_4
    Collect_DateTime
    Collect_EnvironmentVariables
    Collect_Hotfix    
    Collect_ProgramsInfo
    Collect_LanguageInfo
    Collect_RAMInfo
    Collect_ServiceInfo
    Collect_PowerShellInfo
    Collect_HostFqdn
    Collect_Netstat    
    Collect_LocalSecurityPolicy
    Collect_TimeDiffBetweenDC
    Collect_TLS
    Collect_OSRegionSettings
    Collect_NonSMEventLogs
}

function Collect_OnlyConsoleSpecificInfo() {
#region Exit immediately if Console is NOT installed
if (-not (IsScsmConsoleInstalled)) {
    return
}
#endregion


}

function Collect_ForExtractJob() {
    $SqlTestToSMDB = (Try-Invoke-SqlCmd -SQLInstance ($SMDBInfo.SQLInstance_SMDB) -SQLDatabase ($SMDBInfo.SQLDatabase_SMDB) -Query "select 'OK' as 'SqlPingResultFromDWToSMDB' ").Tables[0].SqlPingResultFromDWToSMDB    
    if ($SqlTestToSMDB -eq "OK") {    
        AppendOutputToFileInTargetFolder "OK with user: $env:UserDomain\$env:USERNAME" "ForExtractJob_SqlPing_FromDW_ToSMDB.txt"
    }
    else {
        AppendOutputToFileInTargetFolder "ERROR with user: $env:UserDomain\$env:USERNAME to SQLInstance:($SMDBInfo.SQLInstance_SMDB)  DB:($SMDBInfo.SQLDatabase_SMDB)" "ForExtractJob_SqlPing_FromDW_ToSMDB.txt"
    }

    $sqlUserforExtract = Get-SCSMRunAsAccount -DisplayName "$($SMDBInfo.DataSourceName_SMDB) SecureReference"
    if ($sqlUserforExtract.Domain -ne $env:UserDomain  -or  $sqlUserforExtract.UserName -ne $env:USERNAME) {
        AppendOutputToFileInTargetFolder "`nAttention! Extract Job is actually using account: $($sqlUserforExtract.Domain)\$($sqlUserforExtract.UserName). This is different than the current user:$env:UserDomain\$env:USERNAME" "ForExtractJob_SqlPing_FromDW_ToSMDB.txt"
        AppendOutputToFileInTargetFolder "Please check result of   Get-SCSMRunAsAccount. The result of this test may not be the same as the actual Extract job." "ForExtractJob_SqlPing_FromDW_ToSMDB.txt"
    }

    SaveSQLResultSetsToFiles ($SMDBInfo.SQLInstance_SMDB) ($SMDBInfo.SQLDatabase_SMDB) "dbcc useroptions" "ForExtractJob_dbcc_useroptions_FromDW_ToSMDB.txt" 
    if ($sqlUserforExtract.Domain -ne $env:UserDomain  -or  $sqlUserforExtract.UserName -ne $env:USERNAME) {
        AppendOutputToFileInTargetFolder "`nAttention! Extract Job is actually using account: $($sqlUserforExtract.Domain)\$($sqlUserforExtract.UserName). This is different than the current user:$env:UserDomain\$env:USERNAME" "ForExtractJob_dbcc_useroptions_FromDW_ToSMDB.txt"
        AppendOutputToFileInTargetFolder "Please check result of   Get-SCSMRunAsAccount. The result of this test may not be the same as the actual Extract job." "ForExtractJob_dbcc_useroptions_FromDW_ToSMDB.txt"
    }
}

function Collect_ForMPSyncJob() {
    AppendOutputToFileInTargetFolder (Test-NetConnection -ComputerName ($SMDBInfo.SDKServer_SMDB) -Port 5724) ForMPSyncJob_Telnet_FromDW_ToSMSDK.txt
}

function Collect_SMDBInfo() {
    AppendOutputToFileInTargetFolder ($SMDBInfo) SQL_SMDB_Info.txt
}

function Collect_SQL_SMDB() {
    $SQL_FromSMDB =@{}
    $SQL_FromSMDB['SQL_FromSMDB_MOMManagementGroupInfo']=@'
select * from [dbo].[__MOMManagementGroupInfo__] 
'@
    $SQL_FromSMDB['SQL_FromSMDB_PatchInfo']=@'
select * from [dbo].[__PatchInfo__]  -- if table doesn't exist then it's RTM, check also DBVersion in   __MOMManagementGroupInfo__
'@
    $SQL_FromSMDB['SQL_FromSMDB_WorkItemsCount']=@'
select count(*) 'IR count in SMDB', min(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Oldest",max(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Newest" from [dbo].[MT_System$WorkItem$Incident]
select count(*) 'SR count in SMDB', min(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Oldest",max(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Newest" from [dbo].[MT_System$WorkItem$ServiceRequest] 
select count(*) 'CR count in SMDB', min(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Oldest",max(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Newest" from [dbo].[MT_System$WorkItem$ChangeRequest]
'@
    $SQL_FromSMDB['SQL_FromSMDB_WorkItemsCount_ByMonth']=@'
select 'IR in SMDB',datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) year,datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) month,count(*) count
from [dbo].[MT_System$WorkItem$Incident]
group by datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688),datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688)
order by 2,3
select 'SR in SMDB',datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) year,datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) month,count(*) count
from [dbo].[MT_System$WorkItem$ServiceRequest]
group by datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688),datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688)
order by 2,3
select 'CR in SMDB',datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) year,datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) month,count(*) count
from [dbo].[MT_System$WorkItem$ChangeRequest]
group by datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688),datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688)
order by 2,3
'@
    foreach($SQL_FromSMDB_Text in $SQL_FromSMDB.Keys) {        
        SaveSQLResultSetsToFiles $($SMDBInfo.SQLInstance_SMDB) $($SMDBInfo.SQLDatabase_SMDB) ( $SQL_FromSMDB[$SQL_FromSMDB_Text] ) "$SQL_FromSMDB_Text.csv"    
    }

}

function Collect_FromSMSide() {

#Collects for MpSync & Extract and other info from SM Side (DB and SDK)

    #region DO NOT MOVE THIS! To be used in subsequent functions
    $SQL_SMDBInfo=@'
    select DataSourceName_AC09B683_AE61_BDCA_6383_2007DB60859D as DataSourceName_SMDB,DatabaseServer_CD2D9C2A_39C2_CE05_D84C_AC42E429D191 as SQLInstance_SMDB,Database_D59DC40A_E438_1A05_C231_E3BD50E5DD44 as SQLDatabase_SMDB,SdkServer_0E227991_743F_4854_FF8B_273C1688DFEB  as SDKServer_SMDB from MTV_Microsoft$SystemCenter$DataWarehouse$CMDBSource where BaseManagedEntityId in (select BaseManagedEntityId from BaseManagedEntity where BaseManagedTypeId='0222340F-D0CD-6B06-70A6-AA0A1504F428' and name not like 'DW\_%' escape'\')
'@
    $SMDBInfo = (Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSMDW -SQLDatabase $SQLDatabase_SCSMDW -Query $SQL_SMDBInfo).Tables[0]
    #endregion    
    
    Collect_SMDBInfo
    Collect_ForMPSyncJob    
    Collect_ForExtractJob
    Collect_SQL_SMDB
}

function Collect_SsasCubes() {
    AppendOutputToFileInTargetFolder ($SsasDB.Cubes | ft -Property CreatedTimestamp,LastSchemaUpdate,State,LastProcessed,Name, Dimensions -Wrap) "SsasCubes.txt"
}

function Collect_SsasDataSources() {
    AppendOutputToFileInTargetFolder ($SsasDB.DataSources) "SsasDataSources.txt"
}

function Collect_SsasDataSourceViews() {
    AppendOutputToFileInTargetFolder ($SsasDB.DataSourceViews) "SsasDataSourceViews.txt"
}

function Collect_SsasDB() {
    AppendOutputToFileInTargetFolder $SsasDB "SsasDB.txt"
}

function Collect_SsasDimensions() {
    AppendOutputToFileInTargetFolder ($SsasDB.Dimensions | ft -Property CreatedTimestamp,LastSchemaUpdate,State,LastProcessed,Name -Wrap) "SsasDimensions.txt"
}

function Collect_FromSSAS() {
    #region DO NOT MOVE THIS! To be used in subsequent functions
    $SsasInfo = (Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSMDW -SQLDatabase $SQLDatabase_SCSMDW -Query 'select Server_48B308F9_CF0E_0F74_83E1_0AEB1B58E2FA as SsasServerName,DataService_98B2DDF9_D9FD_9297_85D3_FCF36F1D016B as SsasDBName from MT_Microsoft$SystemCenter$ResourceAccessLayer$ASResourceStore').Tables[0]    
    [System.Reflection.Assembly]::LoadWithPartialName("Microsoft.AnalysisServices") > $NULL
    $Server = New-Object Microsoft.AnalysisServices.Server
    $Server.Connect("Data source=$($SsasInfo.SsasServerName)") 
    $SsasDB=$Server.Databases["$($SsasInfo.SsasDBName)"] 
    #endregion SSAS  

    Collect_SsasDB
    Collect_SsasCubes
    Collect_SsasDimensions
    Collect_SsasDataSourceViews
    Collect_SsasDataSources
}

function Collect_SsrsObjectsInfo() {
    $Proxy = New-WebServiceProxy -Uri $SsrsUrl -Namespace SSRS.ReportingService2005 -UseDefaultCredential
    $ssrsItems = $Proxy.ListChildren('/' , $true) | Select-Object ID, Name, Path, Type, Hidden, CreatedBy, CreationDate, ModifiedBy, ModifiedDate, MimeType | select *, InheritsParentSecurity, EffectivePermissions    
    [System.Collections.ArrayList]$ssrsItemsArrayList=$ssrsItems
    $ssrsRootObj = [PSCustomObject]@{
        Id = ''
        Name = ''
        Path = '/'
        Type = ''
        Hidden = ''
        CreatedBy = ''
        CreationDate = ''
        ModifiedBy = ''
        ModifiedDate = ''
        MimeType = ''
        InheritsParentSecurity = ''
        EffectivePermissions = ''#($Proxy.GetPolicies('/',[ref]$true))
    }
    $ssrsItemsArrayList.Insert(0,$ssrsRootObj)    
    foreach ($ssrsItem in  $ssrsItemsArrayList)
    {
        $InheritsParent = $null
        $TempFileName = ([guid]::NewGuid()).ToString()    
        AppendOutputToFileInTargetFolder ($Proxy.GetPolicies($ssrsItem.Path,[ref]$InheritsParent) ) $TempFileName
        $ssrsItem.InheritsParentSecurity = $InheritsParent
        $ssrsItem.EffectivePermissions =  ( GetFileContentInTargetFolder $TempFileName )
        DeleteFileInTargetFolder $TempFileName 
    }
    AppendOutputToFileInTargetFolder ( $ssrsItemsArrayList | ConvertTo-Csv -NoTypeInformation ) "Ssrs-AllItems.csv"
}

function Collect_SsrsVersion() {
    AppendOutputToFileInTargetFolder (Invoke-WebRequest -Uri ($SsrsUrl.Replace("ReportService2005.asmx","")) -UseDefaultCredentials -UseBasicParsing).Content "Ssrs-Version.txt"
}

function Collect_Test_SsrsWebService() {
    AppendOutputToFileInTargetFolder (Invoke-WebRequest -Uri $SsrsUrl -UseDefaultCredentials -UseBasicParsing) "Ssrs-TestUrl.txt"
}

function Collect_FromSSRS() {
    #region DO NOT MOVE THIS! To be used in subsequent functions
    $SsrsUrl = (Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSMDW -SQLDatabase $SQLDatabase_SCSMDW -Query 'select DataService_98B2DDF9_D9FD_9297_85D3_FCF36F1D016B as SsrsUrl from MT_Microsoft$SystemCenter$ResourceAccessLayer$SrsResourceStore').Tables[0].SsrsUrl
    #endregion

    Collect_Test_SsrsWebService
    Collect_SsrsVersion
    Collect_SsrsObjectsInfo
}

function Collect_DWEnvironmentInfo() {
    AppendOutputToFileInTargetFolder (Get-SCDWInfraLocation) "Get-SCDWInfraLocation.txt"
}

function Collect_DWJobs() {
    $dwjobs = Get-SCDWJob | select BatchId,Name,Status,CategoryName,StartTime,EndTime,IsEnabled,Duration
    foreach($dwjob in $dwjobs) {
        if ($dwjob.Starttime -and $dwjob.Endtime) {            
            $dwjob.Duration = Get-UserFriendlyTimeSpane ($dwjob.EndTime - $dwjob.StartTime)  #"{0:dd}D.{0:hh}H:{0:mm}M" -f ($dwjob.EndTime - $dwjob.StartTime)
        }        
    }
    AppendOutputToFileInTargetFolder ($dwjobs | Sort-Object -Property Name | ft )  "Get-SCDWJob.txt" 
    AppendOutputToFileInTargetFolder ($dwjobs | Sort-Object -Property Name | ConvertTo-Csv )  "Get-SCDWJob.csv" 
}

function Collect_DWJobSchedules() {
    AppendOutputToFileInTargetFolder (Get-SCDWJobSchedule) "Get-SCDWJobSchedule.txt"
    AppendOutputToFileInTargetFolder ( (Get-SCDWJobSchedule) | ConvertTo-Csv )  "Get-SCDWJobSchedule.csv" 
}

function Collect_DWJobs_Last5() {
    $dwjobsNOB = Get-SCDWJob -NumberOfBatches 5 | select BatchId,Name,Status,CategoryName,StartTime,EndTime,IsEnabled,Duration
    foreach($dwjobNOB in $dwjobsNOB) {
        if ($dwjobNOB.Starttime -and $dwjobNOB.Endtime) {            
            $dwjobNOB.Duration = Get-UserFriendlyTimeSpane ($dwjobNOB.EndTime - $dwjobNOB.StartTime)
        }        
    }
    AppendOutputToFileInTargetFolder ($dwjobsNOB | Sort-Object -Property Name | ft )  "Get-SCDWJob_NumberOfBatches_5.txt"
}

function Collect_DW_MPs() {
    $allMPs=(Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSMDW -SQLDatabase $SQLDatabase_SCSMDW -Query "select ManagementPackId, MPName from ManagementPack")
    foreach ($currMP in $allMPs.Tables[0]) {
        $MPId = $currMP.ManagementPackId
        $MPName = $currMP.MPName
        AppendOutputToFileInTargetFolder ((Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSMDW -SQLDatabase $SQLDatabase_SCSMDW -Query "select convert(xml,MPXML) as MPXML from ManagementPack where ManagementPackId='$MPId'").Tables[0].MPXML) "$($MPName)___$MPId.xml"
        MoveFileInTargetFolder "$($MPName)___$MPId.xml" "MPXml"
    }
}

function Collect_SetDWRoleFound() {
    AppendOutputToFileInTargetFolder "This is the DW mgmt server." ScsmRolesFound.txt
    $script:RoleFoundAbbr = "DW"
}

function Collect_SqlErrorLogFiles_DW() {
    GetSqlErrorLogFiles (GetMachineNameFromSqlInstance $SQLInstance_SCSMDW) $SQLDatabase_SCSMDW
}

function Collect_SQL_CMDWDataMart() {
    if ($SQLInstance_SCSMDW_CMDM -ne $null  -and  $SQLDatabase_SCSMDW_CMDM -ne $null) {
        $SQL_SCSM_DWCMDM =@{}
        $SQL_SCSM_DWCMDM['SQL_TableSizeInfo_CMDWDataMart']=$SQL_SCSM_Shared['SQL_TableSizeInfo']
        $SQL_SCSM_DWCMDM['SQL_DWFactConstraintsIssue_CMDWDatamart']=$SQL_DWFactConstraintsIssue
        $SQL_SCSM_DWCMDM['SQL_DWFactConstraintsIssue_CMDWDatamart_ForDebugging']=$SQL_DWFactConstraintsIssue_ForDebugging
        $SQL_SCSM_DWCMDM['SQL_FKIssuesInDW_CMDWDatamart']=$SQL_DWFKIssues
        $SQL_SCSM_DWCMDM['SQL_DWFactEntityUpgradeIssue_CMDWDataMart']=$SQL_DWFactEntityUpgradeIssue
        $SQL_SCSM_DWCMDM['SQL_DWEtlConfiguration_CMDWDataMart']=$SQL_DWEtlConfiguration
        $SQL_SCSM_DWCMDM['SQL_DWEtlWarehouseEntityGroomingHistory_CMDWDataMart']=$SQL_DWEtlWarehouseEntityGroomingHistory
        $SQL_SCSM_DWCMDM['SQL_DWEtlWarehouseEntityGroomingInfo_CMDWDataMart']=$SQL_DWEtlWarehouseEntityGroomingInfo
        $SQL_SCSM_DWCMDM['SQL_information_schema_columns_CMDWDataMart']=$SQL_SCSM_Shared['SQL_information_schema_columns']
        $SQL_SCSM_DWCMDM['SQL_indexes_CMDWDataMart']=$SQL_SCSM_Shared['SQL_indexes']

        foreach($SQL_SCSM_DWCMDM_Text in $SQL_SCSM_DWCMDM.Keys) {        
            SaveSQLResultSetsToFiles $SQLInstance_SCSMDW_CMDM $SQLDatabase_SCSMDW_CMDM ($SQL_SCSM_DWCMDM[$SQL_SCSM_DWCMDM_Text]) "$SQL_SCSM_DWCMDM_Text.csv"    
        }
    }
}

function Collect_SQL_DWDataMart() {
    $SQL_SCSM_DWDM =@{}
    $SQL_SCSM_DWDM['SQL_TableSizeInfo_DWDataMart']=$SQL_SCSM_Shared['SQL_TableSizeInfo']
    $SQL_SCSM_DWDM['SQL_DwDMDataRetention'] = @'
    select etl.GetConfigurationInfo('dwmaintenance.grooming', 'RetentionPeriodInMinutes.Default')/60/24 as "DWDatamart data retention in days",etl.GetConfigurationInfo('dwmaintenance.grooming', 'RetentionPeriodInMinutes.Default')/60/24/365 as "DWDatamart data retention in years"
'@
    $SQL_SCSM_DWDM['SQL_DWFactConstraintsIssue_DWDatamart']=$SQL_DWFactConstraintsIssue
    $SQL_SCSM_DWDM['SQL_DWFactConstraintsIssue_DWDatamart_ForDebugging']=$SQL_DWFactConstraintsIssue_ForDebugging
    $SQL_SCSM_DWDM['SQL_FKIssuesInDW_DWDatamart']=$SQL_DWFKIssues
    $SQL_SCSM_DWDM['SQL_DWFactEntityUpgradeIssue_DWDataMart']=$SQL_DWFactEntityUpgradeIssue
    $SQL_SCSM_DWDM['SQL_DWEtlConfiguration_DWDataMart']=$SQL_DWEtlConfiguration
    $SQL_SCSM_DWDM['SQL_DWEtlWarehouseEntityGroomingHistory_DWDataMart']=$SQL_DWEtlWarehouseEntityGroomingHistory
    $SQL_SCSM_DWDM['SQL_DWEtlWarehouseEntityGroomingInfo_DWDataMart']=$SQL_DWEtlWarehouseEntityGroomingInfo
    $SQL_SCSM_DWDM['SQL_information_schema_columns_DWDataMart']=$SQL_SCSM_Shared['SQL_information_schema_columns']
    $SQL_SCSM_DWDM['SQL_indexes_DWDataMart']=$SQL_SCSM_Shared['SQL_indexes']

    foreach($SQL_SCSM_DWDM_Text in $SQL_SCSM_DWDM.Keys) {
        SaveSQLResultSetsToFiles $SQLInstance_SCSMDW_DM $SQLDatabase_SCSMDW_DM ($SQL_SCSM_DWDM[$SQL_SCSM_DWDM_Text]) "$SQL_SCSM_DWDM_Text.csv"    
    }
}

function Collect_SQL_DWRepository() {
    $SQL_SCSM_DWRep =@{}
    $SQL_SCSM_DWRep['SQL_TableSizeInfo_DWRepository']=$SQL_SCSM_Shared['SQL_TableSizeInfo']
    $SQL_SCSM_DWRep['SQL_DWFactConstraintsIssue_DWRep']=$SQL_DWFactConstraintsIssue
    $SQL_SCSM_DWRep['SQL_DWFactConstraintsIssue_DWRep_ForDebugging']=$SQL_DWFactConstraintsIssue_ForDebugging
    $SQL_SCSM_DWRep['SQL_DWFactEntityUpgradeIssue_DWRep']=$SQL_DWFactEntityUpgradeIssue
    $SQL_SCSM_DWRep['SQL_DWEtlConfiguration_DWRep']=$SQL_DWEtlConfiguration
    $SQL_SCSM_DWRep['SQL_DWEtlWarehouseEntityGroomingHistory_DWRep']=$SQL_DWEtlWarehouseEntityGroomingHistory
    $SQL_SCSM_DWRep['SQL_DWEtlWarehouseEntityGroomingInfo_DWRep']=$SQL_DWEtlWarehouseEntityGroomingInfo
    $SQL_SCSM_DWRep['SQL_information_schema_columns_DWRep']=$SQL_SCSM_Shared['SQL_information_schema_columns']
    $SQL_SCSM_DWRep['SQL_indexes_DWRep']=$SQL_SCSM_Shared['SQL_indexes']

    foreach($SQL_SCSM_DWRep_Text in $SQL_SCSM_DWRep.Keys) {
        SaveSQLResultSetsToFiles $SQLInstance_SCSMDW_Rep $SQLDatabase_SCSMDW_Rep ($SQL_SCSM_DWRep[$SQL_SCSM_DWRep_Text]) "$SQL_SCSM_DWRep_Text.csv"    
    }
}

function Collect_SQL_DWStagingAndConfig() {
    $SQL_SCSM_DW =@{}
    $SQL_SCSM_DW['SQL_InfraBatch'] = @'
select p.ProcessName, b.StatusId, * 
from infra.Batch b inner join infra.Process p on b.ProcessId = p.ProcessId
	inner join infra.ProcessCategory pc on p.ProcessCategoryId=pc.ProcessCategoryId 
where b.StatusId!=6 and b.StatusId!=3
'@
    $SQL_SCSM_DW['SQL_InfraWorkItem'] = @'
select pm.VertexName, wi.StatusId as WIStatus,b.StatusId as BatchStatus, p.ProcessName,p.ProcessDescription,ErrorSummary,* 
from Infra.WorkItem wi
	inner join infra.ProcessModule pm on wi.ProcessModuleId=pm.ProcessModuleId
	inner join infra.Batch b on wi.BatchId = b.BatchId
	inner join infra.Process p on b.ProcessId = p.ProcessId
where wi.StatusId !=6 and wi.StatusId!=3
 order by 14 desc
'@
    $SQL_SCSM_DW['SQL_InfraWorkItem_ForActiveBatches'] = @'
select pm.VertexName, wi.StatusId as WIStatus,b.StatusId as BatchStatus, p.ProcessName,p.ProcessDescription,ErrorSummary,* 
from Infra.WorkItem wi
	inner join infra.ProcessModule pm on wi.ProcessModuleId=pm.ProcessModuleId
	inner join infra.Batch b on wi.BatchId = b.BatchId
	inner join infra.Process p on b.ProcessId = p.ProcessId
where b.StatusId not in (3,6)
order by 14 desc
'@
    $SQL_SCSM_DW['SQL_InfraWorkItemDAG'] = @'
select * from Infra.WorkItemDAG order by 1,2,3
'@
    $SQL_SCSM_DW['SQL_LockDetails'] = @'
Select * from lockdetails
'@
    $SQL_SCSM_DW['SQL_DeploySequenceView'] = @'
select * from DeploySequenceView where DeploymentStatusId!=6
'@
    $SQL_SCSM_DW['SQL_DeploySequenceStaging'] = @'
select * from DeploySequenceStaging
'@
    $SQL_SCSM_DW['SQL_DeployItemStaging'] = @'
select statusid, outcome,* from DeployItemStaging where StatusId!=6 order by 1
'@
    $SQL_SCSM_DW['SQL_InfraProcess'] = @'
select * from infra.Process order by ProcessId
'@
    $SQL_SCSM_DW['SQL_InfraProcessHistory'] = @'
select * from infra.ProcessHistory order by ProcessId
'@
    $SQL_SCSM_DW['SQL_InfraBatch_Recent20000'] = @'
select top 20000 p.ProcessName,b.* from infra.Batch b left join infra.Process p on b.ProcessId=p.ProcessId order by b.BatchId desc
'@
    $SQL_SCSM_DW['SQL_InfraBatchHistory_Recent20000'] = @'
select top 20000 p.ProcessName,bh.* from infra.BatchHistory bh left join infra.Process p on bh.ProcessId=p.ProcessId order by bh.BatchId desc
'@
    $SQL_SCSM_DW['SQL_InfraWorkItem_Recent20000'] = @'
select top 20000 pm.VertexName,p.ProcessName,wi.* from infra.WorkItem wi left join infra.ProcessModule pm on wi.ProcessModuleId=pm.ProcessModuleId left join infra.Process p on pm.ProcessId=p.ProcessId order by wi.WorkItemId desc
'@
    $SQL_SCSM_DW['SQL_InfraWorkItemHistory_Recent20000'] = @'
select top 20000 pm.VertexName,p.ProcessName,wih.* from infra.WorkItemHistory wih left join infra.ProcessModule pm on wih.ProcessModuleId=pm.ProcessModuleId left join infra.Process p on pm.ProcessId=p.ProcessId order by wih.WorkItemId desc
'@
    $SQL_SCSM_DW['SQL_SSRS_Info'] = @'
select DataService_98B2DDF9_D9FD_9297_85D3_FCF36F1D016B as SsrsUrl from MT_Microsoft$SystemCenter$ResourceAccessLayer$SrsResourceStore
'@
    $SQL_SCSM_DW['SQL_SSAS_Info'] = @'
select Server_48B308F9_CF0E_0F74_83E1_0AEB1B58E2FA as SsasServerName,DataService_98B2DDF9_D9FD_9297_85D3_FCF36F1D016B as SsasDBName from MT_Microsoft$SystemCenter$ResourceAccessLayer$ASResourceStore
'@
    $SQL_SCSM_DW['SQL_etl.WarehouseEntity'] = @'
select * from etl.WarehouseEntity
'@
    $SQL_SCSM_DW['SQL_etl.WarehouseColumn'] = @'
select * from etl.WarehouseColumn
'@
    $SQL_SCSM_DW['SQL_etl.WarehouseModule'] = @'
select * from etl.WarehouseModule
'@
    $SQL_SCSM_DW['SQL_etl.WarehouseModuleDependency'] = @'
select * from etl.WarehouseModuleDependency
'@
    $SQL_SCSM_DW['SQL_etl.WarehouseModuleDependency_Combined'] = @'
select wm.ModuleName,we.WarehouseEntityName ,* 
from etl.WarehouseModuleDependency wmd
left join etl.WarehouseEntity we on wmd.WarehouseEntityId=we.WarehouseEntityId
left join etl.WarehouseModule wm on wmd.ModuleId=wm.ModuleId
left join etl.WarehouseModuleType wmt on wm.ModuleTypeId=wmt.ModuleTypeId
left join etl.Source s on we.SourceId=s.SourceId
left join etl.WarehouseEntityType wet on we.WarehouseEntityTypeId=wet.WarehouseEntityTypeId
order by 1,2
'@
    $SQL_SCSM_DW['SQL_DW_DataSources'] = @'
select DataSourceName_AC09B683_AE61_BDCA_6383_2007DB60859D as DataSourceName
,lt_DST.LTValue as DataSourceType
,DateRegistered_E3D84601_0917_3E29_5524_74CDFDEDB077 as DateRegistered
,lt_RegStatus.LTValue as RegistrationStatus
,ds.DatabaseServer_CD2D9C2A_39C2_CE05_D84C_AC42E429D191 as SqlInstance
,ds.Database_D59DC40A_E438_1A05_C231_E3BD50E5DD44 as DbName
,ds.SdkServer_0E227991_743F_4854_FF8B_273C1688DFEB as SDKServerName
,DS.* 
from MTV_Microsoft$SystemCenter$DataWarehouse$CMDBSource DS
left join LocalizedText lt_DST on DS.DatasourceType_284CCCB2_4410_14D1_B5F9_7469B26FB5C5 = lt_DST.LTStringId and lt_DST.LanguageCode='ENU' and lt_DST.LTStringType=1
left join LocalizedText lt_RegStatus on DS.RegistrationStatus_7B26B8DE_F3D4_6CF3_5280_60DCD1CE3DDB = lt_RegStatus.LTStringId and lt_RegStatus.LanguageCode='ENU' and lt_RegStatus.LTStringType=1
'@
    $SQL_SCSM_DW['SQL_SynchronizationJobDetails'] = @'
--This shows the Job Progress values and Synchronization details list of MPSyncJob in Console DW/Jobs/MpSyncJob
DECLARE @Path TABLE
(
S uniqueidentifier,
CS int,
T0 uniqueidentifier,
CT0 int,
T1 uniqueidentifier,
CT1 int
);
INSERT INTO @Path
SELECT [PC].[S],0 AS CS,[PC].[T0],1 AS CT0,[PC].[T1],2 AS CT1
FROM (SELECT [S].[BaseManagedEntityId] AS [S],0 AS CS,[R0].[TargetEntityId] AS [T0],1 AS CRT0,[R1].[TargetEntityId] AS [T1],2 AS CRT1
FROM dbo.TypedManagedEntity AS S 
 LEFT OUTER JOIN dbo.Relationship AS R0 
     ON (R0.[SourceEntityId] = S.[BaseManagedEntityId]
     AND R0.[RelationshipTypeId] = (select RelationshipTypeId from RelationshipType rst where RelationshipTypeName='SynchronizationForSourceManagementPack') 
     AND R0.[IsDeleted] = 0)
 LEFT OUTER JOIN dbo.Relationship AS R1 
     ON (R1.[SourceEntityId] = S.[BaseManagedEntityId]
     AND R1.[RelationshipTypeId] = (select RelationshipTypeId from RelationshipType rst where RelationshipTypeName='SynchronizationForSource') 
     AND R1.[IsDeleted] = 0)
WHERE (S.[ManagedTypeId] = (select ManagedTypeId from ManagedType where TypeName = 'Microsoft.SystemCenter.DataWarehouse.SynchronizationLog') 
     AND S.[IsDeleted] = 0)) AS PC OPTION (KEEP PLAN)
declare @BatchId int, @DataSource nvarchar(max), @ManagementPack nvarchar(max), @Status nvarchar(max), @MPVersion nvarchar(max), @key nvarchar(max)
declare @Result Table (BatchId int, DataSource nvarchar(max), ManagementPack nvarchar(max), Status nvarchar(max), MPVersion nvarchar(max), [key] nvarchar(max))
declare c cursor local FORWARD_ONLY READ_ONLY for
	SELECT 
	SLOG.BatchId_AD2C9445_8EFE_29BB_C0B9_D2D5A3CF9FF1 as BatchId
	,DwDataSource.DataSourceName_AC09B683_AE61_BDCA_6383_2007DB60859D as DataSource
	,MP.ManagementPackName_BC9C558E_DA29_B720_4A0F_FEF17184671F as ManagementPack
	,lt.LTValue as Status
	,mp.ManagementPackVersion_81B2EA0C_5781_76A5_298B_52EE32A8C93F as MPVersion
	,cast(DwDataSource.DataSourceName_AC09B683_AE61_BDCA_6383_2007DB60859D as nvarchar(max))+cast(MP.ManagementPackId_11A9EC2C_EA14_2995_9F96_CEE1C71F28F6 as nvarchar(max)) as [key]  
	FROM @Path AS PC 
	inner join dbo.MTV_Microsoft$SystemCenter$DataWarehouse$SynchronizationLog AS SLog on PC.S = SLOG.BaseManagedEntityId
	inner join LocalizedText lt on SLog.Action_E1ADF345_0F5E_E972_EB9A_1A4056B66E66 = lt.LTStringId and LTStringType=1 and lt.LanguageCode='ENU'
	inner join  MTV_Microsoft$SystemCenter$DataWarehouse$ManagementPack as MP on PC.T0 = MP.BaseManagedEntityId
	inner join MTV_Microsoft$SystemCenter$DataWarehouse$CMDBSource as DwDataSource on PC.T1 = DwDataSource.BaseManagedEntityId
	order by 4,3,2
open c; while 1=1 begin; fetch c into @BatchId, @DataSource, @ManagementPack, @Status, @MPVersion, @key ; if @@FETCH_STATUS<>0 break;

	if (select count(*) from @Result where [key] = @key) > 0
    begin
        declare @thisbatchid int = @BatchId
        declare @existingbatchid int; select @existingbatchid=BatchId from @Result where [key] = @key

        if (@thisbatchid > @existingbatchid)
        begin            
			delete @Result where [key] = @key
			insert into @Result Select @BatchId, @DataSource, @ManagementPack, @Status, @MPVersion, @key
        end
        else if (@thisbatchid = @existingbatchid)
        begin                                                                     
            
                if @Status = 'Associated' or @Status = 'Disassociated'                
                begin
                    delete @Result where [key] = @key
					insert into @Result Select @BatchId, @DataSource, @ManagementPack, @Status, @MPVersion, @key
                end            
        end                                                                 
    end
    else
    begin
        insert into @Result Select @BatchId, @DataSource, @ManagementPack, @Status, @MPVersion, @key
    end 

end; close c; deallocate c;

--That's the Job Progress area in Console DW/Jobs/MpSyncJob
select cast(sum(case when Status in ('Associated','Disassociated') then 1 else 0 end) as nvarchar(max)) +'/'+ cast(count(*) as nvarchar(max)) as [Job Progress]
from @Result

--That's the list in Console DW/Jobs/MpSyncJob/Synchronization Job Details
--sorted by Status descending order, so that incomplete syncs will appear at the top.
--ignore the last column, it's only for debugging purposes.
select * from @Result
order by 4 desc,3,2,5 
'@

    # We assume that DwRep and DWDatamart databasases are on the same SQL instance as DWStagingAndConfig
    $SQL_SCSM_DW['SQL_NewestWorkItemsInDW'] = @'
--IR
select * from (select top 1 'IR in DWRepository' as 'WI type',Id as 'Newest ID',CreatedDate as 'Created at', datediff(MINUTE,CreatedDate,GETUTCDATE()) as 'Minutes Behind' from DWRepository.dbo.IncidentDim where IncidentDimKey!=0 order by 3 desc) as sub1 
union all
select * from (select top 1 'IR in DWDataMart' as 'WI type'  ,Id as 'Newest ID',CreatedDate as 'Created at', datediff(MINUTE,CreatedDate,GETUTCDATE()) as 'Minutes Behind' from DWDataMart.dbo.IncidentDim where IncidentDimKey!=0 order by 3 desc) as sub1 
--SR
select * from (select top 1 'SR in DWRepository' as 'WI type',Id as 'Newest ID',CreatedDate as 'Created at', datediff(MINUTE,CreatedDate,GETUTCDATE()) as 'Minutes Behind' from DWRepository.dbo.ServiceRequestDim where ServiceRequestDimKey!=0 order by 3 desc) as sub1 
union all
select * from (select top 1 'SR in DWDataMart' as 'WI type'  ,Id as 'Newest ID',CreatedDate as 'Created at', datediff(MINUTE,CreatedDate,GETUTCDATE()) as 'Minutes Behind' from DWDataMart.dbo.ServiceRequestDim where ServiceRequestDimKey!=0 order by 3 desc) as sub1 
--CR
select * from (select top 1 'CR in DWRepository' as 'WI type',Id as 'Newest ID',CreatedDate as 'Created at', datediff(MINUTE,CreatedDate,GETUTCDATE()) as 'Minutes Behind' from DWRepository.dbo.ChangeRequestDim where ChangeRequestDimKey!=0 order by 3 desc) as sub1 
union all
select * from (select top 1 'CR in DWDataMart' as 'WI type'  ,Id as 'Newest ID',CreatedDate as 'Created at', datediff(MINUTE,CreatedDate,GETUTCDATE()) as 'Minutes Behind' from DWDataMart.dbo.ChangeRequestDim where ChangeRequestDimKey!=0 order by 3 desc) as sub1 

'@
    $SQL_SCSM_DW['SQL_OldestWorkItemsInDW'] = @'
select * from (select top 1 'IR in DWRepository' as 'WI type',Id as 'Oldest ID',CreatedDate as 'Created at' from DWRepository.dbo.IncidentDim where IncidentDimKey!=0 order by 3 ) as sub1 
union all
select * from (select top 1 'IR in DWDataMart' as 'WI type'  ,Id as 'Oldest ID',CreatedDate as 'Created at' from DWDataMart.dbo.IncidentDim where IncidentDimKey!=0 order by 3 ) as sub1 

select * from (select top 1 'SR in DWRepository' as 'WI type',Id as 'Oldest ID',CreatedDate as 'Created at' from DWRepository.dbo.ServiceRequestDim where ServiceRequestDimKey!=0 order by 3 ) as sub1 
union all
select * from (select top 1 'SR in DWDataMart' as 'WI type'  ,Id as 'Oldest ID',CreatedDate as 'Created at' from DWDataMart.dbo.ServiceRequestDim where ServiceRequestDimKey!=0 order by 3 ) as sub1 

select * from (select top 1 'CR in DWRepository' as 'WI type',Id as 'Oldest ID',CreatedDate as 'Created at' from DWRepository.dbo.ChangeRequestDim where ChangeRequestDimKey!=0 order by 3 ) as sub1 
union all
select * from (select top 1 'CR in DWDataMart' as 'WI type'  ,Id as 'Oldest ID',CreatedDate as 'Created at' from DWDataMart.dbo.ChangeRequestDim where ChangeRequestDimKey!=0 order by 3 ) as sub1 

'@ 
    $SQL_SCSM_DW['SQL_WorkItemsInDW_ByMonth'] = @'
--IR
select coalesce(sub1DwRep.year,sub1DwDm.year) as Year, coalesce(sub1DwRep.month,sub1DwDm.month) as Month,'IR' as 'WI Type', coalesce(sub1DwRep.count,0) as "Count in DWRep", coalesce(sub1DwDM.count,0) as "Count in DWDataMart", coalesce(sub1DwDM.count,0) - coalesce(sub1DwRep.count,0) as "Diff (DM-Rep)" from (
	select datepart(year,CreatedDate) year,datepart(month,CreatedDate) month,count(*) count
	from DWRepository.dbo.IncidentDim
	where IncidentDimKey!=0
	group by datepart(year,CreatedDate),datepart(month,CreatedDate)
) as sub1DwRep
full outer join (
	select datepart(year,CreatedDate) year,datepart(month,CreatedDate) month,count(*) count
	from DWDataMart.dbo.IncidentDim
	where IncidentDimKey!=0
	group by datepart(year,CreatedDate),datepart(month,CreatedDate)
) as sub1DwDM
on sub1DwRep.year = sub1DwDM.year and sub1DwRep.month = sub1DwDM.month
order by coalesce(sub1DwRep.year,sub1DwDm.year), coalesce(sub1DwRep.month,sub1DwDm.month) 
--SR
select coalesce(sub1DwRep.year,sub1DwDm.year) as Year, coalesce(sub1DwRep.month,sub1DwDm.month) as Month,'SR' as 'WI Type', coalesce(sub1DwRep.count,0) as "Count in DWRep", coalesce(sub1DwDM.count,0) as "Count in DWDataMart", coalesce(sub1DwDM.count,0) - coalesce(sub1DwRep.count,0) as "Diff (DM-Rep)" from (
	select datepart(year,CreatedDate) year,datepart(month,CreatedDate) month,count(*) count
	from DWRepository.dbo.ServiceRequestDim
	where ServiceRequestDimKey!=0
	group by datepart(year,CreatedDate),datepart(month,CreatedDate)
) as sub1DwRep
full outer join (
	select datepart(year,CreatedDate) year,datepart(month,CreatedDate) month,count(*) count
	from DWDataMart.dbo.ServiceRequestDim
	where ServiceRequestDimKey!=0
	group by datepart(year,CreatedDate),datepart(month,CreatedDate)
) as sub1DwDM
on sub1DwRep.year = sub1DwDM.year and sub1DwRep.month = sub1DwDM.month
order by coalesce(sub1DwRep.year,sub1DwDm.year), coalesce(sub1DwRep.month,sub1DwDm.month) 
--CR
select coalesce(sub1DwRep.year,sub1DwDm.year) as Year, coalesce(sub1DwRep.month,sub1DwDm.month) as Month,'CR' as 'WI Type', coalesce(sub1DwRep.count,0) as "Count in DWRep", coalesce(sub1DwDM.count,0) as "Count in DWDataMart", coalesce(sub1DwDM.count,0) - coalesce(sub1DwRep.count,0) as "Diff (DM-Rep)" from (
	select datepart(year,CreatedDate) year,datepart(month,CreatedDate) month,count(*) count
	from DWRepository.dbo.ChangeRequestDim
	where ChangeRequestDimKey!=0
	group by datepart(year,CreatedDate),datepart(month,CreatedDate)
) as sub1DwRep
full outer join (
	select datepart(year,CreatedDate) year,datepart(month,CreatedDate) month,count(*) count
	from DWDataMart.dbo.ChangeRequestDim
	where ChangeRequestDimKey!=0
	group by datepart(year,CreatedDate),datepart(month,CreatedDate)
) as sub1DwDM
on sub1DwRep.year = sub1DwDM.year and sub1DwRep.month = sub1DwDM.month
order by coalesce(sub1DwRep.year,sub1DwDm.year), coalesce(sub1DwRep.month,sub1DwDm.month) 
'@ 

    if ($SQLDatabase_SCSMDW_Rep -ne "DwRepository"){
        $SQL_SCSM_DW['SQL_NewestWorkItemsInDW'] = $SQL_SCSM_DW['SQL_NewestWorkItemsInDW'] -replace 'DwRepository.', ($SQLDatabase_SCSMDW_Rep +'.' )
        $SQL_SCSM_DW['SQL_OldestWorkItemsInDW'] = $SQL_SCSM_DW['SQL_OldestWorkItemsInDW'] -replace 'DwRepository.', ($SQLDatabase_SCSMDW_Rep +'.' )
        $SQL_SCSM_DW['SQL_WorkItemsInDW_ByMonth'] = $SQL_SCSM_DW['SQL_WorkItemsInDW_ByMonth'] -replace 'DwRepository.', ($SQLDatabase_SCSMDW_Rep +'.' )
        $SQL_SCSM_DW['SQL_FKIssuesInDW'] = $SQL_SCSM_DW['SQL_FKIssuesInDW'] -replace 'DwRepository.', ($SQLDatabase_SCSMDW_Rep +'.' )
    }
    if ($SQLDatabase_SCSMDW_DM -ne "DwDataMart"){
        $SQL_SCSM_DW['SQL_NewestWorkItemsInDW'] = $SQL_SCSM_DW['SQL_NewestWorkItemsInDW'] -replace 'DwDataMart.', ($SQLDatabase_SCSMDW_DM +'.' )
        $SQL_SCSM_DW['SQL_OldestWorkItemsInDW'] = $SQL_SCSM_DW['SQL_OldestWorkItemsInDW'] -replace 'DwDataMart.', ($SQLDatabase_SCSMDW_DM +'.' )
        $SQL_SCSM_DW['SQL_WorkItemsInDW_ByMonth'] = $SQL_SCSM_DW['SQL_WorkItemsInDW_ByMonth'] -replace 'DwDataMart.', ($SQLDatabase_SCSMDW_DM +'.' )        
    }

    foreach($SQL_SCSM_DW_Text in $SQL_SCSM_DW.Keys) {        
        SaveSQLResultSetsToFiles $SQLInstance_SCSMDW $SQLDatabase_SCSMDW ($SQL_SCSM_DW[$SQL_SCSM_DW_Text]) "$SQL_SCSM_DW_Text.csv"    
    }

}

function Collect_SQL_DW_Shared() {
    foreach($SqlSharedText in $SQL_SCSM_Shared.Keys) {        
        SaveSQLResultSetsToFiles $SQLInstance_SCSMDW $SQLDatabase_SCSMDW ($SQL_SCSM_Shared[$SqlSharedText]) "$SqlSharedText.csv"    
    }
}

function Collect_SQL_OMDWDataMart() {
    if ($SQLInstance_SCSMDW_OMDM -ne $null  -and  $SQLDatabase_SCSMDW_OMDM -ne $null) {
        $SQL_SCSM_DWOMDM =@{}
        $SQL_SCSM_DWOMDM['SQL_TableSizeInfo_OMDWDataMart']=$SQL_SCSM_Shared['SQL_TableSizeInfo']
        $SQL_SCSM_DWOMDM['SQL_DWFactConstraintsIssue_OMDWDatamart']=$SQL_DWFactConstraintsIssue
        $SQL_SCSM_DWOMDM['SQL_DWFactConstraintsIssue_OMDWDatamart_ForDebugging']=$SQL_DWFactConstraintsIssue_ForDebugging
        $SQL_SCSM_DWOMDM['SQL_FKIssuesInDW_OMDWDatamart']=$SQL_DWFKIssues
        $SQL_SCSM_DWOMDM['SQL_DWFactEntityUpgradeIssue_OMDWDataMart']=$SQL_DWFactEntityUpgradeIssue
        $SQL_SCSM_DWOMDM['SQL_DWEtlConfiguration_OMDWDataMart']=$SQL_DWEtlConfiguration
        $SQL_SCSM_DWOMDM['SQL_DWEtlWarehouseEntityGroomingHistory_OMDWDataMart']=$SQL_DWEtlWarehouseEntityGroomingHistory
        $SQL_SCSM_DWOMDM['SQL_DWEtlWarehouseEntityGroomingInfo_OMDWDataMart']=$SQL_DWEtlWarehouseEntityGroomingInfo
        $SQL_SCSM_DWOMDM['SQL_information_schema_columns_OMDWDataMart']=$SQL_SCSM_Shared['SQL_information_schema_columns']
        $SQL_SCSM_DWOMDM['SQL_indexes_OMDWDataMart']=$SQL_SCSM_Shared['SQL_indexes']

        foreach($SQL_SCSM_DWOMDM_Text in $SQL_SCSM_DWOMDM.Keys) {        
            SaveSQLResultSetsToFiles $SQLInstance_SCSMDW_OMDM $SQLDatabase_SCSMDW_OMDM ($SQL_SCSM_DWOMDM[$SQL_SCSM_DWOMDM_Text]) "$SQL_SCSM_DWOMDM_Text.csv"    
        }
    }
}

function Collect_Test_BetweenDWMSandSQL() {
    AppendOutputToFileInTargetFolder (Test-NetConnection -ComputerName (GetMachineNameFromSqlInstance $SQLInstance_SCSMDW) -Port (GetPortFromSqlInstance $SQLInstance_SCSMDW)) Telnet_FromSMDW_ToSQL.txt 
    AppendOutputToFileInTargetFolder (Test-Connection -ComputerName (GetMachineNameFromSqlInstance $SQLInstance_SCSMDW)) Ping_FromSMDW_ToSQL.txt
}

function Collect_TimeDiffBetweenDWMSandSQL() {
    #Getting the time diff directly (if possible)
    $compNameToCheckTimeDiff = (GetMachineNameFromSqlInstance $SQLInstance_SCSMDW)
    $result = Run2ndOnlyIf1stSucceeds {
        InvokeCommand -computerName $compNameToCheckTimeDiff -scriptBlock {Get-Date}
        }{
        New-TimeSpan -Start (Get-Date) -End $resultOf1 
    }
    AppendOutputToFileInTargetFolder ( $result ) "TimeDiff_BtwMS_AndSQL.txt"

    # additionally, getting the time diff via win32tm
    AppendOutputToFileInTargetFolder ( w32tm.exe /stripchart /dataonly /samples:1 /computer:$compNameToCheckTimeDiff ) "TimeDiff_BtwMS_AndSQL_viaWin32tm.txt"
}

function Collect_FromDW() {
#region DO NOT REMOVE THIS! Exit immediately if script is NOT running on a DW mgmt server
if (-not (IsThisScsmDwMgmtServer)) {
    return
}
#endregion

# Collects info that is specific to only DW servers

    Collect_SetDWRoleFound
    Collect_DWJobs    
    Collect_DWJobs_Last5   
    Collect_DWJobSchedules
    Collect_DWEnvironmentInfo
    Collect_TimeDiffBetweenDWMSandSQL
    Collect_DW_MPs
    Collect_Test_BetweenDWMSandSQL 
    Collect_SqlErrorLogFiles_DW

    Collect_SQL_DW_Shared
    Collect_SQL_DWStagingAndConfig

    #region DO NOT MOVE THIS! To be used in subsequent functions
$SQL_DWFactConstraintsIssue=@'
declare @fixFactDiscrepancies bit = 0	-- set this to 1 for real corrections, but Please take a database backup before !!!
										-- set this to 0 to only show the discrepancies and generate a change script to be applied manually.
--------------------------------------------------------------------
set nocount on
declare @overallIssuesFound bit = 0
declare @allIssuesFixed bit = 1
if @fixFactDiscrepancies = 1 
	print '-- Read-write mode. Fixing issues ...';
else
	print '-- Read-only mode. Only generating a change script ...'	
print ''
----------------------------------
--	begin tran --for debugging only
----------------------------------
declare @initialTrancount int 
set @initialTrancount=@@TRANCOUNT
if @initialTrancount > 0
	print  '-- @initialTrancount : ' + cast(@initialTrancount as nvarchar(max)) 
----------------------------------
declare @dec31Exists bit
set @dec31Exists=0
select @dec31Exists=1 from DateDim where DateKey=20201231 --should exist
if @dec31Exists = 0
begin
	set @overallIssuesFound = 1

	print '--current DateDim contains no row for 2020/12/31' 
	declare @dec31Exists_Script nvarchar(max)
	set @dec31Exists_Script='insert into DateDim values (20201231,	''20201231'',	''Thursday'',	31,	53,	''December'',	12,	2020,	''Q4'',	''Q2'',	6,	2021,	0,	1,	1)'
	print @dec31Exists_Script

	if @fixFactDiscrepancies = 1
	begin	
			begin try
				exec sp_executesql @dec31Exists_Script										
			end try
			begin catch
				set @allIssuesFixed = 0
				print 'Error happened with: ' + @dec31Exists_Script
				print ERROR_MESSAGE()
				goto ErrorHappened
			end catch
	end
end
------------------------------------------------------------------------------------
declare @dateCountAfter2021 int
set @dateCountAfter2021=0
select @dateCountAfter2021=count(*) from DateDim where DateKey between 20210101 and 20501231 --should be 10956
if @dateCountAfter2021 < 10956 
begin
	set @overallIssuesFound = 1

	print '--current DateDim contains less rows between 20210101 and 20501231 =>' + cast(@dateCountAfter2021 as nvarchar(max))
	--declare @startByDateKey int
	--select @startByDateKey=max(DateKey) from DateDim 
	--set @startByDateKey= @startByDateKey + 1

	declare @startByDateKey smalldatetime	--7.2
	select @startByDateKey=max(CalendarDate) from DateDim 
	set @startByDateKey= @startByDateKey + 1

	declare @dateCountAfter2021_Script nvarchar(max)
	set @dateCountAfter2021_Script='exec PopulateDateDim '''+convert(char(8),@startByDateKey,112)+''' , ''20501231'' '  --7.2
	print @dateCountAfter2021_Script

	if @fixFactDiscrepancies = 1
	begin	
			begin try
				exec sp_executesql @dateCountAfter2021_Script										
			end try
			begin catch
				set @allIssuesFixed = 0
				print 'Error happened with: ' + @dateCountAfter2021_Script
				print ERROR_MESSAGE()
				goto ErrorHappened
			end catch
	end
end
-------------------------------------------------------------------------------------------
declare @Months table (MonthName char(3),MonthValue tinyint, LastDay tinyint)
insert into @Months values 
('Jan',1,31),
('Feb',2,28),
('Mar',3,31),
('Apr',4,30),
('May',5,31),
('Jun',6,30),
('Jul',7,31),
('Aug',8,31),
('Sep',9,30),
('Oct',10,31),
('Nov',11,30),
('Dec',12,31)
declare @factName sysname
declare @factTableName sysname
declare @factTables table (name sysname, [Year] smallint, [Month] tinyint, YearMonth int)
declare @isFirstIteration bit, @prevPartitionEndDate int
declare @chkStartDate int, @chkEndDate int
declare @issuesFoundForFact bit 
declare @tmpFact_Script nvarchar(max), @tmpFact_Created bit

declare c cursor local FORWARD_ONLY READ_ONLY for
	select we.WarehouseEntityName --V7
	from etl.WarehouseEntity we 
	inner join etl.WarehouseEntityType wet on we.WarehouseEntityTypeId=wet.WarehouseEntityTypeId and wet.WarehouseEntityTypeName='Fact'	
	order by 1
open c; while 1=1 begin; fetch c into @factName; if @@FETCH_STATUS<>0 break;
	
	set @isFirstIteration=1
	set @issuesFoundForFact=0
	set @prevPartitionEndDate=0
	set @tmpFact_Created=0
	
	declare @currentView nvarchar(max)
	select @currentView=definition from sys.objects o join sys.sql_modules m on m.object_id = o.object_id where o.object_id = object_id('dbo.'+ @factName+'vw') and o.type = 'V' 
	declare @isViewCorrect bit
	set @isViewCorrect = 1
	declare @factColumnList nvarchar(max)
	set @factColumnList = ''
	select @factColumnList=@factColumnList+',['+name+']' from sys.columns where object_id=(select object_id from sys.views where name=@factName+'vw') order by column_id
	set @factColumnList = SUBSTRING(@factColumnList,2,80000) 

	delete @factTables
	insert into @factTables (name) 
	select tp.PartitionName --V7
	from etl.WarehouseEntity we 
		inner join etl.WarehouseEntityType wet on we.WarehouseEntityTypeId=wet.WarehouseEntityTypeId and wet.WarehouseEntityTypeName='Fact'	
		inner join etl.TablePartition tp on we.WarehouseEntityName=tp.WarehouseEntityName
	where tp.WarehouseEntityName = @factName
	order by tp.PartitionName

	declare c2 cursor local FORWARD_ONLY READ_ONLY for
		select name from @factTables;
	open c2; while 1=1 begin; fetch c2 into @factTableName; if @@FETCH_STATUS<>0 break;		
		declare @Year smallint, @Month tinyint, @YearMonth int, @YearName char(4), @MonthName char(3)

		set @MonthName=RIGHT(@factTableName,3)
		set @YearName=RIGHT(@factTableName,8); set @YearName=left(@YearName,4)
		set @year=cast(@YearName as smallint)
		select @Month=MonthValue from @Months where MonthName=@MonthName
		update @factTables
		set [Year]=@Year, [Month]=@Month, YearMonth=@Year*100+@Month
		where name=@factTableName
	end; close c2; deallocate c2;

	declare @minYear smallint, @minMonth tinyint, @maxYear smallint, @maxMonth tinyint, @minYearMonth int, @maxYearMonth int, @prevYearMonth int, @nextAvailableYear smallint, @nextAvailableMonth tinyint, @prevMonthLastDay int
	select @minYear=min(YearMonth)/100, @minMonth=min(YearMonth) % 100, @maxYear=max(YearMonth)/100, @maxMonth=max(YearMonth) % 100, @minYearMonth=min(YearMonth), @maxYearMonth=max(YearMonth)	
	from @factTables
	
	print 'begin tran -- '+@factName
	if @fixFactDiscrepancies = 1 
		begin tran -- 

	declare c3 cursor local FORWARD_ONLY READ_ONLY for
		select name, [Year], [Month], YearMonth from @factTables order by YearMonth
	open c3; while 1=1 begin; fetch c3 into @factTableName, @Year, @Month, @YearMonth; if @@FETCH_STATUS<>0 break;

		set @chkStartDate=0
		set @chkEndDate=0

		--calculate new TP range values
		if @YearMonth = @maxYearMonth
		begin
			set @chkStartDate = @YearMonth*100 + 1
			set @chkEndDate=null
		end
		else
		begin			
			select top 1 @nextAvailableYear=[Year], @nextAvailableMonth=[Month]
			from @factTables
			where YearMonth>@YearMonth
			order by YearMonth		
			if @nextAvailableMonth = 1	set @prevMonthLastDay=(@nextAvailableYear-1)*10000+1231
			else	set @prevMonthLastDay=(@nextAvailableYear*10000) + ((@nextAvailableMonth-1)*100) + (select LastDay from @Months where MonthValue=@nextAvailableMonth-1) 
			
			if @isFirstIteration = 1  
				set @chkStartDate = null
			else 			
				set @chkStartDate = @YearMonth*100 + 1			

			set @chkEndDate = @prevMonthLastDay
		end	
		if @chkEndDate % 100 = 28					
			if ((@chkEndDate / 10000) % 4) = 0	
				set @chkEndDate = @chkEndDate+1	
   --------------------------------------------------------------------------------
		--check TP range values 
		declare @currentRangeStartDate int, @currentRangeEndDate int
		select @currentRangeStartDate=RangeStartDate, @currentRangeEndDate=RangeEndDate from etl.TablePartition where PartitionName = @factTableName
		if 	(@currentRangeStartDate is null and @chkStartDate is not null)	or
			(@currentRangeStartDate is not null and @chkStartDate is null)	or
			(@currentRangeStartDate is not null and @chkStartDate is not null and @currentRangeStartDate != @chkStartDate) or
			(@currentRangeEndDate is null and @chkEndDate is not null)	or
			(@currentRangeEndDate is not null and @chkEndDate is null) or
			(@currentRangeEndDate is not null and @chkEndDate is not null and @currentRangeEndDate != @chkEndDate)
		begin
			set @overallIssuesFound = 1; set @issuesFoundForFact = 1;

			print ' --current range in TP for ' +@factTableName + ' : ' + case when @currentRangeStartDate is null then 'null' else cast(@currentRangeStartDate as nvarchar(max)) end + ' ' + case when @currentRangeEndDate is null then 'null' else cast(@currentRangeEndDate as nvarchar(max)) end
			declare @UpdateTPScript nvarchar(max)
			set @UpdateTPScript=N' update etl.TablePartition set RangeStartDate = ' + case when @chkStartDate is null then 'null' else cast(@chkStartDate as nvarchar(max)) end + ', RangeEndDate = ' + case when @chkEndDate   is null then 'null' else cast(@chkEndDate as nvarchar(max)) end +'	where PartitionName = '''+ @factTableName +''''
			print @UpdateTPScript
			
			if @fixFactDiscrepancies = 1	
				begin try
					exec sp_executesql @UpdateTPScript		
				end try
			begin catch
				set @allIssuesFixed = 0
				print 'Error happened with: ' + @UpdateTPScript
				print ERROR_MESSAGE()
				goto ErrorHappened
			end catch
		end
   --------------------------------------------------------------------------------
		--check values in fact table if they match TP Range dates
   		declare @sqlMinMaxInTable nvarchar(max), @MinDateKey int, @MaxDateKey int
		set @sqlMinMaxInTable =N'select @MinDateKey=min(DateKey), @MaxDateKey=max(DateKey) from ' + @factTableName
		exec sp_executesql @sqlMinMaxInTable, N'@MinDateKey int out, @MaxDateKey int out', @MinDateKey out, @MaxDateKey out

		if @chkStartDate is null
		begin 
			if @MaxDateKey > @chkEndDate
			begin
				set @overallIssuesFound = 1; set @issuesFoundForFact = 1;				

				set @tmpFact_Script=' IF OBJECT_ID(''Tmp_'+@factName+''') IS NULL 	select top 0 * into Tmp_'+@factName+' from '+@factName+'vw'
				set @tmpFact_Created=1
				print @tmpFact_Script

				declare @sql_MaxDateKeyGTchkEndDate nvarchar(max), @rowCount_MaxDateKeyGTchkEndDate int
				set @sql_MaxDateKeyGTchkEndDate =N'select @rowCount_MaxDateKeyGTchkEndDate=count(*) from '+@factTableName+' where DateKey > '+cast(@chkEndDate as nvarchar(max))
				exec sp_executesql @sql_MaxDateKeyGTchkEndDate, N'@rowCount_MaxDateKeyGTchkEndDate int out', @rowCount_MaxDateKeyGTchkEndDate out
				print ' --current '+@factTableName+' has '+cast(@rowCount_MaxDateKeyGTchkEndDate as nvarchar(max))+' rows that are greater than the new TP.RangeEndDate ' + cast(@chkEndDate as nvarchar(max))
				declare @MaxDateKeyGTchkEndDate_Script nvarchar(max)
			
				set @MaxDateKeyGTchkEndDate_Script=
				' delete from '+@factTableName+' output '+REPLACE(@factColumnList,'[','deleted.[')+' into Tmp_'+@factName+' ('+@factColumnList+')'				
				+' where DateKey > '+cast(@chkEndDate as nvarchar(max))
				print @MaxDateKeyGTchkEndDate_Script

				if @fixFactDiscrepancies = 1
				begin	
					begin try
						exec sp_executesql @tmpFact_Script
						exec sp_executesql @MaxDateKeyGTchkEndDate_Script										
					end try
					begin catch
						set @allIssuesFixed = 0
						print 'Error happened with: ' + @MaxDateKeyGTchkEndDate_Script
						print ERROR_MESSAGE()
						goto ErrorHappened
					end catch
				end
			end
		end

		else if @chkEndDate is null
		begin 
			if @MinDateKey < @chkStartDate
			begin
				set @overallIssuesFound = 1; set @issuesFoundForFact = 1;

				set @tmpFact_Script=' IF OBJECT_ID(''Tmp_'+@factName+''') IS NULL 	select top 0 * into Tmp_'+@factName+' from '+@factName+'vw'
				set @tmpFact_Created=1
				print @tmpFact_Script

				declare @sql_MinDateKeyLTchkStartDate nvarchar(max), @rowCount_MinDateKeyLTchkStartDate int
				set @sql_MinDateKeyLTchkStartDate =N'select @rowCount_MinDateKeyLTchkStartDate=count(*) from '+@factTableName+' where DateKey < '+cast(@chkStartDate as nvarchar(max))
				exec sp_executesql @sql_MinDateKeyLTchkStartDate, N'@rowCount_MinDateKeyLTchkStartDate int out', @rowCount_MinDateKeyLTchkStartDate out
				print ' --current '+@factTableName+' has '+cast(@rowCount_MinDateKeyLTchkStartDate as nvarchar(max))+' rows that are less than the new TP.RangeStartDate ' + cast(@chkStartDate as nvarchar(max))
				declare @MinDateKeyLTchkStartDate_Script nvarchar(max)

				set @MinDateKeyLTchkStartDate_Script=
				' delete from '+@factTableName+' output '+REPLACE(@factColumnList,'[','deleted.[')+' into Tmp_'+@factName+' ('+@factColumnList+')'				
				+' where DateKey < '+cast(@chkStartDate as nvarchar(max))
				print @MinDateKeyLTchkStartDate_Script

				if @fixFactDiscrepancies = 1
				begin	
					begin try
						exec sp_executesql @tmpFact_Script
						exec sp_executesql @MinDateKeyLTchkStartDate_Script										
					end try
					begin catch
						set @allIssuesFixed = 0
						print 'Error happened with: ' + @MinDateKeyLTchkStartDate_Script
						print ERROR_MESSAGE()
						goto ErrorHappened
					end catch
				end
			end
		end

		else
		begin 
			if @MinDateKey < @chkStartDate or @MaxDateKey > @chkEndDate
			begin
				set @overallIssuesFound = 1; set @issuesFoundForFact = 1;

				set @tmpFact_Script=' IF OBJECT_ID(''Tmp_'+@factName+''') IS NULL 	select top 0 * into Tmp_'+@factName+' from '+@factName+'vw'
				set @tmpFact_Created=1
				print @tmpFact_Script

				declare @sql_MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate nvarchar(max), @rowCount_MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate int
				set @sql_MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate =N'select @rowCount_MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate=count(*) from '+@factTableName+' where DateKey < '+cast(@chkStartDate as nvarchar(max))+ ' or DateKey > '+cast(@chkEndDate as nvarchar(max))
				exec sp_executesql @sql_MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate, N'@rowCount_MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate int out', @rowCount_MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate out
				print ' --current '+@factTableName+' has '+cast(@rowCount_MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate as nvarchar(max))+' rows that are less than the new TP.RangeStartDate ' + cast(@chkStartDate as nvarchar(max))+' or greater than the new TP.RangeEndDate ' + cast(@chkEndDate as nvarchar(max))
				declare @MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate_Script nvarchar(max)
				set @MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate_Script=
				' delete from '+@factTableName+' output '+REPLACE(@factColumnList,'[','deleted.[')+' into Tmp_'+@factName+' ('+@factColumnList+')'				
				+' where DateKey < '+cast(@chkStartDate as nvarchar(max))+ ' or DateKey > '+cast(@chkEndDate as nvarchar(max))
				print @MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate_Script

				if @fixFactDiscrepancies = 1
				begin	
					begin try
						exec sp_executesql @tmpFact_Script
						exec sp_executesql @MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate_Script										
					end try
					begin catch
						set @allIssuesFixed = 0
						print 'Error happened with: ' + @MinDateKeyLTchkStartDateORMaxDateKeyGTchkEndDate_Script
						print ERROR_MESSAGE()
						goto ErrorHappened
					end catch
				end
			end
		end
   --------------------------------------------------------------------------------
		--check constraints
		declare @currentChk nvarchar(max)
		set @currentChk=''
		select @currentChk=definition from sys.check_constraints where name = @factTableName + '_Chk'
		set @currentChk = REPLACE(@currentChk,'(','')
		set @currentChk = REPLACE(@currentChk,')','')

		declare @correctChk nvarchar(max) 
		set @correctChk = ''
		if @chkStartDate is not null
			set @correctChk = '[DateKey]>='+ cast(@chkStartDate as nvarchar(max))
		if @chkStartDate is not null  and @chkEndDate is not null
			set @correctChk = @correctChk + ' AND '
		if @chkEndDate is not null
			set @correctChk = @correctChk + '[DateKey]<='+ cast(@chkEndDate as nvarchar(max))

		declare @checkConstraintCount int --V7
		select @checkConstraintCount=count(*) from sys.check_constraints where parent_object_id=OBJECT_ID(@factTableName)

		declare @chkScript nvarchar(max) 
		set @chkScript= ''
		if @currentChk != @correctChk or @checkConstraintCount > 1
		begin
			set @overallIssuesFound = 1; set @issuesFoundForFact = 1;
			
			if @checkConstraintCount > 1 --V7
			begin
				print ' --current '+ @factTableName+' has more than 1 check constraint : '+cast(@checkConstraintCount as nvarchar(max))
				declare @chkConstraintNameToDelete sysname
				declare cCheckConstraints cursor local FORWARD_ONLY READ_ONLY for
					select name from sys.check_constraints where parent_object_id=OBJECT_ID(@factTableName) 
				open cCheckConstraints; while 1=1 begin; fetch cCheckConstraints into @chkConstraintNameToDelete; if @@FETCH_STATUS<>0 break;
					set @chkScript = @chkScript + ' ALTER TABLE dbo.'+ @factTableName +' DROP CONSTRAINT '+ @chkConstraintNameToDelete +'; ' 
				end; close cCheckConstraints; deallocate cCheckConstraints;
			end
			else if @currentChk != '' 
			begin
				print ' --current '+ @factTableName+'_chk: ' + @currentChk
				set @chkScript = @chkScript + ' ALTER TABLE dbo.'+ @factTableName +' DROP CONSTRAINT '+ @factTableName +'_Chk; '			
			end
					
			set @chkScript = @chkScript + ' ALTER TABLE [dbo].['+ @factTableName +']  WITH CHECK ADD  CONSTRAINT ['+ @factTableName +'_Chk] CHECK  ('+ @correctChk +'); ALTER TABLE [dbo].['+ @factTableName +'] CHECK CONSTRAINT ['+ @factTableName +'_Chk]'
			print @chkScript			
			if @fixFactDiscrepancies = 1	
			begin try
				exec sp_executesql @chkScript				
			end try
			begin catch
				set @allIssuesFixed = 0
				print 'Error happened with: ' + @chkScript
				print ERROR_MESSAGE()				
				goto ErrorHappened
			end catch			
		end

	 --------------------------------------------------------------------------------
	   --check view
		if CHARINDEX(@factTableName, @currentView)=0
		begin
			set @overallIssuesFound = 1; set @issuesFoundForFact = 1;

			set @isViewCorrect = 0
			print ' --'+@factTableName +' not in view.'
		end		

		if @isFirstIteration =1 set @isFirstIteration=0

	end; close c3; deallocate c3; -- of partition cursor
  --------------------------------------------------------------------------------

	--check for orphaned tables
	declare @orphanedTableCount int
	declare @OrphanedTables table (TableName sysname)
	delete @OrphanedTables
	insert into @OrphanedTables
	select t.name
	from etl.WarehouseEntity we 
		inner join etl.WarehouseEntityType wet on we.WarehouseEntityTypeId=wet.WarehouseEntityTypeId and wet.WarehouseEntityTypeName='Fact'	
		inner join sys.tables t on t.name like we.WarehouseEntityName + '\_____\____' escape '\' 
	where we.WarehouseEntityName = @factName
		and not exists(
		select tp.PartitionName
		from etl.WarehouseEntity we 
			inner join etl.WarehouseEntityType wet on we.WarehouseEntityTypeId=wet.WarehouseEntityTypeId and wet.WarehouseEntityTypeName='Fact'	
			inner join etl.TablePartition tp on we.WarehouseEntityName=tp.WarehouseEntityName
		where tp.PartitionName=t.name
	)
	select @orphanedTableCount=count(*) from @OrphanedTables
	-------------------------------------------------------------------------------------------
	--re-create views
	if @isViewCorrect = 0 or @orphanedTableCount > 0 
	begin
		--declare @dropView_Script nvarchar(max)
		--set @dropView_Script=' drop view '+@factName+'vw'
		--print @dropView_Script

		declare @factGuid uniqueidentifier
		select @factGuid=EntityGuid from etl.WarehouseEntity where WarehouseEntityName=@factName
		declare @correctView_Script nvarchar(max)
		set @correctView_Script=' exec etl.CreateView @EntityGuid='''+cast(@factGuid as nvarchar(max)) +''', @WarehouseEntityType=''Fact'' -- ' + @factName
		print @correctView_Script

		if @fixFactDiscrepancies = 1
		begin	
				begin try
					--exec sp_executesql @dropView_Script										
					exec sp_executesql @correctView_Script										
				end try
				begin catch
					set @allIssuesFixed = 0
					print 'Error happened with: ' + @correctView_Script
					print ERROR_MESSAGE()
					goto ErrorHappened
				end catch
		end
	end

	--move rows in orphaned tables to view
	if @orphanedTableCount > 0 
	begin
		set @overallIssuesFound = 1; set @issuesFoundForFact = 1;

		print ' --current @orphanedTableCount for '+@factName+' : ' + cast(@orphanedTableCount as nvarchar(max))
		declare @orphanedTable_Script nvarchar(max) 
		set @orphanedTable_Script=''
		declare @orphanedTableName sysname
		declare cOrphanedTables cursor local FORWARD_ONLY READ_ONLY for
			select TableName from @OrphanedTables
		open cOrphanedTables; while 1=1 begin; fetch cOrphanedTables into @orphanedTableName; if @@FETCH_STATUS<>0 break;

			declare @sql_OrphanedTable nvarchar(max), @rowCount_OrphanedTable int
			set @sql_OrphanedTable =N'select @rowCount_OrphanedTable=count(*) from '+@orphanedTableName
			exec sp_executesql @sql_OrphanedTable, N'@rowCount_OrphanedTable int out', @rowCount_OrphanedTable out
			set @orphanedTable_Script = @orphanedTable_Script +char(13)+' -- '+cast(@rowCount_OrphanedTable as nvarchar(max))+' rows to be moved from orphaned table: '+@orphanedTableName+char(13)

			set @orphanedTable_Script = @orphanedTable_Script 
			+' insert into '+@factName+'vw ('+@factColumnList+') '
			+' select '+@factColumnList 
			+' from dbo.'+@orphanedTableName+';' 
			+' drop table dbo.'+@orphanedTableName+'; ' 		
		end; close cOrphanedTables; deallocate cOrphanedTables;

		set @orphanedTable_Script = ' exec sp_executesql N''' +@orphanedTable_Script+''''
		print @orphanedTable_Script

		if @fixFactDiscrepancies = 1	
		begin try
			exec sp_executesql @orphanedTable_Script		
		end try
		begin catch
			set @allIssuesFixed = 0
			print 'Error happened with: ' + @orphanedTable_Script
			print ERROR_MESSAGE()				
			goto ErrorHappened
		end catch
	end
	-------------------------------------------------------------------------------------------
	--move rows in Tmp_fact tables to view
	--declare @sql_TmpFactExists nvarchar(max), @TmpFactExists int
	--set @sql_TmpFactExists =N'select @TmpFactExists=OBJECT_ID(''Tmp_'+@factName+''')'
	--exec sp_executesql @sql_TmpFactExists, N'@TmpFactExists int out', @TmpFactExists out
	--if @TmpFactExists is not null
	if @tmpFact_Created=1
	begin
		print ' -- inserting into '+@factName+'vw  from Tmp_'+@factName
		declare @fromTmpFactToView_Script nvarchar(max)
		set @fromTmpFactToView_Script=' insert into '+@factName+'vw ('+@factColumnList+') '
		+' select '+@factColumnList
		+' from Tmp_'+@factName
		+'; drop table Tmp_'+@factName
		print @fromTmpFactToView_Script

		if @fixFactDiscrepancies = 1
		begin	
			begin try
				exec sp_executesql @fromTmpFactToView_Script										
			end try
			begin catch
				set @allIssuesFixed = 0
				print 'Error happened with: ' + @fromTmpFactToView_Script
				print ERROR_MESSAGE()
				goto ErrorHappened
			end catch
		end
	end				

	--------------------------------------------
	if @issuesFoundForFact = 1
		print ''

	--------------------------------------------
	print 'commit tran-- '+@factName
	if @fixFactDiscrepancies = 1
		commit tran
	--------------------------------------------
end; close c; deallocate c; --of fact cursor

----------------------------------------------------------------------------------------
declare @result nvarchar(max)
print ''
print '-- *****************************************************************'
print '--     R E S U L T   for database:  ' + DB_NAME() 
print '-- *****************************************************************'
print ''
----------------------------------------------------------------------------------------

if @@TRANCOUNT > @initialTrancount
	goto ErrorHappened
else if @@TRANCOUNT > 0
	print  '-- @@TRANCOUNT : ' + cast(@@TRANCOUNT as nvarchar(max)) 
----------------------------------------------------------------------------------------
-- print '@@TRANCOUNT : '+ cast(@@TRANCOUNT as nvarchar(max))  --for debugging only
-- rollback --for debugging only
----------------------------------------------------------------------------------------

if @overallIssuesFound=0
begin 
	print '-- No issues found.'
	return
end

if @allIssuesFixed=1
begin
	if @fixFactDiscrepancies = 1
		print '-- Issues have been fixed by running the commands listed above.'
	else
		print '-- Change script generated (as above) to fix the issues.'
	return
end

return
--------------------------------------
--------------------------------------
ErrorHappened:

print '-- rolling transaction back if  @@TRANCOUNT > @initialTrancount  :  ' + cast(@@TRANCOUNT as nvarchar(max)) +' > '+ cast(@initialTrancount as nvarchar(max))
print 'if @@TRANCOUNT > @initialTrancount   rollback'
if @@TRANCOUNT > @initialTrancount
begin	
	if @fixFactDiscrepancies = 1
		rollback
end

if @allIssuesFixed=0
begin
	print '-- *********************************************************'
	print '-- Looks like errors happened while running the commands listed above.'
	print ''
	print '-- Please share:'
	print '-- 	 all the messages above'
	print '--    and the result of queries in TroubleshootFactProblems.sql '
	print '-- with Microsoft Support.'
end
  
'@   
$SQL_DWFactConstraintsIssue_ForDebugging=@'
select * from etl.WarehouseEntity order by WarehouseEntityName
select * from etl.WarehouseEntity where WarehouseEntityTypeId=1 order by WarehouseEntityTypeId,WarehouseEntityName
select t.name as TableName, * from sys.check_constraints c inner join sys.tables t on c.parent_object_id=t.object_id order by t.name, c.name
SELECT * FROM etl.TablePartition order by PartitionName
select * from DateDim order by DateKey
select distinct left(name,datalength(name)/2-13)+'vw' as name from sys.check_constraints where name like '%\_____\____\_Chk' escape '\' and definition like '%DateKey%' order by 1
select name from sys.tables where name like '%\_____\____' escape '\' order by name
select t.name from sys.tables t left join sys.check_constraints c on t.object_id=c.parent_object_id where t.name like '%\_____\____' escape '\' and c.name is null order by t.name
select * from sys.objects o join sys.sql_modules m on m.object_id = o.object_id where o.type = 'V' order by name
select v.name,c.name,* from sys.columns c inner join sys.views v on c.object_id=v.object_id where v.name like '%vw' order by v.name,c.name
select tp.PartitionName,tp.RangeStartDate,tp.RangeEndDate,t.name as TableName, c.name as ConstraintName, c.definition, v.name,* 
from etl.WarehouseEntity we
left join etl.TablePartition tp on we.WarehouseEntityId=tp.EntityId 
left join sys.tables t on tp.PartitionName=t.name 
left join sys.check_constraints c on c.parent_object_id=t.object_id 
left join sys.views v on we.ViewName=v.name
where we.WarehouseEntityTypeId=1 
order by we.WarehouseEntityName, tp.PartitionName
----------------------------
/*
	These queries collects diagnostic info about Fact issues, if the CorrectFactProblems SQL script does NOT help. 
	Please run it against the DWRepository, DWDataMart, CMDWDataMart, OMDWDataMart databases.
	Please send the output of each DW database to Microsoft Support. 
	THANK YOU!
*/
set nocount on
IF OBJECT_ID('tempdb..#Result') IS NOT NULL drop table #Result
select 
	-- TP Info
	tp.PartitionName, tp.RangeStartDate, tp.RangeEndDate, tp.WarehouseEntityName as tp_WarehouseEntityName, tp.EntityId as tp_EntityId
	-- Table Info2
	,tblSub.name as TableName, left(tblSub.name ,len(tblSub.name )-9)+'vw' as CalculatedViewFromTablename
	-- Chk Info
	, chk.definition as ConstraintDefinition, chk.name as ConstraintName
	-- WE Info
	, we.WarehouseEntityId, we.WarehouseEntityName, we.WarehouseEntityTypeId, we.ViewName as we_ViewName
	-- Wet Info
	,wet.WarehouseEntityTypeName
into #Result
from etl.TablePartition tp 
	full join etl.WarehouseEntity we  on we.WarehouseEntityName=tp.WarehouseEntityName  --4513
	full join etl.WarehouseEntityType wet on we.WarehouseEntityTypeId=wet.WarehouseEntityTypeId 
	full join (select t.[name] from sys.tables t where t.[name] like '%\_____\____' escape '\'  ) as tblSub on tp.PartitionName=tblSub.name
	left join sys.check_constraints chk on OBJECT_ID(tblSub.[name])=chk.parent_object_id
where wet.WarehouseEntityTypeName='Fact' or wet.WarehouseEntityTypeName is null
order by tblSub.name

alter table #Result 
	add RowsCount bigint, MinDateKey int, MaxDateKey int, TableExistInView bit

declare @TableName sysname, @ViewName nvarchar(514), @sql nvarchar(max)
declare c cursor local FORWARD_ONLY READ_ONLY for
	select TableName, CalculatedViewFromTablename as ViewName
	from #Result where TableName is not null or CalculatedViewFromTablename is not null
open c; while 1=1 begin; fetch c into @TableName, @ViewName;if @@FETCH_STATUS<>0 break;	

	if @TableName is not null
	begin
		declare @Tbl_rowcount int, @Tbl_minDatekey int, @Tbl_maxDateKey int, @Tbl_sql as nvarchar(max)
		set @Tbl_sql=N'select @Tbl_rowcount=count(*), @Tbl_minDatekey=Min(DateKey), @Tbl_maxDateKey=Max(DateKey) from '+@TableName
		exec sp_executesql @Tbl_sql,N'@Tbl_rowcount int out, @Tbl_minDatekey int out, @Tbl_maxDateKey int out',@Tbl_rowcount out, @Tbl_minDatekey out, @Tbl_maxDateKey out
		update #Result
		set RowsCount=@Tbl_rowcount, MinDateKey=@Tbl_minDatekey, MaxDateKey=@Tbl_maxDateKey
		where TableName=@TableName
	end

	if @ViewName is not null
	begin
		declare @View_charindex int,  @View_sql as nvarchar(max)
		set @View_sql=N'
		select @View_charindex=CHARINDEX('''+@TableName+''',
					(select definition from sys.objects o join sys.sql_modules m on m.object_id = o.object_id where o.object_id = object_id('''+@ViewName+''') and o.type = ''V'')  
				)
		'
		exec sp_executesql @View_sql,N'@View_charindex int out',@View_charindex out
		update #Result
		set TableExistInView=case when @View_charindex > 0 then 1 else 0 end
		where TableName=@TableName
	end
end; close c; deallocate c;
select db_name() as DbName,* from #Result order by TableName
--
select * from etl.Configuration
--
SELECT WarehouseEntityName, wet.WarehouseEntityTypeName, we.WarehouseEntityId, wegi.RetentionPeriodInMinutes,wegi.RetentionPeriodInMinutes/60/24 as InDays,wegi.RetentionPeriodInMinutes/60/24/365 as InYears,CreatedDate,UpdatedDate
FROM etl.WarehouseEntity (nolock) we
JOIN etl.WarehouseEntityType (nolock) wet on we.WarehouseEntityTypeId = wet.WarehouseEntityTypeId 
JOIN etl.WarehouseEntityGroomingInfo (nolock) wegi on wegi.WarehouseEntityId = we.WarehouseEntityId
order by 1
--
select * from etl.WarehouseEntityGroomingHistory order by PartitionName
'@
$SQL_DWFactEntityUpgradeIssue=@'
-- https://docs.microsoft.com/en-us/system-center/scsm/upgrade-service-manager?view=sc-sm-2019#preventing-mpsync-jobs-from-railing
;WITH FactName  
AS (  
       select w.WarehouseEntityName from etl.WarehouseEntity w  
       join etl.WarehouseEntityType t on w.WarehouseEntityTypeId = t.WarehouseEntityTypeId  
       where t.WarehouseEntityTypeName = 'Fact'  
),FactList  
AS (  
    SELECT  PartitionName, p.WarehouseEntityName,  
            RANK() OVER ( PARTITION BY p.WarehouseEntityName ORDER BY PartitionName ASC ) AS RK  
    FROM    etl.TablePartition p  
       join FactName f on p.WarehouseEntityName = f.WarehouseEntityName  
)  
, FactPKList  
AS (  
    SELECT  f.WarehouseEntityName, a.TABLE_NAME, a.COLUMN_NAME, b.CONSTRAINT_NAME, f.RK,  
            CASE WHEN b.CONSTRAINT_NAME = 'PK_' + f.WarehouseEntityName THEN 1 ELSE 0 END AS DefaultConstraints  
    FROM    FactList f  
    JOIN    INFORMATION_SCHEMA.KEY_COLUMN_USAGE a ON f.PartitionName = a.TABLE_NAME  
    JOIN    INFORMATION_SCHEMA.TABLE_CONSTRAINTS b ON a.CONSTRAINT_NAME = b.CONSTRAINT_NAME AND b.CONSTRAINT_TYPE = 'Primary key'  
)  
, FactWithoutDefaultConstraints  
AS (  
    SELECT  a.*  
    FROM    FactPKList a  
    LEFT JOIN FactPKList b ON b.WarehouseEntityName = a.WarehouseEntityName AND b.DefaultConstraints = 1  
    WHERE   b.WarehouseEntityName IS NULL AND a.RK = 1  
)  
, FactPKListStr  
AS (  
    SELECT  DISTINCT f1.WarehouseEntityName, f1.TABLE_NAME, f1.CONSTRAINT_NAME, F.COLUMN_NAME AS PKList  
    FROM    FactWithoutDefaultConstraints f1  
    CROSS APPLY (  
                    SELECT  '[' + COLUMN_NAME + '],'  
                    FROM    FactWithoutDefaultConstraints f2  
                    WHERE   f2.TABLE_NAME = f1.TABLE_NAME  
                    ORDER BY COLUMN_NAME  
                FOR  
                   XML PATH('')  
                ) AS F (COLUMN_NAME)  
)  
SELECT  'ALTER TABLE [dbo].[' + f.TABLE_NAME + '] DROP CONSTRAINT [' + f.CONSTRAINT_NAME + ']' + CHAR(13) + CHAR(10) +  
        'ALTER TABLE [dbo].[' + f.TABLE_NAME + '] ADD CONSTRAINT [PK_' + f.WarehouseEntityName + '] PRIMARY KEY NONCLUSTERED (' + SUBSTRING(f.PKList, 1, LEN(f.PKList) -1) + ')' + CHAR(13) + CHAR(10)  
FROM    FactPKListStr f
OPTION (QUERYTRACEON 9481)
'@
$SQL_DWFKIssues = @'
print 'Checking for potential SSAS "The attribute key cannot be found" issues inside database:   ' + db_name()
print ''

declare @MissingRows nvarchar(max), @ParmDefinition nvarchar(max), @retval int, @MissingTables nvarchar(max), @error int, @error_message nvarchar(4000), @IssuesFound bit
declare @ForeignSchema sysname, @ForeignTable sysname, @ForeignColumn sysname, @ReferencedSchema sysname, @ReferencedTable sysname, @ReferencedColumn sysname
set @IssuesFound=0

declare c1 cursor local FORWARD_ONLY READ_ONLY for
	select fkS.name as ForeignSchema, fkT.name as ForeignTable, fkC.name as ForeignColumn, rfS.name as ReferencedSchema, rfT.name as ReferencedTable, rfC.name as ReferencedColumn	
	from DWRepository.sys.foreign_key_columns fkcols
	inner join DWRepository.sys.foreign_keys fkeys on fkcols.constraint_object_id=fkeys.object_id
	inner join DWRepository.sys.tables fkT on fkcols.parent_object_id = fkT.object_id
	inner join DWRepository.sys.columns fkC on fkcols.parent_column_id=fkC.column_id and fkcols.parent_object_id=fkC.object_id
	inner join DWRepository.sys.schemas fkS on fkT.schema_id=fkS.schema_id
	inner join DWRepository.sys.tables rfT on fkcols.referenced_object_id = rfT.object_id
	inner join DWRepository.sys.columns rfC on fkcols.referenced_column_id=rfC.column_id and fkcols.referenced_object_id=rfC.object_id
	inner join DWRepository.sys.schemas rfS on rfT.schema_id=rfS.schema_id
	where fkeys.is_disabled=0
	order by 1,2,3
open c1; while 1=1 begin; fetch c1 into @ForeignSchema, @ForeignTable, @ForeignColumn, @ReferencedSchema, @ReferencedTable, @ReferencedColumn; if @@FETCH_STATUS<>0 break;		
	set @ParmDefinition = N'@retvalOUT int OUTPUT'
	set @MissingTables='
	if (NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = ''[ForeignSchema]'' AND TABLE_NAME = ''[ForeignTable]''))
	or (NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = ''[ReferencedSchema]'' AND TABLE_NAME = ''[ReferencedTable]''))
		set @retvalOUT=1
	else
		set @retvalOUT=0
	return'	
    set @MissingTables = REPLACE(@MissingTables,'[ForeignSchema]',@ForeignSchema)
	set @MissingTables = REPLACE(@MissingTables,'[ForeignTable]',@ForeignTable)
	set @MissingTables = REPLACE(@MissingTables,'[ReferencedSchema]',@ReferencedSchema)
	set @MissingTables = REPLACE(@MissingTables,'[ReferencedTable]',@ReferencedTable)
	set @retval = 0
	exec sp_executesql @MissingTables, @ParmDefinition, @retvalOUT=@retval OUTPUT
	if @retval=1
		continue

	set @MissingRows='select @retvalOUT=count(*) from [ForeignSchema].[ForeignTable] as ForeignTable where ForeignTable.[ForeignColumn] is not null and  NOT exists(select * from [ReferencedSchema].[ReferencedTable] as ReferencedTable	where ForeignTable.[ForeignColumn]=ReferencedTable.[ReferencedColumn])'
	set @MissingRows = REPLACE(@MissingRows,'[ForeignSchema]',@ForeignSchema)
	set @MissingRows = REPLACE(@MissingRows,'[ForeignTable]',@ForeignTable)
	set @MissingRows = REPLACE(@MissingRows,'[ForeignColumn]',@ForeignColumn)
	set @MissingRows = REPLACE(@MissingRows,'[ReferencedSchema]',@ReferencedSchema)
	set @MissingRows = REPLACE(@MissingRows,'[ReferencedTable]',@ReferencedTable)
	set @MissingRows = REPLACE(@MissingRows,'[ReferencedColumn]',@ReferencedColumn)	
	set @retval = 0
	exec sp_executesql @MissingRows, @ParmDefinition, @retvalOUT=@retval OUTPUT
	select @error=@@ERROR, @error_message=error_message()

	if @error!=0  or  @retval > 0
	begin 
		if @error!=0
			print @error_message

		set @MissingRows = REPLACE(@MissingRows,'@retvalOUT=count(*)','*')
		print @MissingRows +  ' --' + cast(@retval as nvarchar(max))
		set @IssuesFound=1
	end

end; close c1; deallocate c1;
print ''
if @IssuesFound=0
	print 'No Issues found in database   ' + db_name()
else
	print 'Issues exist in database   ' + db_name() + '. Queries listed above can be investigated.'
'@
$SQL_DWEtlConfiguration='select * from etl.Configuration'
$SQL_DWEtlWarehouseEntityGroomingHistory='select * from etl.WarehouseEntityGroomingHistory'
$SQL_DWEtlWarehouseEntityGroomingInfo=@'
SELECT WarehouseEntityName, wet.WarehouseEntityTypeName, we.WarehouseEntityId, wegi.RetentionPeriodInMinutes,wegi.RetentionPeriodInMinutes/60/24 as InDays,wegi.RetentionPeriodInMinutes/60/24/365 as InYears,CreatedDate,UpdatedDate
FROM etl.WarehouseEntity (nolock) we
JOIN etl.WarehouseEntityType (nolock) wet on we.WarehouseEntityTypeId = wet.WarehouseEntityTypeId 
JOIN etl.WarehouseEntityGroomingInfo (nolock) wegi on wegi.WarehouseEntityId = we.WarehouseEntityId
order by 1
'@
    #endregion

    Collect_SQL_DWRepository
    Collect_SQL_DWDataMart
    Collect_SQL_CMDWDataMart
    Collect_SQL_OMDWDataMart

    Collect_FromSMSide

    Collect_FromSSAS
    Collect_FromSSRS
}
 

function Collect_ConnectedSDKUsersCount() {
    AppendOutputToFileInTargetFolder (Get-Counter -Counter "\OpsMgr SDK Service(system center data access service)\Client Connections" )  "ConnectedSDKUsers.txt"
}

function Collect_HealthServiceStateFolder() {
    Copy-Item -Path (Join-Path -Path ((Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Service Manager\Setup').InstallDirectory) -ChildPath  "Health Service State") -Destination (GetFileNameInTargetFolder "Health Service State") -Recurse  -ErrorAction SilentlyContinue
}

function Collect_MGRegistryValues() {
    Reg export "HKLM\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Server Management Groups" (GetFileNameInTargetFolder "ServerManagementGroups.regValues.txt")| Out-Null
}

function Collect_OMEventLog() {
    (get-wmiobject win32_nteventlogfile -filter "logfilename = 'Operations Manager'").BackupEventlog((GetFileNameInTargetFolder "OperationsManager.evtx")) | Out-Null
    wevtutil archive-log (GetFileNameInTargetFolder "OperationsManager.evtx") /l:en-US
}

function Collect_OMTraceFiles() {
    Copy-Item -Path "$env:windir\Logs\OpsMgrTrace" -Destination (GetFileNameInTargetFolder "OpsMgrTrace") -Recurse  -ErrorAction SilentlyContinue
}

function Collect_ScomAgent() {
    AppendOutputToFileInTargetFolder (Reg query 'HKLM\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Agent Management Groups' -s 2>&1) AgentMGs.regValues.txt
}

function Collect_SCSMInstallationFilesInfo() {
    AppendOutputToFileInTargetFolder (Get-ChildItem -Path ((Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Service Manager\Setup').InstallDirectory) -Recurse -Force | Select-Object Length, lastwritetimeutc, @{Name="Version";Expression={$_.VersionInfo.ProductVersion}}, FullName | ConvertTo-Csv -NoTypeInformation ) "SCSM_Files.csv"
}

function Collect_SCSMRunAsAccounts() {
    AppendOutputToFileInTargetFolder (Get-SCSMRunAsAccount) "Get-SCSMRunAsAccount.txt"
}

function Collect_SCSMSetupLogFiles() {
    Get-ChildItem -Path "$env:SystemDrive\users\*\appdata\local\temp" -Include SCSM*.log -Recurse -Force -ErrorAction SilentlyContinue | % {
            $UpDir1 = $_.Directory;$UpDir2 = $UpDir1.Parent;$UpDir3 = $UpDir2.Parent;$UpDir4 = $UpDir3.Parent;
            if ($UpDir1.Name -eq "Temp" -and $UpDir2.Name -eq "local" -and $UpDir3.Name -eq "appdata") {
                $userFolderName=$UpDir3.Parent;
                CopyFileToTargetFolder $_.FullName "SCSM_SetupLogFiles\$userFolderName"
            }    
    } -ErrorAction SilentlyContinue
}

function Collect_SCSMUserRoles() {
# SCSM User Roles  with ALL Details
    $roles = Get-SCSMUserRole | Sort-Object -Property DisplayName
    $tbl = New-Object System.Data.DataTable "UserRoles"
    
    $col1 = New-Object System.Data.DataColumn DisplayName
    $col2 = New-Object System.Data.DataColumn Queues
    $col3 = New-Object System.Data.DataColumn ConfigurationItemGroups
    $col4 = New-Object System.Data.DataColumn CatalogItemGroups
    $col5 = New-Object System.Data.DataColumn Tasks
    $col6 = New-Object System.Data.DataColumn Views
    $col7 = New-Object System.Data.DataColumn FormTemplates
    $col8 = New-Object System.Data.DataColumn Users
    $col9 = New-Object System.Data.DataColumn Profile
    $col10 = New-Object System.Data.DataColumn LastModified
    $col11 = New-Object System.Data.DataColumn LastModifiedBy

    $tbl.Columns.Add($col1)
    $tbl.Columns.Add($col2)
    $tbl.Columns.Add($col3)
    $tbl.Columns.Add($col4)
    $tbl.Columns.Add($col5)
    $tbl.Columns.Add($col6)
    $tbl.Columns.Add($col7)
    $tbl.Columns.Add($col8)
    $tbl.Columns.Add($col9)
    $tbl.Columns.Add($col10)
    $tbl.Columns.Add($col11)

    foreach($role in $roles) {
        $row = $tbl.NewRow()

        $row.DisplayName = $role.DisplayName
        $row.Queues = Show-AllSelectedNone $role.AllQueues $role.Queue
        $row.ConfigurationItemGroups = Show-AllSelectedNone $role.AllGroups $role.Group
        $row.CatalogItemGroups = Show-AllSelectedNone $role.AllCatalogGroups $role.CatalogGroup
        $row.Tasks = Show-AllSelectedNone $role.AllTasks $role.Task
        $row.Views = Show-AllSelectedNone $role.AllViews $role.View
        $row.FormTemplates = Show-AllSelectedNone $role.AllFormTemplates $role.FormTemplate
        $row.Users = [string]( $role.User | %{ $_ + [char]10 } )
        $row.LastModified = $role.LastModified
        $row.LastModifiedBy = $role.LastModifiedBy

        $dsUserRole = Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSM  -SQLDatabase $SQLDatabase_SCSM -Query "SELECT (select ProfileName from Profile where ProfileId = UserRole.ProfileId) as ProfileName FROM UserRole where UserRoleName = '$($role.UserRole.ToString())'"
        $row.Profile = $dsUserRole.Tables[0].ProfileName

        $tbl.Rows.Add($row)
    }
    AppendOutputToFileInTargetFolder (  $tbl | ConvertTo-Csv -NoTypeInformation) Get-SCSMUserRole_WithAllDetails.csv
}

function Collect_SCSMVersion() {
    AppendOutputToFileInTargetFolder (GP HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*  | ?{$_.DisplayName -like "*Service Manager*"} | FT DisplayName, DisplayVersion -Autosize) "SCSM_Version.txt"
    AppendOutputToFileInTargetFolder (GP HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*  | ?{$_.DisplayName -like "*Service Manager*"} | Select-Object DisplayName, DisplayVersion, Publisher | ConvertTo-Csv) "SCSM_Version.csv"
}

function Collect_SMTraceFiles() {
    Copy-Item -Path "$env:windir\Temp\SMTrace" -Destination (GetFileNameInTargetFolder "SMTrace") -Recurse  -ErrorAction SilentlyContinue
}

function Collect_SPNs() {
    AppendOutputToFileInTargetFolder (Invoke-Expression "setspn.exe -q MSOMSdkSvc/$((Get-Item -path Env:COMPUTERNAME).Value)*") spnSDK.txt
    AppendOutputToFileInTargetFolder (Invoke-Expression "setspn.exe -q MSOMHSvc/$((Get-Item -path Env:COMPUTERNAME).Value)*") spnHS.txt
    AppendOutputToFileInTargetFolder (Invoke-Expression "setspn.exe -X") spnX.txt
}

function Collect_SystemCenterRegPermissions() {
    AppendOutputToFileInTargetFolder (Get-ChildItem "HKLM:\SOFTWARE\Microsoft\System Center" -Recurse | % {$_.Name; (Get-Acl -Path $_.PSPath).Access} ) "SystemCenter.regPermissions.txt"
}

function Collect_SystemCenterRegValues() {
    Reg export "HKLM\SOFTWARE\Microsoft\System Center" (GetFileNameInTargetFolder "SystemCenter.regValues.txt")| Out-Null
}

function Collect_Test_LocalOMSDK() {
    AppendOutputToFileInTargetFolder (Test-NetConnection -ComputerName localhost -Port 5724) Telnet_localhost_5724.txt
    AppendOutputToFileInTargetFolder (Test-Connection -ComputerName localhost | ft -Wrap -Autosize ) Ping_localhost_5724.txt
}

function Collect_WindowsErrorReporting() {
    AppendOutputToFileInTargetFolder ( Get-ChildItem -Path "$env:SystemDrive\users\*\appdata\local\CrashDumps" -Include *.* -Recurse -Force -ErrorAction SilentlyContinue ) WER_Files.txt    
    AppendOutputToFileInTargetFolder ( Reg query "HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps" 2>&1 ) WER.regValues.txt
}

function Collect_FromDWAndWFAndSecondary() {
#region DO NOT REMOVE THIS! Exit immediately if script is NOT running on a WF or Secondary or DW mgmt server
if (-not (IsThisAnyScsmMgmtServer)) {
    return
}
#endregion

# Collects info that is specific to all DW and WF and Secondary Management Servers

    Collect_OMEventLog   
    Collect_SystemCenterRegValues
    Collect_SystemCenterRegPermissions
    Collect_MGRegistryValues
    Collect_SCSMVersion
    Collect_ScomAgent
    Collect_SPNs
    Collect_Test_LocalOMSDK
    Collect_ConnectedSDKUsersCount
    Collect_WindowsErrorReporting

    Collect_HealthServiceStateFolder
    Collect_SCSMInstallationFilesInfo
    Collect_SCSMSetupLogFiles

    Collect_SMTraceFiles
    Collect_OMTraceFiles

    Collect_SCSMRunAsAccounts
    Collect_SCSMUserRoles
}

function Collect_FromSecondary() {
#region DO NOT REMOVE THIS! Exit immediately if script is NOT running on a Secondary server
if (-not (IsThisScsmSecondaryMgmtServer)) {
    return
}
#endregion

# Collects info that is specific to only Secondary servers


#...nothing to collect for now that is specific to only Secondary server
}

function Collect_FromWF() {
#region DO NOT REMOVE THIS! Exit immediately if script is NOT running on a WF server
if (-not (IsThisScsmWfMgmtServer)) {
    return
}
#endregion

# Collects info that is specific to only WF servers


#... nothing to collect for now that is specific to only WF server

}

function Collect_FromWFAndDW() {
#region DO NOT REMOVE THIS! Exit immediately if script is NOT running on a WF or DW server
if (-not ( (IsThisScsmWfMgmtServer) -or (IsThisScsmDwMgmtServer) )) {
    return
}
#endregion

# Collects info that is specific to only WF and DW servers

#...nothing to collect for now that is specific to only WF or DW servers
}

function Collect_ConnectorEclLogSettings() {
    AppendOutputToFileInTargetFolder (Get-SCSMClassInstance -Class (Get-SCSMClass -Name "System.GlobalSetting.ConnectorEclLogSettings")) "ConnectorEclLogSettings.txt"
}

function Collect_Connectors() {
    AppendOutputToFileInTargetFolder (Get-SCSMConnector | fl *) "Get-SCSMConnector.txt"
}

function Collect_EmailSendingRules() {
    AppendOutputToFileInTargetFolder (GetEmailSendingRules) "EmailSendingRules.txt"
}

function Collect_EmailTemplates() {
    AppendOutputToFileInTargetFolder (Get-SCSMEmailTemplate | fl) "Get-SCSMEmailTemplate.txt"
}

function Collect_MPs() {
$allMPs=(Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSM -SQLDatabase $SQLDatabase_SCSM -Query "select ManagementPackId, MPName from ManagementPack")
    foreach ($currMP in $allMPs.Tables[0]) {
        $MPId = $currMP.ManagementPackId
        $MPName = $currMP.MPName
        AppendOutputToFileInTargetFolder ((Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSM -SQLDatabase $SQLDatabase_SCSM -Query "select convert(xml,MPXML) as MPXML from ManagementPack where ManagementPackId='$MPId'").Tables[0].MPXML) "$($MPName)___$MPId.xml"
        MoveFileInTargetFolder "$($MPName)___$MPId.xml" "MPXml"
    }
}

function Collect_NotificationChannel() {
    AppendOutputToFileInTargetFolder (Get-SCSMChannel | fl *) "Get-SCSMChannel.txt"
}

function Collect_RegisteredDWEnvironmentInfo() {
#this function writes to 2 files!

    #get the registered DW mgmt server name. 
    $registeredDwMS = (Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSM -SQLDatabase $SQLDatabase_SCSM 'select dw.Server_48B308F9_CF0E_0F74_83E1_0AEB1B58E2FA as "DW mgmt server name" from MT_Microsoft$SystemCenter$ResourceAccessLayer$DwSdkResourceStore dw inner join BaseManagedEntity bme on dw.BaseManagedEntityId=bme.BaseManagedEntityId').Tables[0].'DW mgmt server name'
    
    #if not registered then immediately return, no need for further collection.
    if ($registeredDwMS -eq $null) {
        return
    }

    $GetSCDWInfraLocationResultCsv = Get-SCDWInfraLocation -ComputerName $registeredDwMS | ConvertTo-Csv -NoTypeInformation
    AppendOutputToFileInTargetFolder $GetSCDWInfraLocationResultCsv "Get-SCDWInfraLocation_FromRegisteredDW.csv"

    $GetSCDWInfraLocationResult = ConvertFrom-Csv -InputObject $GetSCDWInfraLocationResultCsv
    $DwStagingAndConfigDbInfo = $GetSCDWInfraLocationResult | ? { $_.InfraType -eq 'StagingAndConfigDatabase' } 
    SaveSQLResultSetsToFiles $DwStagingAndConfigDbInfo.Server $DwStagingAndConfigDbInfo.Value "exec sp_configure 'show advanced options',1 ; RECONFIGURE; exec sp_configure" SQL_sp_configure_FromRegisteredDwSQL.csv 
}

function Collect_SCOMCIConnectorAllowList() {
    AppendOutputToFileInTargetFolder (Get-SCSMAllowList) "Get-SCSMAllowList.txt"
}

function Collect_SCSMRolesFound() {

    $role = "It is unknown what type of SCSM components are installed on this machine."
    $script:RoleFoundAbbr = "UNK"

    if (IsThisScsmWfMgmtServer) {
        $role="This is the Primary/Workflow mgmt server."
        $script:RoleFoundAbbr = "WF"
    }
    elseif (IsThisScsmSecondaryMgmtServer) {
        $role = "This is a Secondary mgmt server"
        $script:RoleFoundAbbr = "2MS"
    }
    AppendOutputToFileInTargetFolder $role "ScsmRolesFound.txt" 
}

function Collect_SCSMSettings() {
    AppendOutputToFileInTargetFolder (Get-SCSMSetting)  "Get-SCSMSetting.txt"
}

function Collect_SqlErrorLogFiles() {
    GetSqlErrorLogFiles (GetMachineNameFromSqlInstance $SQLInstance_SCSM) $SQLDatabase_SCSM
}

function Collect_SQL_MS_Shared() {
    foreach( $SqlSharedText in $SQL_SCSM_Shared.Keys ) {        
        SaveSQLResultSetsToFiles $SQLInstance_SCSM $SQLDatabase_SCSM ( $SQL_SCSM_Shared[$SqlSharedText] ) "$SqlSharedText.csv"    
    }
}

function Collect_SQL_MS_Specific() {

    $SQL_SCSM_MS =@{}
    $SQL_SCSM_MS['SQL_DCM']=@'

SELECT COUNT(*) AS 'Number of Updates to DCM Instances'
FROM EntityChangeLog AS ECL WITH(NOLOCK)
JOIN ManagedType AS MT
ON ECL.EntityTypeId = MT.ManagedTypeId
WHERE MT.TypeName = 'Microsoft.SystemCenter.ConfigurationManager.DCM_NonCompliance_CI' 
GO

DECLARE @MinState INT
SET @MinState = (
SELECT MIN(State)
FROM CmdbInstanceSubscriptionState AS W WITH(NOLOCK)
JOIN Rules AS R
ON W.RuleId = R.RuleId
WHERE
R.RuleEnabled <> 0 AND
W.IsPeriodicQueryEvent = 0
)
SELECT COUNT(*) AS 'UNPROCESSED Number of Updates to DCM Instances'
FROM EntityChangeLog AS ECL WITH(NOLOCK)
JOIN ManagedType AS MT
ON ECL.EntityTypeId = MT.ManagedTypeId
WHERE
ECL.EntityTransactionLogId >= @MinState AND
MT.TypeName = 'Microsoft.SystemCenter.ConfigurationManager.DCM_NonCompliance_CI' 
GO
'@
    $SQL_SCSM_MS['SQL_PatchInfo']=@'
     select '__PatchInfo__' tableName,* from [__PatchInfo__]  order by AppliedOn  desc
'@
    $SQL_SCSM_MS['SQL_NotificationTemplate']=@'
SELECT LTValue as "Notification Template Display Name",ot.*
FROM ObjectTemplate ot
inner join localizedtext lt on ot.ObjectTemplateId=lt.LTStringId and LTStringType=1 and LanguageCode='ENU'
'@
    $SQL_SCSM_MS['SQL_WorkflowMinutesBehind_Original'] = @'
DECLARE @MaxState INT, @MaxStateDate Datetime, @Delta INT, @Language nvarchar(3)
 SET @Delta = 0
 SET @Language = 'ENU'
 SET @MaxState = (
    SELECT MAX(EntityTransactionLogId)
    FROM EntityChangeLog WITH(NOLOCK)
 )
 SET @MaxStateDate = (
	SELECT TimeAdded 
	FROM EntityTransactionLog
	WHERE EntityTransactionLogId = @MaxState
)
SELECT
    LT.LTValue AS 'Display Name',
	S.State AS 'Current Workflow Watermark',
	@MaxState AS 'Current Transaction Log Watermark',
	@MaxState-S.State as Delta,
	DATEDIFF(mi,(SELECT TimeAdded 
	FROM EntityTransactionLog WITH(NOLOCK)
	WHERE EntityTransactionLogId = S.State), @MaxStateDate) AS 'Minutes Behind',
	S.EventCount,
	S.LastNonZeroEventCount,
	R.RuleName AS 'MP Rule Name',
    MT.TypeName AS 'Source Class Name',
    S.LastModified AS 'Rule Last Modified',
	S.IsPeriodicQueryEvent AS 'Is Periodic Query Subscription', 
    R.RuleEnabled AS 'Rule Enabled',    R.RuleID
 FROM CmdbInstanceSubscriptionState AS S WITH(NOLOCK)
 LEFT OUTER JOIN Rules AS R
    ON S.RuleId = R.RuleId
 LEFT OUTER JOIN ManagedType AS MT
    ON S.TypeId = MT.ManagedTypeId
 LEFT OUTER JOIN LocalizedText AS LT
	ON R.RuleId = LT.MPElementId
 WHERE
    S.State <= @MaxState - @Delta 
	AND R.RuleEnabled <> 0 
	AND LT.LTStringType = 1
	AND LT.LanguageCode = @Language
	AND S.IsPeriodicQueryEvent = 0
order by 4 desc 
'@
    $SQL_SCSM_MS['SQL_WorkflowMinutesBehind'] = @'
DECLARE @MaxState INT, @MaxStateDate Datetime, @Delta INT, @Language nvarchar(3)
 SET @Delta = 0
 SET @Language = 'ENU'
 SET @MaxState = (
    SELECT MAX(EntityTransactionLogId)
    FROM EntityChangeLog WITH(NOLOCK)
 )
 SET @MaxStateDate = (
	SELECT TimeAdded 
	FROM EntityTransactionLog
	WHERE EntityTransactionLogId = @MaxState
)
SELECT
    LT.LTValue AS 'Display Name',
	S.State AS 'Current Workflow Watermark',
	@MaxState AS 'Current Transaction Log Watermark',
	@MaxState-S.State as Delta,
	DATEDIFF(mi,(SELECT TimeAdded 
	FROM EntityTransactionLog WITH(NOLOCK)
	WHERE EntityTransactionLogId = S.State), @MaxStateDate) AS 'Minutes Behind',
	S.EventCount,
	S.LastNonZeroEventCount,
	R.RuleName AS 'MP Rule Name',
    MT.TypeName AS 'Source Class Name',
    S.LastModified AS 'Rule Last Modified',
	S.IsPeriodicQueryEvent AS 'Is Periodic Query Subscription', 
    R.RuleEnabled AS 'Rule Enabled',    R.RuleID
into #tmp
 FROM CmdbInstanceSubscriptionState AS S WITH(NOLOCK)
 LEFT OUTER JOIN Rules AS R
    ON S.RuleId = R.RuleId
 LEFT OUTER JOIN ManagedType AS MT
    ON S.TypeId = MT.ManagedTypeId
 LEFT OUTER JOIN LocalizedText AS LT
	ON R.RuleId = LT.MPElementId
 WHERE
    S.State <= @MaxState - @Delta 
	AND R.RuleEnabled <> 0 
	AND LT.LTStringType = 1
	AND LT.LanguageCode = @Language
	AND S.IsPeriodicQueryEvent = 0

select [Display Name],max([Current Workflow Watermark]) as [Current Workflow Watermark], max([Current Transaction Log Watermark]) as [Current Transaction Log Watermark], 
max(Delta) as Delta,min([Minutes Behind]) as [Minutes Behind],
[MP Rule Name], [Source Class Name], RuleId 
from #tmp
group by [Display Name], [MP Rule Name], [Source Class Name], RuleId
order by 4
'@
    $SQL_SCSM_MS['SQL_Queues'] = @'     
select dsv.DisplayName
,(select mtTarget.TypeName from  RelationshipType rst inner join ManagedType as mtTarget on rst.TargetManagedTypeId=mtTarget.ManagedTypeId where rst.SourceManagedTypeId=mt.ManagedTypeId) as WorkItemType
, mt.IsDeleted as "Q is deleted"
,(select count(*) from Relationship rs where rs.SourceEntityId=mt.ManagedTypeId and rs.IsDeleted=0) as Existing_membercount
,(select count(*) from Relationship rs where rs.SourceEntityId=mt.ManagedTypeId and rs.IsDeleted=1) as Deleted_membercount
,mt.ManagedTypeId,dsv.ManagementPackId,dsv.MPElementId,dsv.ElementName,mp.MPName,mp.MPFriendlyName--,* 
from ManagedType mt
inner join DisplayStringView dsv on mt.ManagedTypeId = dsv.LTStringId and LanguageCode='ENU'
inner join ManagementPack mp on dsv.ManagementPackId = mp.ManagementPackId
where mt.BaseManagedTypeId='31D729D9-83C5-5B36-703B-C51D54395687'
'@
    $SQL_SCSM_MS['SQL_InternalJobHistory'] = @'
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomSubscriptionSpecificRECLRows 55270A70-AC47-C853-C617-236B0CFF9B4C%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomSubscriptionSpecificECLRows 55270A70-AC47-C853-C617-236B0CFF9B4C%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomStagedChangeLogs 55270A70-AC47-C853-C617-236B0CFF9B4C%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomManagedEntity A604B942-4C7B-2FB2-28DC-61DC6F465C68%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomManagedEntity E6C9CF6E-D7FE-1B5D-216C-C3F5D2C7670C%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomManagedEntity D02DC3B6-D709-46F8-CB72-452FA5E082B8%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomManagedEntity 422AFC88-5EFF-F4C5-F8F6-E01038CDE67F%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomManagedEntity 04B69835-6343-4DE2-4B19-6BE08C612989%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomChangeLogs 55270A70-AC47-C853-C617-236B0CFF9B4C%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomPartitionedObjects and dbo.p_Grooming%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_GroomTypeSpecificLogTables%' order by TimeStarted desc
Select top 4 * from InternalJobHistory where command like '%Exec dbo.p_DataPurging%' order by TimeStarted desc
'@
    $SQL_SCSM_MS['SQL_WF_and_2ndaryMS'] = @'
select sitc.*,mt.TypeName, bme.DisplayName as "Primary/WF Mgmt Server"  -- ,*
FROM dbo.[ScopedInstanceTargetClass] sitc
inner join ManagedType mt on mt.ManagedTypeId = sitc.ManagedTypeId
inner join BaseManagedEntity bme on bme.BaseManagedEntityId = sitc.ScopedInstanceId and bme.IsDeleted=0
where mt.ManagedTypeId = dbo.fn_ManagedTypeId_MicrosoftSystemCenterWorkflowTarget()
select 'All registered mgmt servers below (including WF, except DW)'
exec    p_RootManagementServerSelectConnectionPropertyValues
'@
    $SQL_SCSM_MS['SQL_AdvancedTypeProjections'] = @'
select distinct lttp.ltvalue as TypeProjectionName,ltf.LTValue as FolderName,lt.ltvalue as ViewName
from TypeProjection tp
left join LocalizedText lttp on tp.TypeProjectionId=lttp.LTStringId 
inner join  views v  on v.ConfigurationXML like '%Parameter="TypeProjectionId"%Value="$MPElement\[Name=''%!'+ tp.TypeProjectionName +'''\]$"%' escape '\'
inner join FolderItem fi on v.ViewId=fi.MPElementId
inner join Folder f on fi.FolderId=f.FolderId
left join LocalizedText lt on v.ViewId=lt.LTStringId 
left join LocalizedText ltf on f.FolderId=ltf.LTStringId 
inner join ManagementPack mp on v.ManagementPackId=mp.ManagementPackId
where 
lttp.ltvalue like '%(advanced)%'
and lttp.LTStringType=1 and lttp.LanguageCode like 'EN_' 
and lt.LTStringType=1 and lt.LanguageCode like 'EN_' 
and ltf.LTStringType=1 and ltf.LanguageCode like 'EN_' 
and (MP.MPKeyToken!='31bf3856ad364e35' or mp.MPKeyToken is null)
order by 1,2,3  
'@
    $SQL_SCSM_MS['SQL_ScsmMonitoringMP_Grooming'] = @'
    SELECT COUNT(*) "Grooming - SCSM Monitoring MP" FROM dbo.InternalJobHistory Job, (SELECT max(timestarted) as LastTime, command FROM dbo.InternalJobHistory GROUP BY command) GroupJob WHERE job.Command = GroupJob.Command AND job.TimeStarted= GroupJob.LastTime AND ( (job.StatusCode = '0' AND (DATEDIFF(MINUTE, job.TimeStarted , GETUTCDATE()) >= 25)) OR (job.StatusCode = '0' AND (DATEDIFF(MINUTE, job.TimeStarted , GETUTCDATE()) >= 15) AND job.Command like '%Subscription%') OR job.StatusCode ='2' )
'@
    $SQL_SCSM_MS['SQL_ScsmMonitoringMP_Lfx'] = @'
declare @TableName sysname; declare @StatusColumn sysname; declare @StartTimeColumn sysname; declare @Query varchar(max); 
select @TableName = MT.ManagedTypeTableName, @StatusColumn = MTP1.ColumnName,@StartTimeColumn = MTP2.ColumnName from ManagedType MT inner join ManagedTypeProperty MTP1 on MT.ManagedTypeId = MTP1.ManagedTypeId inner join ManagedTypeProperty MTP2 on MT.ManagedTypeId = MTP2.ManagedTypeId where MT.TypeName = N'Microsoft.SystemCenter.LinkingFramework.SyncStatus' and MTP1.ManagedTypePropertyName = N'Status' and MTP2.ManagedTypePropertyName = N'LastRunStartTime'
SET @Query = N'select CONVERT(varchar,COUNT(*)) "Linking FX - SCSM Monitoring MP" ' + ' from dbo.EnumType Etype join ' + @TableName + ' SyncStatus on Etype.EnumTypeId = SyncStatus.' + @StatusColumn + ' join dbo.Relationship Rel on Rel.TargetEntityId = SyncStatus.BaseManagedEntityId join dbo.BaseManagedEntity BME '+ 'on BME.BaseManagedEntityId = Rel.SourceEntityId ' + ' WHERE (' + @StatusColumn + ' like ''%FinishedwithError%'') OR ' + '(' + @StatusColumn + ' like ''%Unknown%'') OR ' + '(' + @StatusColumn + ' like ''%NeverRun%'' AND ' + '('+ ' DATEDIFF(MINUTE,' + @StartTimeColumn + ', GETUTCDATE()) >= 5))' 
EXEC(@Query)
'@
    $SQL_SCSM_MS['SQL_ScsmMonitoringMP_Workflows'] = @'
SELECT CONVERT(nvarchar,COUNT(*)) "Workflows - SCSM Monitoring MP"
FROM dbo.WindowsWorkflowTaskJobStatus 
LEFT OUTER JOIN dbo.JobStatusView ON dbo.[JobStatusView].[BatchId] = dbo.[WindowsWorkflowTaskJobStatus].[BatchId] 
LEFT OUTER JOIN dbo.MySubscriptions ON dbo.[WindowsWorkflowTaskJobStatus].[RuleId] = dbo.[MySubscriptions].[RuleEntityId] WHERE (( dbo.[WindowsWorkflowTaskJobStatus].[Processed] IS NULL 
AND ( (dbo.[WindowsWorkflowTaskJobStatus].[ErrorMessage] IS NOT NULL) 
OR (dbo.[JobStatusView].Status = 3) 
OR ((dbo.[JobStatusView].Status = 0 
OR dbo.[JobStatusView].Status = 1) AND (DATEDIFF(MINUTE, dbo.[JobStatusView].TimeScheduled, GETUTCDATE()) >= 25) ) OR( dbo.[JobStatusView].Status = 2) 
OR( dbo.[JobStatusView].Status is NULL) ) ))
and RuleId!='78B51DD8-0183-A48B-3993-E793F3BB9F85'
GO
SELECT R.RuleName, [JobStatusView].[Id],[JobStatusView].[BatchId],[JobStatusView].[Status],[JobStatusView].[TimeStarted],[JobStatusView].[TimeFinished],[JobStatusView].[Output],[WindowsWorkflowTaskJobStatus].[BaseManagedEntityId],[WindowsWorkflowTaskJobStatus].[RuleId],[MySubscriptions].[UserSID],[JobStatusView].[ErrorCode],[JobStatusView].[ErrorMessage],[WindowsWorkflowTaskJobStatus].[ErrorMessage] AS [TaskSubmissionErrorMessage],[WindowsWorkflowTaskJobStatus].[RowId]--, r.*
FROM dbo.WindowsWorkflowTaskJobStatus 
 LEFT OUTER JOIN dbo.JobStatusView 
     ON dbo.[JobStatusView].[BatchId] = dbo.[WindowsWorkflowTaskJobStatus].[BatchId]
 LEFT OUTER JOIN dbo.MySubscriptions 
     ON dbo.[WindowsWorkflowTaskJobStatus].[RuleId] = dbo.[MySubscriptions].[RuleEntityId] 
 LEFT JOIN Rules r on [WindowsWorkflowTaskJobStatus].[RuleId] = r.RuleId
WHERE 
dbo.[WindowsWorkflowTaskJobStatus].[Processed] IS NULL            
AND
(    
	dbo.[WindowsWorkflowTaskJobStatus].[ErrorMessage] IS NOT NULL
	OR ((dbo.[JobStatusView].Status = 0 OR dbo.[JobStatusView].Status = 1) AND (DATEDIFF(MINUTE, dbo.[JobStatusView].TimeScheduled, GETUTCDATE()) >= 25))                
	OR dbo.[JobStatusView].Status = 2
	OR dbo.[JobStatusView].Status = 3                
)
and R.RuleId!='78B51DD8-0183-A48B-3993-E793F3BB9F85'
'@
    $SQL_SCSM_MS['SQL_Connectors'] = @'
SELECT [PC].[S] as Connector_BME
into #BME_Connector
FROM (SELECT [S].[BaseManagedEntityId] AS [S],0 AS CS
	FROM dbo.TypedManagedEntity AS S 
	WHERE (S.[ManagedTypeId] = '71f6cfcd-99b3-3a07-471d-bb9c4bf5ba76'
		AND S.[IsDeleted] = 0)) AS PC
LEFT OUTER JOIN
	(
		SELECT DISTINCT [SourceView].[LastModified], [MTV_Connector].[BaseManagedEntityId]
		FROM dbo.MTV_Connector AS MTV_Connector 
		INNER JOIN dbo.EnterpriseManagementObjectView AS SourceView 
			ON [MTV_Connector].[BaseManagedEntityId] = [SourceView].[Id] 
		WHERE ((SourceView.[MonitoringClassId] = '71F6CFCD-99B3-3A07-471D-BB9C4BF5BA76')) 
	) AS EpilogOrderByJoin0_0 ON EpilogOrderByJoin0_0.[BaseManagedEntityId] = [PC].[S]
SELECT [PC].[S] as BME_Connector,[PC].[T0] as BME_SyncStatus
into #Bme_Map
FROM (SELECT [S].[BaseManagedEntityId] AS [S],0 AS CS,[R0].[TargetEntityId] AS [T0],1 AS CRT0
FROM dbo.TypedManagedEntity AS S 
 LEFT OUTER JOIN dbo.Relationship AS R0 /*SOURCE_HINT_PATTERN*/-- Microsoft.SystemCenter.LinkingFramework.DataSourceHostSyncStatus
     ON (R0.[SourceEntityId] = S.[BaseManagedEntityId]
     AND R0.[RelationshipTypeId] = '1548950d-6cea-d9c1-11ec-53701fbcbbec'
     AND R0.[IsDeleted] = 0)
WHERE (S.[ManagedTypeId] = '71f6cfcd-99b3-3a07-471d-bb9c4bf5ba76'
     AND S.[IsDeleted] = 0)) AS PC 
WHERE [PC].[S] IN (select Connector_BME from #BME_Connector)
 OPTION (KEEP PLAN)
SELECT 
bmecon.DisplayName as "Name",
[MTV_Connector].[Enabled_2B488464_2BCA_D1E4_B438_D6DE9759E808] as "Enabled",
[MTV_Connector].[DataProviderDisplayName_6244FC3E_8D65_C1D5_29E7_1071B0890237] as "Data Provider Name",
CONVERT(datetime, SWITCHOFFSET(CONVERT(datetimeoffset, [MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus].[LastRunStartTime_2B415DAF_7E5C_1241_ADD4_955E08C15B89]), DATENAME(TzOffset, SYSDATETIMEOFFSET())))  as "Start Time",
CONVERT(datetime, SWITCHOFFSET(CONVERT(datetimeoffset, [MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus].[LastRunFinishTime_B2581D10_0D95_2D11_A250_5BFC7E325EDC]), DATENAME(TzOffset, SYSDATETIMEOFFSET())))  as "Finish Time",
lt.LTValue as Status,
[MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus].[SyncPercent_A712979C_DCB0_6936_9F52_802603596BBC] as "Percentage",
datediff(MINUTE,[MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus].[LastRunStartTime_2B415DAF_7E5C_1241_ADD4_955E08C15B89],[MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus].[LastRunFinishTime_B2581D10_0D95_2D11_A250_5BFC7E325EDC]) as Duration_Minutes,
[MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus].[LastRunStartTime_2B415DAF_7E5C_1241_ADD4_955E08C15B89] as "Start Time (UTC)",
[MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus].[LastRunFinishTime_B2581D10_0D95_2D11_A250_5BFC7E325EDC] as "Finish Time (UTC)"
FROM dbo.MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus AS MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus  
	inner join #Bme_Map sync on [MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus].[BaseManagedEntityId]=sync.BME_SyncStatus
	inner join BaseManagedEntity bmeCon on sync.BME_Connector=bmeCon.BaseManagedEntityId
	inner join MTV_Connector on MTV_Connector.BaseManagedEntityId = sync.BME_Connector
	left join LocalizedText lt on Status_6505CB6B_B5DE_D3D0_6DB4_2C746EB1AAC5=lt.LTStringId and lt.LanguageCode='ENU' and lt.LTStringType=1
WHERE [MTV_Microsoft$SystemCenter$LinkingFramework$SyncStatus].[BaseManagedEntityId] IN (select BME_SyncStatus from #Bme_Map)
'@
    $SQL_SCSM_MS['SQL_TroubleshootingWorkflowPerformanceandDelays'] =@'
--Appendix of  https://techcommunity.microsoft.com/t5/system-center-blog/troubleshooting-workflow-performance-and-delays/ba-p/347510
declare @minState bigint, @maxETL bigint
declare @cntCard1 int, @largestRECLetlID bigint

--STEP 1
--Select the minimum watermark
SELECT @minState=MIN(State)
FROM dbo.CmdbInstanceSubscriptionState W WITH (nolock)
JOIN dbo.Rules R
ON W.RuleId = R.RuleId
WHERE R.RuleEnabled <> 0
AND W.IsPeriodicQueryEvent = 0;
-- Example: 1204988

--STEP 2
--Select the max watermark
SELECT @maxETL=MAX(EntityTransactionLogId)  FROM EntityChangeLog WITH (nolock)
-- Example: 1232787

--STEP 3
-- See if the large volume transaction entries in RECL have a target max cardinality=1 relationship.
SELECT 
top 1 @cntCard1=COUNT(*), @largestRECLetlID=RECL.EntityTransactionLogId
--COUNT(*) AS TargetMaxCard1CountInTransaction,RECL.EntityTransactionLogId
FROM dbo.RelatedEntityChangeLog RECL WITH(nolock)
INNER JOIN dbo.RelationshipType RT WITH(nolock)
ON RECL.EntityTypeId = RT.RelationshipTypeId 
WHERE RT.TargetMaxCardinality=1
AND RECL.EntityTransactionLogId <= @maxETL --1232787
AND RECL.EntityTransactionLogId >= @minState --1204988
GROUP BY RECL.EntityTransactionLogId
ORDER BY COUNT(*) DESC
-- TargetMaxCard1CountInTransaction EntityTransactionLogId
-- 1656     1232364

--STEP 4
-- In a large transaction in RECL see if there are target max cardinality = 1 relationships that also have 
-- the source endpoint of the target max cardinality=1 relationship in RECL.
-- This means they are here because their targets changed.
-- Group by target, to see how many sources are associated with the same target.
-- If you see a large count, this is a good candidate to add to exclusion.
SELECT COUNT(*) AS CountOfSourcesForSameTarget,RT.RelationshipTypeId, RECL.RelatedEntityId
FROM dbo.RelatedEntityChangeLog RECL WITH(nolock)
INNER JOIN dbo.RelationshipType RT WITH(nolock)
ON RECL.EntityTypeId = RT.RelationshipTypeId 
INNER JOIN dbo.RelatedEntityChangeLog RECLSOURCE with(nolock)
ON RECL.EntityId = RECLSOURCE.EntityId
WHERE RT.TargetMaxCardinality=1
AND RECLSOURCE.RelatedEntityId IS NULL
AND RECL.EntityTransactionLogId = @largestRECLetlID--'1232364'
AND RECLSOURCE.EntityTransactionLogId = @largestRECLetlID--'1232364'
GROUP BY RT.RelationshipTypeId, RECL.RelatedEntityId
ORDER BY COUNT(*) DESC
---
SELECT '!' as "Custom RelationshipTypes not in ExcludedRelatedEntityChangeLog !",
 R.RelationshipTypeId,
 R.TargetManagedTypeId,
 R.RelationshipTypeName,
 R.TargetMaxCardinality,
 R.ManagementPackId,
 MP.MPName
FROM RelationshipType AS R WITH(NOLOCK)
INNER JOIN ManagementPack AS MP WITH(NOLOCK)
 ON R.ManagementPackId = MP.ManagementPackId
WHERE
 R.TargetMaxCardinality = 1 AND
 R.RelationshipTypeId NOT IN (
 SELECT EX.RelationshipTypeId FROM ExcludedRelatedEntityChangeLog AS EX WITH(NOLOCK)
)
and MP.MPName not in 
('Microsoft.SystemCenter.ConfigurationManager',
'Microsoft.SystemCenter.ServiceManager.Portal',
'Microsoft.SystemCenter.ServiceManager.Portal',
'Microsoft.Windows.Library',
'ServiceManager.IncidentManagement.Library',
'ServiceManager.IncidentManagement.Library',
'ServiceManager.IncidentManagement.Library',
'ServiceManager.LinkingFramework.Library',
'ServiceManager.SLAManagement.Library',
'ServiceManager.SLAManagement.Library',
'System.Knowledge.Library',
'System.Library',
'System.Library',
'System.ServiceCatalog.Library',
'System.SLA.Library',
'System.SLA.Library',
'System.SLA.Library',
'System.SLA.Library',
'System.SLA.Library',
'System.WorkItem.Activity.Library',
'System.WorkItem.Library')
ORDER BY MP.MPName, R.RelationshipTypeName
'@
    $SQL_SCSM_MS['SQL_ForRFH_829977'] = @'
--Regarding UnauthorizedAccessException mentioned in below articles
--https://support.microsoft.com/en-us/topic/update-rollup-2-for-system-center-service-manager-2019-9211f013-33a5-fee4-ea18-d4c35befa831
--https://support.microsoft.com/en-us/topic/update-rollup-10-for-system-center-2016-service-manager-9ffb4362-551d-8a8d-3746-a25d3f379f74

select 'look for for Return based on ImplicitPermission check',substring(text,1,2000) from sys.syscomments where text like '%Procedure%\[AzMan_SPD_AzRoleAssignment_Single_SidMember%' escape '\'
'@  
    $SQL_SCSM_MS['SQL_RegisteredDwInfo'] = @'
select dw.Server_48B308F9_CF0E_0F74_83E1_0AEB1B58E2FA as "DW mgmt server name", dw.DisplayName as DW_MgmtGroupName 
from MT_Microsoft$SystemCenter$ResourceAccessLayer$DwSdkResourceStore dw
inner join BaseManagedEntity bme on dw.BaseManagedEntityId=bme.BaseManagedEntityId
'@
    $SQL_SCSM_MS['SQL_WorkItemsCount']=@'
select count(*) 'IR count in SMDB', min(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Oldest",max(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Newest" from [dbo].[MT_System$WorkItem$Incident]
select count(*) 'SR count in SMDB', min(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Oldest",max(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Newest" from [dbo].[MT_System$WorkItem$ServiceRequest] 
select count(*) 'CR count in SMDB', min(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Oldest",max(CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) as "Newest" from [dbo].[MT_System$WorkItem$ChangeRequest]
'@
    $SQL_SCSM_MS['SQL_WorkItemsCount_ByMonth']=@'
select 'IR in SMDB',datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) year,datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) month,count(*) count
from [dbo].[MT_System$WorkItem$Incident]
group by datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688),datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688)
order by 2,3
select 'SR in SMDB',datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) year,datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) month,count(*) count
from [dbo].[MT_System$WorkItem$ServiceRequest]
group by datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688),datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688)
order by 2,3
select 'CR in SMDB',datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) year,datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688) month,count(*) count
from [dbo].[MT_System$WorkItem$ChangeRequest]
group by datepart(year,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688),datepart(month,CreatedDate_6258638D_B885_AB3C_E316_D00782B8F688)
order by 2,3
'@

    $SQL_SCSM_MS['SQL_DelayedImplicitPermissions']=@'
--To see how many implicit permissions are waiting to be processed
select (select max(entitytransactionlogID) from EntityChangeLog)-EntityTransactionLogID as WatermarksBehind
,EntityTransactionLogID as LastProcessedImplicitPermission,(select max(entitytransactionlogID) from EntityChangeLog) as LatestChangeInSM
from [dbo].[ImplicitUserRoleAdministratorState]
'@

    $SQL_SCSM_MS['SQL_UsersWithMissingImpliedPermissionsOnWorkItems']=@'
--Important: Even if the query shows proper Implicit Role, the work item won't be visible in the Portal if the user has no access permission to the relevant Queues (like IR, SR, RA, MA)
--As mentioned in the WHERE clause below, you may add your SM admins who are not directly added into the SM Administrators role.
--shows all users who are missing ImpliedIncidentAffectedUser Permissions on non-CLOSED Work Items
declare @UserRoleName nvarchar(510)='UserRoleImpliedIncidentAffectedUser'
declare @RelationshipTypeName nvarchar(512)='System.WorkItemAffectedUser' 
declare @UsersWithMissingImpliedPermissions table (Domain_UserName nvarchar(1026) null,BmeID uniqueidentifier not null, SID varbinary(85))
declare @UserRoleId uniqueidentifier=(select UserRoleId from UserRole where UserRoleName = @UserRoleName)
declare @AzRoleID int=(select ID from [dbo].[AzMan_AzScope] where name like convert(nvarchar(50),@UserRoleId))
insert into @UsersWithMissingImpliedPermissions
select distinct Domain_E36D56F2_AD60_E76E_CD5D_9F7AB51AD395+'\'+UserName_6AF77E23_669B_123F_B392_323C17097BBD as 'Permission is missing for User', rs.TargetEntityId as BmeIdUser, 
SUSER_SID(Domain_E36D56F2_AD60_E76E_CD5D_9F7AB51AD395+'\'+UserName_6AF77E23_669B_123F_B392_323C17097BBD) as SID
from Relationship rs 
inner join RelationshipType rst on rs.RelationshipTypeId=rst.RelationshipTypeId and RelationshipTypeName = @RelationshipTypeName and rs.IsDeleted=0
inner join MTV_System$Domain$User MTV_User on MTV_User.BaseManagedEntityId=rs.TargetEntityId
where not exists(select * from [dbo].[AzMan_Role_SIDMember] where RoleID=@AzRoleID and SUSER_Sname(MemberSID)=Domain_E36D56F2_AD60_E76E_CD5D_9F7AB51AD395+'\'+UserName_6AF77E23_669B_123F_B392_323C17097BBD)
select usr.Domain_UserName as 'User is missing Implied Permission' , bme.Name as 'on Work Item'
from @UsersWithMissingImpliedPermissions usr
inner join Relationship rs on usr.BmeID=rs.TargetEntityId and rs.IsDeleted=0 and rs.RelationshipTypeId = 'DFF9BE66-38B0-B6D6-6144-A412A3EBD4CE'
inner join BaseManagedEntity bme on bme.BaseManagedEntityId=rs.SourceEntityId
--below to exclude work items affected by users who are directly set in Administrators role
and not exists(select *
       from [dbo].[AzMan_AzRoleAssignment] ara
       inner join LocalizedText on Name=LTStringId and LTStringType=1 and LanguageCode='ENU'
       inner join userrole on Name=UserRoleId
       inner join AzMan_Role_SIDMember rsidm on ara.ID = rsidm.RoleID
       where  LTValue='Administrators'
       and SUSER_Sname(MemberSID) = usr.Domain_UserName
)
where SID is not null 

--below to exclude Closed IRs, other EnumTypeId can be added into the IN clause eg.  2B8830B6-59F0-F574-9C2A-F4B4682F1681 for IncidentStatusEnum.Resolved
and 1 != (select count(*) from [dbo].[MTV_System$WorkItem$Incident] IR where IR.BaseManagedEntityId = bme.BaseManagedEntityId and IR.Status_785407A9_729D_3A74_A383_575DB0CD50ED='BD0AE7C4-3315-2EB3-7933-82DFC482DBAF')
 
--below to exclude Closed SRs, other EnumTypeId can be added into the IN clause eg.  B026FDFD-89BD-490B-E1FD-A599C78D440F for ServiceRequestStatusEnum.Completed
and 1 != (select count(*) from [dbo].[MTV_System$WorkItem$ServiceRequest] SR where SR.BaseManagedEntityId = bme.BaseManagedEntityId and SR.Status_6DBB4A46_48F2_4D89_CBF6_215182E99E0F IN ('C7B65747-F99E-C108-1E17-3C1062138FC4'))
 
--below to exclude work items affected by users who are NOT directly set in Administrators role directly but indirectly through AD group membership. Add into the IN clause in DOMAIN\USERNAME format
and usr.Domain_UserName NOT IN ('')
 
order by 1,2
'@

    $SQL_SCSM_MS['SQL_UsersWithMissingImpliedPermissionsOnReviewActivities']=@'
--Important: Even if the query shows proper Implicit Role, the work item won't be visible in the Portal if the user has no access permission to the relevant Queues (like IR, SR, RA, MA)
--As mentioned in the WHERE clause below, you may add your SM admins who are not directly added into the SM Administrators role.
--shows all users who are missing ImpliedReviewer Permissions on non-COMPLETED Review Activities
declare @UserRoleName nvarchar(510)='UserRoleImpliedReviewer'
declare @RelationshipTypeName nvarchar(512)='System.ReviewerIsUser' 
declare @UsersWithMissingImpliedPermissions table (Domain_UserName nvarchar(1026) null,BmeID uniqueidentifier not null, SID varbinary(85))
declare @UserRoleId uniqueidentifier=(select UserRoleId from UserRole where UserRoleName = @UserRoleName)
declare @AzRoleID int=(select ID from [dbo].[AzMan_AzScope] where name like convert(nvarchar(50),@UserRoleId))
insert into @UsersWithMissingImpliedPermissions
select distinct Domain_E36D56F2_AD60_E76E_CD5D_9F7AB51AD395+'\'+UserName_6AF77E23_669B_123F_B392_323C17097BBD as 'Permission is missing for User', rs.TargetEntityId as BmeIdUser,
SUSER_SID(Domain_E36D56F2_AD60_E76E_CD5D_9F7AB51AD395+'\'+UserName_6AF77E23_669B_123F_B392_323C17097BBD) as SID
from Relationship rs 
inner join RelationshipType rst on rs.RelationshipTypeId=rst.RelationshipTypeId and RelationshipTypeName = @RelationshipTypeName and rs.IsDeleted=0
inner join MTV_System$Domain$User MTV_User on MTV_User.BaseManagedEntityId=rs.TargetEntityId
where not exists(select * from [dbo].[AzMan_Role_SIDMember] where RoleID=@AzRoleID and SUSER_Sname(MemberSID)=Domain_E36D56F2_AD60_E76E_CD5D_9F7AB51AD395+'\'+UserName_6AF77E23_669B_123F_B392_323C17097BBD)
select usr.Domain_UserName as 'User is missing Implied Permission', bme2.Name as 'on Review Activity'
from @UsersWithMissingImpliedPermissions usr
inner join Relationship rs on usr.BmeID=rs.TargetEntityId and rs.IsDeleted=0 and rs.RelationshipTypeId = '90DA7D7C-948B-E16E-F39A-F6E3D1FFC921'
inner join BaseManagedEntity bme on bme.BaseManagedEntityId=rs.SourceEntityId
inner join Relationship rs2 on rs.SourceEntityId=rs2.TargetEntityId and rs2.IsDeleted=0 and rs2.RelationshipTypeId = '6E05D202-38A4-812E-34B8-B11642001A80'
inner join BaseManagedEntity bme2 on bme2.BaseManagedEntityId=rs2.SourceEntityId
and not exists(select *
       from [dbo].[AzMan_AzRoleAssignment] ara
       inner join LocalizedText on Name=LTStringId and LTStringType=1 and LanguageCode='ENU'
       inner join userrole on Name=UserRoleId
       inner join AzMan_Role_SIDMember rsidm on ara.ID = rsidm.RoleID
       where  LTValue='Administrators'
       and SUSER_Sname(MemberSID) = usr.Domain_UserName
)
where SID is not null 

--below to exclude Completed RAs, other EnumTypeId can be added into the IN clause eg.  144BCD52-A710-2778-2A6E-C62E0C8AAE74 for ActivityStatusEnum.Failed
and 1 != (select count(*) from [dbo].[MTV_System$WorkItem$Activity$ReviewActivity] RA where RA.BaseManagedEntityId = bme2.BaseManagedEntityId and RA.Status_8895EC8D_2CBF_0D9D_E8EC_524DEFA00014 in ('9DE908A1-D8F1-477E-C6A2-62697042B8D9'))
 
--below to exclude users who are NOT directly set in Administrators role directly but indirectly through AD group membership. Add into the IN clause in DOMAIN\USERNAME format
and usr.Domain_UserName NOT IN ('')
 
order by 1,2
'@


    foreach($SQL_SCSM_MS_Text in $SQL_SCSM_MS.Keys) {
        SaveSQLResultSetsToFiles $SQLInstance_SCSM $SQLDatabase_SCSM ($SQL_SCSM_MS[$SQL_SCSM_MS_Text]) "$SQL_SCSM_MS_Text.csv"    
    }

}

function Collect_Test_BetweenMSandDWMS() {
    $RegisteredDwMSName=(Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSM -SQLDatabase $SQLDatabase_SCSM -Query 'select Server_48B308F9_CF0E_0F74_83E1_0AEB1B58E2FA as DWMSName from MT_Microsoft$SystemCenter$ResourceAccessLayer$DwSdkResourceStore').Tables[0].DWMSName
    if ($RegisteredDwMSName) {
        AppendOutputToFileInTargetFolder (Test-NetConnection -ComputerName $RegisteredDwMSName -Port 5724) Telnet_FromSM_ToDW.txt
        AppendOutputToFileInTargetFolder (Test-Connection -ComputerName $RegisteredDwMSName | ft -Wrap -Autosize) Ping_FromSM_ToDW.txt
    }
}

function Collect_Test_BetweenMSandSQL() {
    AppendOutputToFileInTargetFolder (Test-NetConnection -ComputerName (GetMachineNameFromSqlInstance $SQLInstance_SCSM) -Port (GetPortFromSqlInstance $SQLInstance_SCSM)) Telnet_FromSM_ToSQL.txt  
    AppendOutputToFileInTargetFolder (Test-Connection -ComputerName (GetMachineNameFromSqlInstance $SQLInstance_SCSM) | ft -Wrap -Autosize ) Ping_FromSM_ToSQL.txt 
}

function Collect_TimeDiffBetweenMSandSQL() {
    #Getting the time diff via PS (if possible)
    $compNameToCheckTimeDiff = (GetMachineNameFromSqlInstance $SQLInstance_SCSM)
    $result = Run2ndOnlyIf1stSucceeds { 
        InvokeCommand -computerName $compNameToCheckTimeDiff -scriptBlock {Get-Date} 
        }{
        New-TimeSpan -Start (Get-Date) -End $resultOf1 
    }
    AppendOutputToFileInTargetFolder ( $result ) "TimeDiff_BtwMS_AndSQL.txt";    
    
    # additionally, getting the time diff via win32tm
    AppendOutputToFileInTargetFolder ( w32tm.exe /stripchart /dataonly /samples:1 /computer:$compNameToCheckTimeDiff 2>&1 ) "TimeDiff_BtwMS_AndSQL_viaWin32tm.txt"
}

function Collect_Workflows() {
    AppendOutputToFileInTargetFolder (Get-SCSMWorkflow | fl *) "Get-SCSMWorkflow.txt"
}

function Collect_FromWFAndSecondary() {
#region DO NOT REMOVE THIS! Exit immediately if script is NOT running on a WF or Secondary server
if (-not (IsThisScsmMgmtServer)) {
    return
}
#endregion

# Collects info that is specific to only WF and Secondary Management Servers

    Collect_SCSMRolesFound
    Collect_SCSMSettings
    Collect_SCOMCIConnectorAllowList
    Collect_Connectors
    Collect_NotificationChannel
    Collect_EmailTemplates
    Collect_Workflows
    Collect_EmailSendingRules
    Collect_ConnectorEclLogSettings
    Collect_TimeDiffBetweenMSandSQL
    Collect_MPs    
    Collect_SqlErrorLogFiles
    Collect_Test_BetweenMSandSQL 
    Collect_Test_BetweenMSandDWMS

    Collect_SQL_MS_Shared
    Collect_SQL_MS_Specific

    Collect_RegisteredDWEnvironmentInfo
}

function Collect_OnlyMgmtServerSpecificInfo() {
#region DO NOT REMOVE THIS! Exit immediately if script is NOT running on a WF or Secondary or DW mgmt server
if (-not (IsThisAnyScsmMgmtServer)) {
    return
}
#endregion

#region DO NOT MOVE THIS! To be used in subsequent functions
#region Import SM Module and fetch SM DB Location
if (!(Get-Module System.Center.Service.Manager)) {    
        Import-Module ((Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Service Manager\Setup').InstallDirectory +'PowerShell\' +'System.Center.Service.Manager.psd1') -force 
}

$SQLInstance_SCSM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').DatabaseServerName
$SQLDatabase_SCSM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').DatabaseName
#endregion
#region Import DW Module and fetch DW DB Locations
if (!(Get-Module Microsoft.EnterpriseManagement.Warehouse.Cmdlets)) {    
    Import-Module ((Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Service Manager\Setup').InstallDirectory +'Microsoft.EnterpriseManagement.Warehouse.Cmdlets.psd1') -force
}

$SQLInstance_SCSMDW = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').StagingSQLInstance
$SQLDatabase_SCSMDW = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').StagingDatabaseName

$SQLInstance_SCSMDW_Rep = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').RepositorySQLInstance
$SQLDatabase_SCSMDW_Rep = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').RepositoryDatabaseName

$SQLInstance_SCSMDW_DM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').DataMartSQLInstance
$SQLDatabase_SCSMDW_DM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').DataMartDatabaseName

$SQLInstance_SCSMDW_CMDM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').CMDataMartSQLInstance
$SQLDatabase_SCSMDW_CMDM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').CMDataMartDatabaseName

$SQLInstance_SCSMDW_OMDM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').OMDataMartSQLInstance
$SQLDatabase_SCSMDW_OMDM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').OMDataMartDatabaseName
    #endregion
#region Setting SQL SHARED query definitions that will be LATER executed by all mgmt servers including DW
$SQL_SCSM_Shared =@{}
$SQL_SCSM_Shared['SQL_Date']=@'
select SYSDATETIMEOFFSET() as LocalTime, FORMAT(GETUTCDATE(),N'yyyy-MM-dd__HH:mm.ss.fff') as UtcTime
'@
$SQL_SCSM_Shared['SQL_MOMManagementGroupInfo']=@'
select '__MOMManagementGroupInfo__' tableName,* from [__MOMManagementGroupInfo__]
'@
$SQL_SCSM_Shared['SQL_Databases']=@'
SELECT name,is_broker_enabled,compatibility_level,recovery_model_desc,* FROM sys.databases order by 1
'@
$SQL_SCSM_Shared['SQL_dm_os_schedulers']=@'
SELECT * FROM sys.dm_os_schedulers WHERE scheduler_id < 255;
'@
$SQL_SCSM_Shared['SQL_CurrentlyRunningQueries']=@'
SELECT SUBSTRING(sqltext.text, ( req.statement_start_offset / 2 ) + 1, 
              ( ( CASE WHEN req.statement_end_offset <= 0
                       THEN DATALENGTH(sqltext.text) 
              ELSE req.statement_end_offset END - 
       req.statement_start_offset ) / 2 ) + 1) AS statement_text,
sqltext.TEXT, req.last_wait_type,req.session_id,req.status,req.command,req.cpu_time,req.total_elapsed_time,blocking_session_id
,database_id,DB_NAME(database_id), p.hostname,p.hostprocess
FROM sys.dm_exec_requests req
CROSS APPLY sys.dm_exec_sql_text(sql_handle) AS sqltext 
left join sys.sysprocesses p on req.session_id=p.spid
where req.session_id !=@@spid
and  req.last_wait_type not like '%broker%'
'@
$SQL_SCSM_Shared['SQL_database_scoped_configurations_IfGe2016']=@'
if (select convert(smallint,SERVERPROPERTY('ProductMajorVersion'))) >= 13 --greater than or equal sql 2016
SELECT
(select value from sys.database_scoped_configurations as dsc where dsc.name = 'MAXDOP') AS [MaxDop],
(select value_for_secondary from sys.database_scoped_configurations as dsc where dsc.name = 'MAXDOP') AS [MaxDopForSecondary],
(select value from sys.database_scoped_configurations as dsc where dsc.name = 'LEGACY_CARDINALITY_ESTIMATION') AS [LegacyCardinalityEstimation],
(select ISNULL(value_for_secondary, 2) from sys.database_scoped_configurations as dsc where dsc.name = 'LEGACY_CARDINALITY_ESTIMATION') AS [LegacyCardinalityEstimationForSecondary],
(select value from sys.database_scoped_configurations as dsc where dsc.name = 'PARAMETER_SNIFFING') AS [ParameterSniffing],
(select ISNULL(value_for_secondary, 2) from sys.database_scoped_configurations as dsc where dsc.name = 'PARAMETER_SNIFFING') AS [ParameterSniffingForSecondary],
(select value from sys.database_scoped_configurations as dsc where dsc.name = 'QUERY_OPTIMIZER_HOTFIXES') AS [QueryOptimizerHotfixes],
(select ISNULL(value_for_secondary, 2) from sys.database_scoped_configurations as dsc where dsc.name = 'QUERY_OPTIMIZER_HOTFIXES') AS [QueryOptimizerHotfixesForSecondary]
else
select 'no sys.database_scoped_configurations available for this sql version'
'@
$SQL_SCSM_Shared['SQL_DatabaseFiles']=@'
select sys.databases.name, sys.databases.database_id,sys.master_files.physical_name,size*8/1024 SizeInMB  from sys.databases join sys.master_files on sys.databases.database_id = sys.master_files.database_id where sys.databases.source_database_id is null order by 1,3
'@
$SQL_SCSM_Shared['SQL_sp_configure']=@'
exec sp_configure 'show advanced options',1 
RECONFIGURE
exec sp_configure
'@
$SQL_SCSM_Shared['SQL_dm_os_sys_info']=@'
select * from sys.dm_os_sys_info 
'@
$SQL_SCSM_Shared['SQL_dm_os_wait_stats']=@'
SELECT TOP 15 * FROM sys.dm_os_wait_stats ORDER BY wait_time_ms DESC
'@
$SQL_SCSM_Shared['SQL_sp_helplogins']=@'
exec master..sp_helplogins
'@
$SQL_SCSM_Shared['SQL_LoginsInfo']=@'
select name,language,sysadmin from sys.syslogins order by 1
'@
$SQL_SCSM_Shared['SQL_DbUsersInfo']=@'
DECLARE @DB_USers TABLE
(DBName sysname, UserName sysname, LoginType sysname, AssociatedRole varchar(max),create_date datetime,modify_date datetime)
INSERT @DB_USers
EXEC sp_MSforeachdb
'use [?]
SELECT ''?'' AS DB_Name,
case prin.name when ''dbo'' then prin.name + '' (''+ (select SUSER_SNAME(owner_sid) from master.sys.databases where name =''?'') + '')'' else prin.name end AS UserName,
prin.type_desc AS LoginType,
isnull(USER_NAME(mem.role_principal_id),'''') AS AssociatedRole ,create_date,modify_date
FROM sys.database_principals prin
LEFT OUTER JOIN sys.database_role_members mem ON prin.principal_id=mem.member_principal_id
WHERE prin.sid IS NOT NULL and prin.sid NOT IN (0x00) and
prin.is_fixed_role <> 1 AND prin.name NOT LIKE ''##%'''
SELECT
dbname,username ,logintype ,create_date ,modify_date ,
STUFF(
	(SELECT ',' + CONVERT(VARCHAR(500),associatedrole)
	FROM @DB_USers user2
	WHERE
	user1.DBName=user2.DBName AND user1.UserName=user2.UserName
	FOR XML PATH('')
	)
	,1,1,''
	) AS Permissions_user
FROM @DB_USers user1
WHERE dbname=DB_NAME()
GROUP BY dbname,username ,logintype ,create_date ,modify_date
ORDER BY DBName,username
'@
$SQL_SCSM_Shared['SQL_FragmentationInfo']=@'
SELECT OBJECT_NAME(ind.OBJECT_ID) AS TableName,
ind.name AS IndexName, indexstats.index_type_desc AS IndexType,
indexstats.avg_fragmentation_in_percent--,*
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, NULL) indexstats
INNER JOIN sys.indexes ind
ON ind.object_id = indexstats.object_id
AND ind.index_id = indexstats.index_id
ORDER BY indexstats.avg_fragmentation_in_percent DESC
'@
$SQL_SCSM_Shared['SQL_TableSizeInfo']=@'
declare c cursor local FORWARD_ONLY READ_ONLY for
select '['+ s.name +'].['+ o.name +']'
from sys.objects o
inner join sys.schemas s on o.schema_id=s.schema_id 
where o.type='U' 
order by o.name
declare @fqName nvarchar(max)
declare  @tbl table(
name nvarchar(max),
rows bigint,
reserved varchar(18),
data varchar(18),
index_size varchar(18),
unused varchar(18)
)
open c
while 1=1
begin
fetch c into @fqName
if @@FETCH_STATUS<>0 break
	insert into @tbl
	exec sp_spaceused @fqName
end
close c
deallocate c
select name,rows,data,index_size,unused from @tbl order by rows desc
'@
$SQL_SCSM_Shared['SQL_GroomingConfiguration']=@'
SELECT mt.TypeName,gc.RetentionPeriodInMinutes/60/24 as Days,gc.*
FROM [dbo].[MT_GroomingConfiguration] gc
inner join ManagedType mt on gc.TargetId=mt.ManagedTypeId
'@
$SQL_SCSM_Shared['SQL_GroomingConfiguration_Log']=@'
select * from [dbo].[MT_GroomingConfiguration_Log]
'@
$SQL_SCSM_Shared['SQL_PartitionAndGroomingSettings']=@'
select * from [dbo].[PartitionAndGroomingSettings]
'@
$SQL_SCSM_Shared['SQL_ManagementPack']=@'
select mp.ManagementPackId,MPIsSealed,MPName,MPFriendlyName,lt.LTValue as MPDisplayName, MPVersionDependentId,MPVersion,MPKeyToken,MPReadOnly,MPXMLInvalid, MPLastModified,MPCreated,MPSchemaTypes,MPCacheRefreshTimestamp,ContentReadable
from ManagementPack mp left join LocalizedText lt on mp.ManagementPackId=lt.LTStringId and lt.LTStringType=1 and lt.LanguageCode='ENU'
'@
$SQL_SCSM_Shared['SQL_ManagementPackHistory']=@'
select * from ManagementPackHistory
'@
$SQL_SCSM_Shared['SQL_ManagedType']=@'
select * from ManagedType
'@
$SQL_SCSM_Shared['SQL_ManagedTypeProperty']=@'
select mt.TypeName,* 
from ManagedTypeProperty mtp
inner join ManagedType mt on mtp.ManagedTypeId=mt.ManagedTypeId
order by 1,4
'@
$SQL_SCSM_Shared['SQL_Event1209']=@'
select ' !!! ' "Event ID: 1209 and Service Manager Workflows are stuck" , MP.ManagementPackId, MP.MPVersionDependentId, MP.MPName, MPVersion, MP.MPKeyToken,cast(MPRunTimeXML as xml).value('(/ManagementPack/@RevisionId)[1]','uniqueidentifier') as CorrectRevisionId , Convert(xml,MP.MPRunTimeXML) as MPRunTimeXML 
from ManagementPack as MP
where MP.MPIsSealed = 1 and MP.MPVersionDependentId != dbo.fn_MPVersionDependentId(MP.MPName, MP.MPKeyToken, MPVersion)
'@
$SQL_SCSM_Shared['SQL_Info'] = @'
select @@VERSION as "@@VERSION"
create table #SVer(ID int,  Name  sysname, Internal_Value int, Value nvarchar(512))
insert #SVer exec master.dbo.xp_msver
if exists (select 1 from sys.all_objects where name = 'dm_os_host_info' and type = 'V' and is_ms_shipped = 1)
begin
insert #SVer select t.*
from sys.dm_os_host_info
CROSS APPLY (
VALUES
(1001, 'host_platform', 0, host_platform),
(1002, 'host_distribution', 0, host_distribution),
(1003, 'host_release', 0, host_release),
(1004, 'host_service_pack_level', 0, host_service_pack_level),
(1005, 'host_sku', host_sku, '')
) t(id, [name], internal_value, [value])
end
declare @SmoRoot nvarchar(512)
exec master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\Setup', N'SQLPath', @SmoRoot OUTPUT
SELECT
(select Value from #SVer where Name = N'ProductName') AS [Product],
SERVERPROPERTY(N'ProductVersion') AS [VersionString],
(select Value from #SVer where Name = N'Language') AS [Language],
(select Value from #SVer where Name = N'Platform') AS [Platform],
CAST(SERVERPROPERTY(N'Edition') AS sysname) AS [Edition],
(select Internal_Value from #SVer where Name = N'ProcessorCount') AS [Processors],
(select Value from #SVer where Name = N'WindowsVersion') AS [OSVersion],
(select Internal_Value from #SVer where Name = N'PhysicalMemory') AS [PhysicalMemory],
CAST(ISNULL(SERVERPROPERTY('IsClustered'),N'') AS bit) AS [IsClustered],
@SmoRoot AS [RootDirectory],
convert(sysname, serverproperty(N'collation')) AS [Collation],
( select Value from #SVer where Name =N'host_platform') AS [HostPlatform],
( select Value from #SVer where Name =N'host_release') AS [HostRelease],
( select Value from #SVer where Name =N'host_service_pack_level') AS [HostServicePackLevel],
( select Value from #SVer where Name =N'host_distribution') AS [HostDistribution]
drop table #SVer
GO
'@
$SQL_SCSM_Shared['SQL_Rules'] = @'
select * from Rules
'@
$SQL_SCSM_Shared['SQL_Dbcc_Useroptions'] = @'
dbcc useroptions
'@
$SQL_SCSM_Shared['SQL_ForRFH_430445'] = @'
select 'check for Nvarchar and WITH RECOMPILE',substring(text,1,500) from sys.syscomments where text like '%CREATE PROCEDURE%SelectForNewTypeCache%'
'@
$SQL_SCSM_Shared['SQL_information_schema_columns'] = @'
select * from information_schema.columns order by Table_name,COLUMN_NAME
'@
$SQL_SCSM_Shared['SQL_Indexes'] = @'
--Taken from https://stackoverflow.com/questions/765867/list-of-all-index-index-columns-in-sql-server-db
SELECT '[' + s.NAME + '].[' + o.NAME + ']' AS 'table_name'
    ,+ i.NAME AS 'index_name'
    ,LOWER(i.type_desc) + CASE 
        WHEN i.is_unique = 1
            THEN ', unique'
        ELSE ''
        END + CASE 
        WHEN i.is_primary_key = 1
            THEN ', primary key'
        ELSE ''
        END AS 'index_description'
    ,STUFF((
            SELECT ', [' + sc.NAME + ']' AS "text()"
            FROM syscolumns AS sc
            INNER JOIN sys.index_columns AS ic ON ic.object_id = sc.id
                AND ic.column_id = sc.colid
            WHERE sc.id = so.object_id
                AND ic.index_id = i1.indid
                AND ic.is_included_column = 0
            ORDER BY key_ordinal
            FOR XML PATH('')
            ), 1, 2, '') AS 'indexed_columns'
    ,STUFF((
            SELECT ', [' + sc.NAME + ']' AS "text()"
            FROM syscolumns AS sc
            INNER JOIN sys.index_columns AS ic ON ic.object_id = sc.id
                AND ic.column_id = sc.colid
            WHERE sc.id = so.object_id
                AND ic.index_id = i1.indid
                AND ic.is_included_column = 1
            FOR XML PATH('')
            ), 1, 2, '') AS 'included_columns'
FROM sysindexes AS i1
INNER JOIN sys.indexes AS i ON i.object_id = i1.id
    AND i.index_id = i1.indid
INNER JOIN sysobjects AS o ON o.id = i1.id
INNER JOIN sys.objects AS so ON so.object_id = o.id
    AND is_ms_shipped = 0
INNER JOIN sys.schemas AS s ON s.schema_id = so.schema_id
WHERE so.type = 'U'
    AND i1.indid < 255
    AND i1.STATUS & 64 = 0 --index with duplicates
    AND i1.STATUS & 8388608 = 0 --auto created index
    AND i1.STATUS & 16777216 = 0 --stats no recompute
    AND i.type_desc <> 'heap'
    AND so.NAME <> 'sysdiagrams'
ORDER BY table_name
    ,index_name;
'@
$SQL_SCSM_Shared['SQL_BackupInfo'] = @'
SELECT 
    database_name
    , case type
	when 'D' then 'Database'
	when 'I' then 'Differential database'
	when 'L' then 'Log'
	when 'F' then 'File or filegroup'
	when 'G' then 'Differential file'
	when 'P' then 'Partial'
	when 'Q' then 'Differential partial'
	else '(unknown)'
	 end AS BackupType
    , MAX(backup_start_date) AS LastBackupDate
    , GETDATE() AS CurrentDate
    , DATEDIFF(DD,MAX(backup_start_date),GETDATE()) AS DaysSinceBackup
FROM msdb.dbo.backupset BS JOIN master.dbo.sysdatabases SD ON BS.database_name = SD.[name]
GROUP BY database_name, type 
ORDER BY database_name, type
'@
$SQL_SCSM_Shared['SQL_Get-SCSMUserRole'] = @'
select LocalizedText.LTValue as UserRoleName,  SUSER_Sname(MemberSID) as MembersInRole
	from [dbo].[AzMan_AzRoleAssignment] ara
	inner join LocalizedText on Name=LTStringId and LTStringType=1 and LanguageCode='ENU'
	inner join userrole on Name=UserRoleId
	inner join AzMan_Role_SIDMember rsidm on ara.ID = rsidm.RoleID
order by 1,2
'@
#endregion 
#endregion

Collect_FromDWAndWFAndSecondary

Collect_FromWFAndSecondary
Collect_FromWFAndDW
#Collect_FromDWAndSecondary  #ignored because I don't know anything common between DW AND Secondary

Collect_FromDW
Collect_FromWF
Collect_FromSecondary

}

function Collect_OnlyPortalSpecificInfo() {
#region Exit immediately if Portal is NOT installed
if (-not (IsScsmHtmlPortalInstalled)) {
    return
}
#endregion

	
}

function Collect() {

#region Collector Initial tasks
$resultPrefix = "SCSM_DIAG"
$collectorVersion = $toolVersion #"1.0.5.24"   

$resultFolderPath = Split-Path $scriptFilePath
$resultDateTime = (Get-Date).ToString("yyyy-MM-dd__HH.mm.ss.fff")
$collector_FolderName = "Collector"    
$resultFolder = New-Item -Force -ItemType Directory -Path $resultFolderPath -Name "$($resultPrefix)_$resultDateTime\$collector_FolderName"
Start-Transcript -Path "$resultFolder\Transcript_$resultDateTime.txt" -NoClobber | Out-Null

Write-Host "This script does *NOT* make any change in your SCSM environment. It is completely read-only."
Write-Host ""
Write-Host "SCSM Diagnostic Tool started at $resultDateTime. (local time)"
Write-Host "Please wait for completion. This can take a few minutes..." -ForegroundColor Yellow
Write-Host "(Please ignore any Warning and Errors)"

CopyFileToTargetFolder $scriptFilePath
AppendOutputToFileInTargetFolder ( $collectorVersion ) CollectorVersion.txt

$PSDefaultParameterValues['out-file:width'] = 2000
$FormatEnumerationLimit = -1 #prevents truncation of column values if no fit
$ProgressPreference = 'SilentlyContinue'
#endregion

#region Start Collecting
Collect_Info
#endregion

#region Waiting for background tasks to complete
foreach($psJob in Get-Job) {
    while ( $psJob.State -eq [System.Management.Automation.JobState]::Running ) {
        Start-Sleep -Seconds 1 
    } 
}
#endregion

#region Collector Final tasks
Write-Host ""
$completionDateTime = (Get-Date).ToString("yyyy-MM-dd__HH.mm.ss.fff")  

$currentBackgroundColor = $host.UI.RawUI.BackgroundColor.ToString()
if ($currentBackgroundColor -eq "-1") { $currentBackgroundColor = "DarkBlue" }
Write-Host "Collection completed at $completionDateTime. (local time)" -ForegroundColor $currentBackgroundColor #not to see in PS window but still in the transcript file

$script:SQLResultSetCounter = $null
Stop-Transcript | out-null
#$ProgressPreference = 'Continue'

$zipFileTargetFolder = Split-Path $scriptFilePath
$resultingZipFile_FullPath = (Join-Path -Path $zipFileTargetFolder -ChildPath "$($resultPrefix)_$($script:RoleFoundAbbr)_$($resultDateTime).zip")

$currentFolderName = "$($resultPrefix)_$($resultDateTime)"
$newFolderName = "$($resultPrefix)_$($script:RoleFoundAbbr)_$($resultDateTime)"
Rename-Item -Path $currentFolderName -NewName $newFolderName
#endregion

return $resultingZipFile_FullPath # actually, there's no real zip file (anymore), but Analyzer will handle this accordingly
}

function Collect_Info() {

    Collect_NonScsmSpecificMachineInfo
    
    Collect_OnlyMgmtServerSpecificInfo
    Collect_OnlyPortalSpecificInfo
    Collect_OnlyConsoleSpecificInfo

}

#region internal function definitions used by Collector and Analyzer
function IsRunningAsElevated() {
    return $(([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))
}
function CreateNewFileInTargetFolder($fileName) {
    New-Item -Force -ItemType File -Path $resultFolder -Name $fileName | Out-Null
}
function CreateNewFolderInTargetFolder($folderName) {
    New-Item -Force -ItemType Directory -Path $resultFolder -Name $folderName | Out-Null
}
function GetFileNameInTargetFolder($fileName) {
    return Join-Path -Path $resultFolder -ChildPath $fileName
}
function GetFileContentInTargetFolder($fileName) {
    return Get-Content -Path (Join-Path -Path $resultFolder -ChildPath $fileName) | Out-String
    #return [IO.File]::ReadAllText( (Join-Path -Path $resultFolder -ChildPath $fileName) )
}
function DeleteFileInTargetFolder($fileName) {
    return Remove-Item -Path (Join-Path -Path $resultFolder -ChildPath $fileName)
}
function FileDoesExistInTargetFolder($fileName) {
    return Test-Path -Path (Join-Path -Path $resultFolder -ChildPath $fileName)
}
function FileDoesNotExistInTargetFolder($fileName) {
    return -Not (FileDoesExistInTargetFolder $fileName)
}
function CopyFileToTargetFolder($fileName, $subFolderName) {
  if ([string]::IsNullOrEmpty($subFolderName) -or $subFolderName -eq ".") { 
    Copy-Item $fileName -Destination $resultFolder}
  else  {
    New-Item -ItemType Directory -Force -Path "$resultFolder\$subFolderName" | Out-Null
    Copy-Item $fileName -Destination "$resultFolder\$subFolderName" }
}
function MoveFileInTargetFolder($fileName, $subFolderName) {
    $fileToMove=GetFileNameInTargetFolder $fileName
    CopyFileToTargetFolder $fileToMove $subFolderName
    DeleteFileInTargetFolder $fileName
}
function AppendOutputToFileInTargetFolder($obj, $fileName) {
    $resultFilePath = Join-Path -Path $resultFolder -ChildPath $fileName    
    if (!(Test-Path $resultFilePath))
    {
       New-Item $resultFilePath -ItemType File -Force | Out-Null
    }
    $obj | Out-File -FilePath $resultFilePath -Encoding utf8 -Append 
}

function SaveSQLResultSetsToFiles($SQLInstance, $SQLDatabase, $SQLQuery, $fileName, $includeBatchInResultSet, [int]$SqlCommandTimeoutSeconds = 0) 
{
    if (-not (Get-Variable -Name SQLResultSetCounter -Scope Script -ErrorAction SilentlyContinue)) {
    #if ([string]::IsNullOrEmpty($script:SQLResultSetCounter)) 
        $script:SQLResultSetCounter=1
    }
    
    $batches = $SQLQuery -split '(?:\bGO\b)'
    foreach($batch in $batches)
    {
        if ([string]::IsNullOrEmpty($batch.Trim())) {continue}
        $DS= Try-Invoke-SqlCmd -SQLInstance $SQLInstance -SQLDatabase $SQLDatabase -Query $batch -SqlCommandTimeoutSeconds $SqlCommandTimeoutSeconds
        $targetCsvFileName = $fileName 

#        if ($DS.Tables.Count -eq 0) { # write the Sql Print messages
#            AppendOutputToFileInTargetFolder $global:SqlPrintMessages $targetCsvFileName
#        }
#        else {
            foreach($dataTable in $DS.Tables) 
            {            
                if ([string]::IsNullOrEmpty($targetCsvFileName))
                {
                    $targetCsvFileName = "SQLResultSet_$script:SQLResultSetCounter.csv"
                    $script:SQLResultSetCounter++
                }            
                SaveSQLResultToFile ($dataTable) $targetCsvFileName $batch #$includeBatchInResultSet      
            }
            AppendOutputToFileInTargetFolder $global:SqlPrintMessages $targetCsvFileName

#       }

        if ($includeBatchInResultSet -eq $null) {$includeBatchInResultSet=$true}
        if ($includeBatchInResultSet) {
            AppendOutputToFileInTargetFolder "" $targetCsvFileName
            AppendOutputToFileInTargetFolder "/*------------------------`r`n$($batch.Trim())`r`n------------------------*/" $targetCsvFileName 
        }
    }
}

function SaveSQLResultToFile($dataTable, $fileName, $batch)  #, $includeBatchInResultSet) 
{
    $TempFileName = ([guid]::NewGuid()).ToString()    
    AppendOutputToCsvFileInTargetFolder ($dataTable) $TempFileName
    #if ($includeBatchInResultSet -eq $null) {$includeBatchInResultSet=$true}
    #if ($includeBatchInResultSet) {
    #    AppendOutputToFileInTargetFolder "" $TempFileName
    #    AppendOutputToFileInTargetFolder "/*------------------------`r`n$($batch.Trim())`r`n------------------------*/" $TempFileName 
    #}
    AppendOutputToFileInTargetFolder "" $fileName
    AppendOutputToFileInTargetFolder (GetFileContentInTargetFolder $TempFileName) $fileName
    DeleteFileInTargetFolder $TempFileName
}

function Try-Invoke-SqlCmd
{
param (
        [Parameter(Mandatory=$true)] [string]$SQLInstance,
        [Parameter(Mandatory=$true)] [string]$SQLDatabase,
        [Parameter(Mandatory=$true)] [string]$Query,
        [Parameter(Mandatory=$false)] [int]$SqlCommandTimeoutSeconds = 0
)
# I do not use Invoke-Sqlcmd anymore because it requires 1. distinct column names and 2. Module "SqlServer" to be installed
#      $DS = Invoke-Sqlcmd -ServerInstance $SQLInstance -Database $SQLDatabase -Query $Query -OutputAs DataSet -QueryTimeout 0 -OutputSqlErrors $true -IncludeSqlUserErrors -MaxCharLength ([int32]::MaxValue)
#      return $DS;

    if ($SqlCommandTimeoutSeconds -eq 0) {
        $DS = Invoke-AlternativeSqlCmd_WithoutTimeout $SQLInstance $SQLDatabase $Query
    }
    else {
        $DS = Invoke-AlternativeSqlCmd_WithTimeout $SQLInstance $SQLDatabase $Query $SqlCommandTimeoutSeconds

    }
    return $DS;

}
function Invoke-AlternativeSqlCmd_WithoutTimeout($SQLInstance, $SQLDatabase, $SQLQuery)
{
    $SqlConnection = New-Object System.Data.SqlClient.SqlConnection
    $SqlConnection.ConnectionString = "Server=$SQLInstance; Database=$SQLDatabase; Trusted_Connection=True"
    $SqlConnection.Open() 

    $SqlAdp = New-Object System.Data.SqlClient.SqlDataAdapter
    $SqlCmd = New-Object System.Data.SqlClient.SqlCommand
    $SqlCmd.CommandText = $SQLQuery
    $SqlCmd.Connection = $SqlConnection
    $SqlCmd.CommandTimeout = 0 # do NOT change this!
    $SqlAdp.SelectCommand = $SqlCmd

        $global:SqlPrintMessages=""
        $handler = [System.Data.SqlClient.SqlInfoMessageEventHandler] {
            param($sender, $event) 
            $global:SqlPrintMessages += "`n" + $event.Message 
        };
        $SqlConnection.add_InfoMessage($handler); 
        $SqlConnection.FireInfoMessageEventOnUserErrors = $true;


    $DS = New-Object System.Data.DataSet
    $SqlAdp.Fill($DS) | out-null  # keep the out-null otherwise $DS will return as Object[]
    return $DS;
}

function Invoke-AlternativeSqlCmd_WithTimeout($SQLInstance, $SQLDatabase, $SQLQuery, [int]$SqlCommandTimeoutSeconds)
{
    # no need for a background job, query will run indefinitely and sync
    if ($SqlCommandTimeoutSeconds -eq 0) {
        Invoke-AlternativeSqlCmd_WithoutTimeout $SQLInstance $SQLDatabase $SQLQuery
        return
    }

    $code = { 
    
        #region Getting input params
        #because of:  https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-5.1#input
        #and https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator?view=netframework-4.8#remarks
        if ($input.MoveNext()) { $inputs = $input.Current } else { return }  
        #endregion  

        function Invoke-AlternativeSqlCmd_WithoutTimeout($SQLInstance, $SQLDatabase, $SQLQuery)
        {
            $SqlConnection = New-Object System.Data.SqlClient.SqlConnection
            $SqlConnection.ConnectionString = "Server=$SQLInstance; Database=$SQLDatabase; Trusted_Connection=True"
            $SqlConnection.Open() 

            $SqlAdp = New-Object System.Data.SqlClient.SqlDataAdapter
            $SqlCmd = New-Object System.Data.SqlClient.SqlCommand
            $SqlCmd.CommandText = $SQLQuery
            $SqlCmd.Connection = $SqlConnection
            $SqlCmd.CommandTimeout = 0 # do NOT change this!
            $SqlAdp.SelectCommand = $SqlCmd

                $global:SqlPrintMessages=""
                $handler = [System.Data.SqlClient.SqlInfoMessageEventHandler] {
                    param($sender, $event) 
                    $global:SqlPrintMessages += "`n" + $event.Message 
                };
                $SqlConnection.add_InfoMessage($handler); 
                $SqlConnection.FireInfoMessageEventOnUserErrors = $true;

            $DS = New-Object System.Data.DataSet
            $SqlAdp.Fill($DS) | out-null  # keep the out-null otherwise $DS will return as Object[]
            return $DS;
        }
     
        $SQLInstance, $SQLDatabase, $SQLQuery = $inputs  
        Invoke-AlternativeSqlCmd_WithoutTimeout -SQLInstance $SQLInstance -SQLDatabase $SQLDatabase -SQLQuery $SQLQuery
    }

    $jobParams = @($SQLInstance, $SQLDatabase, $SQLQuery)
    $job = Start-Job -ScriptBlock $code -InputObject $jobParams
    $PIDofNewJob = (Get-WmiObject win32_process -filter "Name='powershell.exe' AND ParentProcessId=$PID" -Property ProcessID,CreationDate | Sort-Object -Property CreationDate -Descending | Select-Object -First 1 -Property ProcessId).ProcessId

    $timeoutsecs = $SqlCommandTimeoutSeconds
    Wait-Job -Job $job -Timeout $timeoutsecs | Out-Null

    if ( $job.State -eq "Running"  ) {        
        Stop-Process -Id $PIDofNewJob  | Out-Null 
        Write-Host "Stopped PID: $PIDofNewJob because of timeout secs: $timeoutsecs for query: $SQLQuery"   
    } 
    if ($job.State -eq "Completed") { 
        Receive-Job -Job $job
    }
    Remove-Job -Job $job -Force | Out-Null
    #$global:SqlPrintMessages #todo
}
function AppendOutputToCsvFileInTargetFolder($dataTable, $fileName) {     
    $resultFilePath = Join-Path -Path $resultFolder -ChildPath $fileName
    if ($dataTable.Rows.Count -eq 0) 
    {
        $header = ""
        foreach ($col in $dataTable.Columns) {
            $header += $col.ColumnName +","
        }
        $header = $header.Remove($header.Length-1,1) 
        AppendOutputToFileInTargetFolder $header $fileName
    } 
    else 
    {
        #$dataTable | export-csv -Path $resultFilePath -Encoding UTF8 -Append -NoTypeInformation
        AppendOutputToFileInTargetFolder ($dataTable | ConvertTo-Csv -NoTypeInformation) $fileName
    }
}

function GetNewSB() {return [System.Text.StringBuilder]::new();}
function SB_Append($sb, $text) {[void]$sb.Append( $text )}
function SB_AppendLine($sb, $text) {[void]$sb.AppendLine( $text )}

#function IsAnyScsmRoleInstalled() {
 # $regItems = [object[]](GP HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*  | ?{$_.DisplayName -like "*Service Manager*"})
 # $regItems.Count -gt 0
#}


function IsThisAnyScsmMgmtServer() { #includes WF, Secondary and DW    
    return ((IsThisScsmMgmtServer) -or (IsThisScsmDwMgmtServer))
}
function IsThisScsmMgmtServer() {  #includes WF, Secondary
    $regSetupExists = Test-Path -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Service Manager\Setup' -ErrorAction SilentlyContinue
    $regMGExists = Test-Path -Path 'HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Server Management Groups' -ErrorAction SilentlyContinue
    $regSDKType = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\SDK Service' -ErrorAction SilentlyContinue)."SDK Service Type"

    return ($regSetupExists -and $regMGExists -and ($regSDKType -eq 1))
}
function IsThisScsmDwMgmtServer() {
    $regSetupExists = Test-Path -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Service Manager\Setup' -ErrorAction SilentlyContinue
    $regMGExists = Test-Path -Path 'HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Server Management Groups' -ErrorAction SilentlyContinue
    $regSDKType = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\SDK Service' -ErrorAction SilentlyContinue)."SDK Service Type"

    return ($regSetupExists -and $regMGExists -and ($regSDKType -eq 2))
}
function IsThisScsmWfMgmtServer() {
    $qry = @'
    select bme.Name, bme.DisplayName
    FROM dbo.[ScopedInstanceTargetClass] sitc
        inner join ManagedType mt on mt.ManagedTypeId = sitc.ManagedTypeId
        inner join BaseManagedEntity bme on bme.BaseManagedEntityId = sitc.ScopedInstanceId and bme.IsDeleted=0
    where mt.ManagedTypeId = dbo.fn_ManagedTypeId_MicrosoftSystemCenterWorkflowTarget()
'@
    $SQLInstance_SCSM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').DatabaseServerName
    $SQLDatabase_SCSM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').DatabaseName
    $ds = Try-Invoke-SqlCmd -SQLInstance $SQLInstance_SCSM -SQLDatabase $SQLDatabase_SCSM -Query $qry
    if ($ds.Tables.Count -eq 0) {
        Write-Host "Error in IsThisScsmWfMgmtServer(): $global:SqlPrintMessages"
    }
    $WfDisplayName = $ds.Tables[0].DisplayName
    return ( ($env:COMPUTERNAME -eq $WfDisplayName) -or ([System.Net.Dns]::GetHostEntry([string]$env:computername).HostName -eq $WfDisplayName) )
}
function IsThisScsmSecondaryMgmtServer() {
    return ((IsThisScsmMgmtServer) -and (-not (IsThisScsmWfMgmtServer)))
}
function IsScsmHtmlPortalInstalled() {
    $PortalVirtualDirectory = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Service Manager\Setup' -ErrorAction SilentlyContinue).PortalVirtualDirectory
    return ($PortalVirtualDirectory -ne $null)
}
function IsScsmConsoleInstalled() {
# todo
    $PortalVirtualDirectory = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Service Manager\Setup' -ErrorAction SilentlyContinue).PortalVirtualDirectory
    return ($PortalVirtualDirectory -ne $null)
}

function IsThisHostingServiceManagerDB() {

$SQLInstance_SCSM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').DatabaseServerName
$SQLDatabase_SCSM = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\System Center\2010\Common\Database').DatabaseName
}
function IsThisHostingDwStagingAndDwRepDB() {

}
function IsThisHostingDwDataMartDB() {

}
function GetScsmDWSsrsServer() {
    $class= get-scclass -Name Microsoft.SystemCenter.ResourceAccessLayer.SrsResourceStore # -ComputerName <DWServerName>  
    $SrsServer= get-scclassinstance -class $class #-ComputerName <DWServerName>  
    $SrsServer.Server #  DataService  ????
}
function GetScsmDWSsasServer() {
    $class= get-scclass -Name Microsoft.SystemCenter.ResourceAccessLayer.ASResourceStore # -ComputerName <DWServerName>  
    $OLAPServer= get-scclassinstance -class $class #-ComputerName <DWServerName>  
    $OLAPServer.Server    
}
function GetMachineNameFromSqlInstance($SqlInstanceName) {
    $tmp = $SqlInstanceName.Split("\\")[0]
    $tmp.Split(",")[0]
}
function GetPortFromSqlInstance($SqlInstanceName) {
	$port = $SqlInstanceName.Split(",")[1]
	if ($port -eq $null) { 
	        1433 
	}
	else { 
	    [int]($port.trim()) 
	}
	
}
function GetNamedInstanceNameFromSqlInstance($SqlInstanceName) {
    $tmp = $SqlInstanceName.Split("\\")[1]
    if ($tmp -eq $null) {
        $namedInstanceName=""
    }
    else {
        $namedInstanceName=$tmp.Split(",")[0]
    }
    $namedInstanceName
}
function Get-UserFriendlyTimeSpane ($Duration) {
    $Day = switch ($Duration.Days) {
        0 { $null; break }       
        Default {"{0}d." -f $Duration.Days}
    }

    $Hour = switch ($Duration.Hours) {
        0 { $null; break }       
        Default { "{0}h:" -f $Duration.Hours }
    }

    $Minute = switch ($Duration.Minutes) {
        0 { $null; break }       
        Default { "{0}m" -f $Duration.Minutes }
    }

    $Second = switch ($Duration.Seconds) {
        0 { $null; break }        
        Default { ":{0}s" -f $Duration.Seconds }
    }

    "$Day$Hour$Minute$Second"
}
function MakeNewZipFile($source,$archive) { #https://stackoverflow.com/questions/40692024/zip-and-unzip-file-in-powershell-4
    Add-Type -assembly "system.io.compression.filesystem"
    [io.compression.zipfile]::CreateFromDirectory($source, $archive)
}
function GetSqlErrorLogFiles ($SQLInstance, $SQLDatabase){
    CreateNewFolderInTargetFolder "ERRORLOG"   

    $errorlogLocalfilename=(Try-Invoke-SqlCmd -SQLInstance $SQLInstance -SQLDatabase $SQLDatabase -Query "select cast(SERVERPROPERTY(N'errorlogfilename') as nvarchar(512)) as errorlogfilename").Tables[0].errorlogfilename
    AppendOutputToFileInTargetFolder "errorlogLocalfilename: $errorlogLocalfilename `n" 'ERRORLOG\Notes.txt' 
    $DriveOfErrorlogfilename = $errorlogLocalfilename.substring(0,1)
    $RestOfErrorlogfilename = $errorlogLocalfilename.substring(2)        
    $errorlogRemotefilename="\\$(GetMachineNameFromSqlInstance $SQLInstance)\$DriveOfErrorlogfilename$\$RestOfErrorlogfilename"

    [long]$SizeOfRecentSqlErrorlogFile= (Get-Item  -Path $errorlogRemotefilename   -ErrorAction SilentlyContinue | select Length | measure -Sum -Property Length -ErrorAction SilentlyContinue).Sum 
    [long]$TotalSizeOfSqlErrorlogFiles= (Get-Item -Path "$errorlogRemotefilename*" -ErrorAction SilentlyContinue | select Length | measure -Sum -Property Length -ErrorAction SilentlyContinue).Sum 

    if ($SizeOfRecentSqlErrorlogFile -gt 0) {
        if ($TotalSizeOfSqlErrorlogFiles -le 200MB ) {
            Get-Item -Path "$errorlogRemotefilename*" | % { CopyFileToTargetFolder ($_.Fullname) "ERRORLOG" }
            AppendOutputToFileInTargetFolder "All ERRORLOG file(s) copied." 'ERRORLOG\Notes.txt'            
        }
        elseif ($SizeOfRecentSqlErrorlogFile -le 100MB){
            CopyFileToTargetFolder $errorlogRemotefilename "ERRORLOG"
            AppendOutputToFileInTargetFolder "Only recent ERRORLOG file copied. TotalSizeOfSqlErrorlogFiles:$TotalSizeOfSqlErrorlogFiles" 'ERRORLOG\Notes.txt'            
        }
        else {
            AppendOutputToFileInTargetFolder "ERRORLOG file(s) too big: SizeOfRecentSqlErrorlogFile:$SizeOfRecentSqlErrorlogFile   TotalSizeOfSqlErrorlogFiles:$TotalSizeOfSqlErrorlogFiles" 'ERRORLOG\Notes.txt'            
        }
    }
    else {
        AppendOutputToFileInTargetFolder "Error while accessing remote SQL ERRORLOG file(s): errorlogLocalfilename:$errorlogLocalfilename `n $_" 'ERRORLOG\Notes.txt'
        AppendOutputToFileInTargetFolder "Now trying to read SQL ERRORLOG entries via xp_readerrorlog" 'ERRORLOG\Notes.txt'
        try {
            SaveSQLResultSetsToFiles $SQLInstance $SQLDatabase "xp_readerrorlog" "ERRORLOG_via_xp_readerrorlog.txt" -SqlCommandTimeoutSeconds 4
            MoveFileInTargetFolder 'ERRORLOG_via_xp_readerrorlog.txt' "ERRORLOG"
        }
        catch {
            AppendOutputToFileInTargetFolder "Error while accessing SQL ERRORLOG entries via xp_readerrorlog `n $_" 'ERRORLOG\Notes.txt'
        } 
    }
}
function GetEmailSendingRules() {
    $rules = @()
    $wkfs = Get-SCSMWorkflow  | where {  ($_.EnableNotification -and $_.Notification) -or 
                                        ($_.WorkflowSubscription -is [Microsoft.EnterpriseManagement.Subscriptions.NotificationSubscription]) 
                                      } 
    foreach($wkf in $wkfs)
    {   
        if ($wkf.WorkflowSubscription.SubscriptionType -is [Microsoft.EnterpriseManagement.Subscriptions.RelationshipTypeSubscription])
        {       
            $class = Get-SCSMRelationship -Id $wkf.WorkflowSubscription.SubscriptionType.SourceTypeId
            $classDisplayName = $class.DisplayName 

            $sourceType = Get-SCSMClass -id $class.Source.Type.Id 
            $targetType = Get-SCSMClass -id $class.Target.Type.Id 
            $classDisplayName += " (" + $sourceType.DisplayName + " -> " + $targetType.DisplayName + ")"
        }  
        elseif ($wkf.WorkflowSubscription.SubscriptionType -is [Microsoft.EnterpriseManagement.Subscriptions.InstanceTypeSubscription])
        {   
            $class = Get-SCSMClass -id $wkf.WorkflowSubscription.SubscriptionType.TypeId
            $classDisplayName = $class.DisplayName    
        }
        else
        {
            $exc = "unexpected SubscriptionType!!!"
            $exc
            continue
        } 

        $peopleToNotify = ""
        $templateAndRecipients = ""
        $templates = ""
	    $recipients = ""

        if ($wkf.WorkflowSubscription -is [Microsoft.EnterpriseManagement.Subscriptions.WorkflowSubscription])
        {  
		    $templates = $wkf.Notification | % { $_.Template.DisplayName + "; " } 
		    $templates = "$templates"
		
            $recipients = $wkf.Notification | % { $_.User + "; " } 	
		    $recipients = "$recipients"		
        }
        elseif ($wkf.WorkflowSubscription -is [Microsoft.EnterpriseManagement.Subscriptions.NotificationSubscription])
        {
		    $templates = $wkf.WorkflowSubscription.TemplateIds | % { Get-SCSMObjectTemplate -Id $_.Guid } | % { $_.DisplayName }
		
		    $recipients = $wkf.WorkflowSubscription.Recipients | % { Get-SCSMObject -Id $_.Recipient} | % { $_.DisplayName + "; " }
		    $recipients = "$recipients"	
            $recipients += [system.String]::Join("; ", $wkf.WorkflowSubscription.RelatedRecipients)				
        }
        else
        {
            $exc = "unexpected Workflow Subscription Type "
            $exc
            continue
        }

        $rule = New-Object System.Object
        $rule | Add-Member -type NoteProperty -Name "The Rule" -Value $wkf.DisplayName
        $rule | Add-Member -type NoteProperty -Name "in Management Pack" -Value $wkf.ManagementPack.DisplayName    
        $rule | Add-Member -type NoteProperty -Name "is" -Value @{$true="Enabled";$false="Disabled"}[$wkf.Enabled]
        $rule | Add-Member -type NoteProperty -Name "Runs when each" -Value $classDisplayName
    
        $subscriptionType = switch ($wkf.WorkflowSubscription.SubscriptionType.GetType().Name)
        {
            InstanceTypeSubscription {"is"}
            RelationshipTypeSubscription {"Relationship"}
            default {"unknown??? :" + $wkf.WorkflowSubscription.SubscriptionType.GetType().Name}
        }
        $rule | Add-Member -type NoteProperty -Name "(Type)" -Value $subscriptionType    
        $editableInConsole = -Not ($subscriptionType -eq "Relationship")    
    
        $operation = switch ($wkf.WorkflowSubscription.SubscriptionType.Operation)
        {
            Add {"created"}
            Update {"updated"}
            PeriodicQuery {"periodically checked"}
            default {"unknown!!!"}
        }
        $rule | Add-Member -type NoteProperty -Name "is:" -Value $operation     
     
        $rule | Add-Member -type NoteProperty -Name "It is of type" -Value  @{$true="Workflow";$false="Notification"}[$wkf.WorkflowSubscription.GetType().Name -eq "WorkflowSubscription"] 
        $rule | Add-Member -type NoteProperty -Name "and can be edited" -Value @{$true="in Console";$false="only in MP xml"}[ $editableInConsole]

        $hasCriteria = ($wkf.Criteria.length -gt 0)
        $rule | Add-Member -type NoteProperty -Name "and has any criteria?" -Value @{$true="Yes";$false="No"}[$hasCriteria]

        $rule | Add-Member -type NoteProperty -Name "Templates" -Value $templates
	    $rule | Add-Member -type NoteProperty -Name "Recipients" -Value $recipients
        $rule | Add-Member -type NoteProperty -Name "Time Added" -Value $wkf.WorkflowSubscription.TimeAdded
        $rule | Add-Member -type NoteProperty -Name "Last Modified" -Value $wkf.WorkflowSubscription.LastModified
        $rule | Add-Member -type NoteProperty -Name "Description" -Value $wkf.Description
        $rule | Add-Member -type NoteProperty -Name "Criteria" -Value $wkf.Criteria
    
        $rules += $rule  
    }
    $rules
}
#region Zipping in PS 2.0
#credits: https://gist.github.com/deadlydog/4d3d98ca10c5c6b62e29f7e793850305

# Recursive function to calculate the total number of files and directories in the Zip file.
function GetNumberOfItemsInZipFileItems($shellItems)
{
	[int]$totalItems = $shellItems.Count
	foreach ($shellItem in $shellItems)
	{
		if ($shellItem.IsFolder)
		{ $totalItems += GetNumberOfItemsInZipFileItems -shellItems $shellItem.GetFolder.Items() }
	}
	$totalItems
}

# Recursive function to move a directory into a Zip file, since we can move files out of a Zip file, but not directories, and copying a directory into a Zip file when it already exists is not allowed.
function MoveDirectoryIntoZipFile($parentInZipFileShell, $pathOfItemToCopy)
{
	# Get the name of the file/directory to copy, and the item itself.
	$nameOfItemToCopy = Split-Path -Path $pathOfItemToCopy -Leaf
	if ($parentInZipFileShell.IsFolder)
	{ $parentInZipFileShell = $parentInZipFileShell.GetFolder }
	$itemToCopyShell = $parentInZipFileShell.ParseName($nameOfItemToCopy)
	
	# If this item does not exist in the Zip file yet, or it is a file, move it over.
	if ($itemToCopyShell -eq $null -or !$itemToCopyShell.IsFolder)
	{
		$parentInZipFileShell.MoveHere($pathOfItemToCopy)
		
		# Wait for the file to be moved before continuing, to avoid erros about the zip file being locked or a file not being found.
		while (Test-Path -Path $pathOfItemToCopy)
		{ Start-Sleep -Milliseconds 10 }
	}
	# Else this is a directory that already exists in the Zip file, so we need to traverse it and copy each file/directory within it.
	else
	{
		# Copy each file/directory in the directory to the Zip file.
		foreach ($item in (Get-ChildItem -Path $pathOfItemToCopy -Force))
		{
			MoveDirectoryIntoZipFile -parentInZipFileShell $itemToCopyShell -pathOfItemToCopy $item.FullName
		}
	}
}

# Recursive function to move all of the files that start with the File Name Prefix to the Directory To Move Files To.
function MoveFilesOutOfZipFileItems($shellItems, $directoryToMoveFilesToShell, $fileNamePrefix)
{
	# Loop through every item in the file/directory.
	foreach ($shellItem in $shellItems)
	{
		# If this is a directory, recursively call this function to iterate over all files/directories within it.
		if ($shellItem.IsFolder)
		{ 
			$totalItems += MoveFilesOutOfZipFileItems -shellItems $shellItem.GetFolder.Items() -directoryToMoveFilesTo $directoryToMoveFilesToShell -fileNameToMatch $fileNameToMatch
		}
		# Else this is a file.
		else
		{
			# If this file name starts with the File Name Prefix, move it to the specified directory.
			if ($shellItem.Name.StartsWith($fileNamePrefix))
			{
				$directoryToMoveFilesToShell.MoveHere($shellItem)
			}
		}			
	}
}

function Expand-ZipFile
{
	[CmdletBinding()]
	param
	(
		[parameter(Position=1,Mandatory=$true)]
		[ValidateScript({(Test-Path -Path $_ -PathType Leaf) -and $_.EndsWith('.zip', [StringComparison]::OrdinalIgnoreCase)})]
		[string]$ZipFilePath, 
		
		[parameter(Position=2,Mandatory=$false)]
		[string]$DestinationDirectoryPath, 
		
		[Alias("Force")]
		[switch]$OverwriteWithoutPrompting
	)
	
	BEGIN { }
	END { }
	PROCESS
	{	
		# If a Destination Directory was not given, create one in the same directory as the Zip file, with the same name as the Zip file.
		if ($DestinationDirectoryPath -eq $null -or $DestinationDirectoryPath.Trim() -eq [string]::Empty)
		{
			$zipFileDirectoryPath = Split-Path -Path $ZipFilePath -Parent
			$zipFileNameWithoutExtension = [System.IO.Path]::GetFileNameWithoutExtension($ZipFilePath)
			$DestinationDirectoryPath = Join-Path -Path $zipFileDirectoryPath -ChildPath $zipFileNameWithoutExtension
		}
		
		# If the directory to unzip the files to does not exist yet, create it.
		if (!(Test-Path -Path $DestinationDirectoryPath -PathType Container)) 
		{ New-Item -Path $DestinationDirectoryPath -ItemType Container > $null }

		# Flags and values found at: https://msdn.microsoft.com/en-us/library/windows/desktop/bb759795%28v=vs.85%29.aspx
		$FOF_SILENT = 0x0004
		$FOF_NOCONFIRMATION = 0x0010
		$FOF_NOERRORUI = 0x0400

		# Set the flag values based on the parameters provided.
		$copyFlags = 0
		if ($OverwriteWithoutPrompting)
		{ $copyFlags = $FOF_NOCONFIRMATION }
	#	{ $copyFlags = $FOF_SILENT + $FOF_NOCONFIRMATION + $FOF_NOERRORUI }

		# Get the Shell object, Destination Directory, and Zip file.
	    $shell = New-Object -ComObject Shell.Application
		$destinationDirectoryShell = $shell.NameSpace($DestinationDirectoryPath)
	    $zipShell = $shell.NameSpace($ZipFilePath)
		
		# Start copying the Zip files into the destination directory, using the flags specified by the user. This is an asynchronous operation.
	    $destinationDirectoryShell.CopyHere($zipShell.Items(), $copyFlags)

		# Get the number of files and directories in the Zip file.
		$numberOfItemsInZipFile = GetNumberOfItemsInZipFileItems -shellItems $zipShell.Items()
		
		# The Copy (i.e. unzip) operation is asynchronous, so wait until it is complete before continuing. That is, sleep until the Destination Directory has the same number of files as the Zip file.
		while ((Get-ChildItem -Path $DestinationDirectoryPath -Recurse -Force).Count -lt $numberOfItemsInZipFile)
		{ Start-Sleep -Milliseconds 100 }
	}
}

function Compress-ZipFile
{
	[CmdletBinding()]
	param
	(
		[parameter(Position=1,Mandatory=$true)]
		[ValidateScript({Test-Path -Path $_})]
		[string]$FileOrDirectoryPathToAddToZipFile, 
	
		[parameter(Position=2,Mandatory=$false)]
		[string]$ZipFilePath,
		
		[Alias("Force")]
		[switch]$OverwriteWithoutPrompting
	)
	
	BEGIN { }
	END { }
	PROCESS
	{
		# If a Zip File Path was not given, create one in the same directory as the file/directory being added to the zip file, with the same name as the file/directory.
		if ($ZipFilePath -eq $null -or $ZipFilePath.Trim() -eq [string]::Empty)
		{ $ZipFilePath = Join-Path -Path $FileOrDirectoryPathToAddToZipFile -ChildPath '.zip' }
		
		# If the Zip file to create does not have an extension of .zip (which is required by the shell.application), add it.
		if (!$ZipFilePath.EndsWith('.zip', [StringComparison]::OrdinalIgnoreCase))
		{ $ZipFilePath += '.zip' }
		
		# If the Zip file to add the file to does not exist yet, create it.
		if (!(Test-Path -Path $ZipFilePath -PathType Leaf))
		{ New-Item -Path $ZipFilePath -ItemType File > $null }

		# Get the Name of the file or directory to add to the Zip file.
		$fileOrDirectoryNameToAddToZipFile = Split-Path -Path $FileOrDirectoryPathToAddToZipFile -Leaf

		# Get the number of files and directories to add to the Zip file.
		$numberOfFilesAndDirectoriesToAddToZipFile = (Get-ChildItem -Path $FileOrDirectoryPathToAddToZipFile -Recurse -Force).Count
		
		# Get if we are adding a file or directory to the Zip file.
		$itemToAddToZipIsAFile = Test-Path -Path $FileOrDirectoryPathToAddToZipFile -PathType Leaf

		# Get Shell object and the Zip File.
		$shell = New-Object -ComObject Shell.Application
		$zipShell = $shell.NameSpace($ZipFilePath)

		# We will want to check if we can do a simple copy operation into the Zip file or not. Assume that we can't to start with.
		# We can if the file/directory does not exist in the Zip file already, or it is a file and the user wants to be prompted on conflicts.
		$canPerformSimpleCopyIntoZipFile = $false

		# If the file/directory does not already exist in the Zip file, or it does exist, but it is a file and the user wants to be prompted on conflicts, then we can perform a simple copy into the Zip file.
		$fileOrDirectoryInZipFileShell = $zipShell.ParseName($fileOrDirectoryNameToAddToZipFile)
		$itemToAddToZipIsAFileAndUserWantsToBePromptedOnConflicts = ($itemToAddToZipIsAFile -and !$OverwriteWithoutPrompting)
		if ($fileOrDirectoryInZipFileShell -eq $null -or $itemToAddToZipIsAFileAndUserWantsToBePromptedOnConflicts)
		{
			$canPerformSimpleCopyIntoZipFile = $true
		}
		
		# If we can perform a simple copy operation to get the file/directory into the Zip file.
		if ($canPerformSimpleCopyIntoZipFile)
		{
			# Start copying the file/directory into the Zip file since there won't be any conflicts. This is an asynchronous operation.
			$zipShell.CopyHere($FileOrDirectoryPathToAddToZipFile)	# Copy Flags are ignored when copying files into a zip file, so can't use them like we did with the Expand-ZipFile function.
			
			# The Copy operation is asynchronous, so wait until it is complete before continuing.
			# Wait until we can see that the file/directory has been created.
			while ($zipShell.ParseName($fileOrDirectoryNameToAddToZipFile) -eq $null)
			{ Start-Sleep -Milliseconds 100 }
			
			# If we are copying a directory into the Zip file, we want to wait until all of the files/directories have been copied.
			if (!$itemToAddToZipIsAFile)
			{
				# Get the number of files and directories that should be copied into the Zip file.
				$numberOfItemsToCopyIntoZipFile = (Get-ChildItem -Path $FileOrDirectoryPathToAddToZipFile -Recurse -Force).Count
			
				# Get a handle to the new directory we created in the Zip file.
				$newDirectoryInZipFileShell = $zipShell.ParseName($fileOrDirectoryNameToAddToZipFile)
				
				# Wait until the new directory in the Zip file has the expected number of files and directories in it.
				while ((GetNumberOfItemsInZipFileItems -shellItems $newDirectoryInZipFileShell.GetFolder.Items()) -lt $numberOfItemsToCopyIntoZipFile)
				{ Start-Sleep -Milliseconds 100 }
			}
		}
		# Else we cannot do a simple copy operation. We instead need to move the files out of the Zip file so that we can merge the directory, or overwrite the file without the user being prompted.
		# We cannot move a directory into the Zip file if a directory with the same name already exists, as a MessageBox warning is thrown, not a conflict resolution prompt like with files.
		# We cannot silently overwrite an existing file in the Zip file, as the flags passed to the CopyHere/MoveHere functions seem to be ignored when copying into a Zip file.
		else
		{
			# Create a temp directory to hold our file/directory.
			$tempDirectoryPath = $null
			$tempDirectoryPath = Join-Path -Path ([System.IO.Path]::GetTempPath()) -ChildPath ([System.IO.Path]::GetRandomFileName())
			New-Item -Path $tempDirectoryPath -ItemType Container > $null
		
			# If we will be moving a directory into the temp directory.
			$numberOfItemsInZipFilesDirectory = 0
			if ($fileOrDirectoryInZipFileShell.IsFolder)
			{
				# Get the number of files and directories in the Zip file's directory.
				$numberOfItemsInZipFilesDirectory = GetNumberOfItemsInZipFileItems -shellItems $fileOrDirectoryInZipFileShell.GetFolder.Items()
			}
		
			# Start moving the file/directory out of the Zip file and into a temp directory. This is an asynchronous operation.
			$tempDirectoryShell = $shell.NameSpace($tempDirectoryPath)
			$tempDirectoryShell.MoveHere($fileOrDirectoryInZipFileShell)
			
			# If we are moving a directory, we need to wait until all of the files and directories in that Zip file's directory have been moved.
			$fileOrDirectoryPathInTempDirectory = Join-Path -Path $tempDirectoryPath -ChildPath $fileOrDirectoryNameToAddToZipFile
			if ($fileOrDirectoryInZipFileShell.IsFolder)
			{
				# The Move operation is asynchronous, so wait until it is complete before continuing. That is, sleep until the Destination Directory has the same number of files as the directory in the Zip file.
				while ((Get-ChildItem -Path $fileOrDirectoryPathInTempDirectory -Recurse -Force).Count -lt $numberOfItemsInZipFilesDirectory)
				{ Start-Sleep -Milliseconds 100 }
			}
			# Else we are just moving a file, so we just need to check for when that one file has been moved.
			else
			{
				# The Move operation is asynchronous, so wait until it is complete before continuing.
				while (!(Test-Path -Path $fileOrDirectoryPathInTempDirectory))
				{ Start-Sleep -Milliseconds 100 }
			}
			
			# We want to copy the file/directory to add to the Zip file to the same location in the temp directory, so that files/directories are merged.
			# If we should automatically overwrite files, do it.
			if ($OverwriteWithoutPrompting)
			{ Copy-Item -Path $FileOrDirectoryPathToAddToZipFile -Destination $tempDirectoryPath -Recurse -Force }
			# Else the user should be prompted on each conflict.
			else
			{ Copy-Item -Path $FileOrDirectoryPathToAddToZipFile -Destination $tempDirectoryPath -Recurse -Confirm -ErrorAction SilentlyContinue }	# SilentlyContinue errors to avoid an error for every directory copied.

			# For whatever reason the zip.MoveHere() function is not able to move empty directories into the Zip file, so we have to put dummy files into these directories 
			# and then remove the dummy files from the Zip file after.
			# If we are copying a directory into the Zip file.
			$dummyFileNamePrefix = 'Dummy.File'
			[int]$numberOfDummyFilesCreated = 0
			if ($fileOrDirectoryInZipFileShell.IsFolder)
			{
				# Place a dummy file in each of the empty directories so that it gets copied into the Zip file without an error.
				$emptyDirectories = Get-ChildItem -Path $fileOrDirectoryPathInTempDirectory -Recurse -Force -Directory | Where-Object { (Get-ChildItem -Path $_ -Force) -eq $null }
				foreach ($emptyDirectory in $emptyDirectories)
				{
					$numberOfDummyFilesCreated++
					New-Item -Path (Join-Path -Path $emptyDirectory.FullName -ChildPath "$dummyFileNamePrefix$numberOfDummyFilesCreated") -ItemType File -Force > $null
				}
			}		

			# If we need to copy a directory back into the Zip file.
			if ($fileOrDirectoryInZipFileShell.IsFolder)
			{
				MoveDirectoryIntoZipFile -parentInZipFileShell $zipShell -pathOfItemToCopy $fileOrDirectoryPathInTempDirectory
			}
			# Else we need to copy a file back into the Zip file.
			else
			{
				# Start moving the merged file back into the Zip file. This is an asynchronous operation.
				$zipShell.MoveHere($fileOrDirectoryPathInTempDirectory)
			}
			
			# The Move operation is asynchronous, so wait until it is complete before continuing.
			# Sleep until all of the files have been moved into the zip file. The MoveHere() function leaves empty directories behind, so we only need to watch for files.
			do
			{
				Start-Sleep -Milliseconds 100
				$files = Get-ChildItem -Path $fileOrDirectoryPathInTempDirectory -Force -Recurse | Where-Object { !$_.PSIsContainer }
			} while ($files -ne $null)
			
			# If there are dummy files that need to be moved out of the Zip file.
			if ($numberOfDummyFilesCreated -gt 0)
			{
				# Move all of the dummy files out of the supposed-to-be empty directories in the Zip file.
				MoveFilesOutOfZipFileItems -shellItems $zipShell.items() -directoryToMoveFilesToShell $tempDirectoryShell -fileNamePrefix $dummyFileNamePrefix
				
				# The Move operation is asynchronous, so wait until it is complete before continuing.
				# Sleep until all of the dummy files have been moved out of the zip file.
				do
				{
					Start-Sleep -Milliseconds 100
					[Object[]]$files = Get-ChildItem -Path $tempDirectoryPath -Force -Recurse | Where-Object { !$_.PSIsContainer -and $_.Name.StartsWith($dummyFileNamePrefix) }
				} while ($files -eq $null -or $files.Count -lt $numberOfDummyFilesCreated)
			}
			
			# Delete the temp directory that we created.
			Remove-Item -Path $tempDirectoryPath -Force -Recurse > $null
		}
	}
}
#endregion 
function Show-AllSelectedNone($allSelected, $collection, $separator, $allWording, $noneWording) {
if (-not $separator) { $separator = [char]10 }
if (-not $allWording) { $allWording = "(all)" }
if (-not $noneWording) { $noneWording = "(none)" }

    $result = ""
    if ($allSelected -eq $true) { 
        $result = $allWording 
    } 
    else {
        if (-not $collection) {
            $result = $noneWording
         } 
         #else {
         #   $result = ""
         #}

        ForEach ($item in $collection)
        {            
            $result +=  $separator + "$($item.DisplayName)"
        }        
    }
    
    if ($result.StartsWith($separator)) { $result = $result.Substring($separator.Length) }

    $result
}
function ConvertTo-Scriptblock { # https://www.thomasmaurer.ch/2011/11/powershell-convert-string-to-scriptblock/
Param(
[Parameter(
    Mandatory = $true,
    ParameterSetName = '',
    ValueFromPipeline = $true)]
    [string]$string
)
    $scriptBlock = [scriptblock]::Create($string)
    return $scriptBlock
}
function InvokeCommandFromString ($scriptAsString, $computerName) {
    $scriptBlock = ConvertTo-Scriptblock $scriptAsString
    InvokeCommand $scriptBlock $computerName 
} 
function InvokeCommand ($scriptBlock, $computerName) {    
    if (-not $computerName -or $computerName -eq "localhost" -or $computerName -eq "127.0.0.1" -or $computerName -eq "$Env:COMPUTERNAME" -or $computerName -eq "$Env:COMPUTERNAME.$Env:USERDNSDOMAIN" `
    -or ((Get-NetIPAddress -AddressFamily IPv4 | Select-Object IPAddress) | ? { $_.IPAddress -eq $computerName }).IPAddress.Count -gt 0
    
     ) {
         Invoke-Command -ScriptBlock $scriptBlock 2>&1   # Caller should check if   -isnot [System.Management.Automation.ErrorRecord] 
    }
    else {
        Invoke-Command -ComputerName $computerName -ScriptBlock $scriptBlock 2>&1  # Caller should check if   -isnot [System.Management.Automation.ErrorRecord]
    }
}
function Run2ndOnlyIf1stSucceeds([scriptblock]$scriptBlock1, [scriptblock]$scriptBlock2) {

    $resultOf1 = Invoke-Command -ScriptBlock $scriptBlock1

    if ($resultOf1 -is [System.Management.Automation.ErrorRecord])  {
        $resultOf1
    }
    else { #Very IMPORTANT: $scriptBlock2  should "contain" exactly the variable   "$resultOf1"    if the "result" of $scriptBlock1  will be used inside.
        Invoke-Command -ScriptBlock $scriptBlock2 -ArgumentList $resultOf1
    }
}
function Abs($value) {
    $result = $null
    if ([double]::TryParse($value, [System.Globalization.NumberStyles]::Any, $null, [ref] $result)) {    
        [Math]::Abs($value)
    }
    else {
        $value
    }   
}
function WithThousandSeparators($numValue) {
    "{0:#,##0.##########}" -f $numValue
}
 #endregion

function Check_TimeDiffWithDC() {

    $timeDiffInSecs = [int]::MaxValue
    $fileContainsError = $true

    [string]$tmp = GetFileContentInSourceFolder TimeDiff_BtwDC_viaWin32tm.txt
    $fileContainsError = $tmp.contains(': 0x')
    if (-not $fileContainsError) {
        $posOfTimeDiff = $tmp.IndexOf(', -'); 
        if ($posOfTimeDiff -eq -1) { $posOfTimeDiff = $tmp.IndexOf(', +') }

        if ($posOfTimeDiff -eq -1) { $fileContainsError = $true }
        else {
            $posOfTimeDiff2 = $tmp.IndexOf('.',$posOfTimeDiff+2)
            if ($posOfTimeDiff2 -eq -1) { $fileContainsError = $true }
            else {
                $timeDiffInSecs_Str = $tmp.Substring( $posOfTimeDiff+2, $posOfTimeDiff2 - ($posOfTimeDiff+2) )
                
                if ( [int]::TryParse($timeDiffInSecs_Str, [ref] $timeDiffInSecs) ) {
                    $fileContainsError = $false
                    [int]$timeDiffInSecs = [System.Math]::Abs($timeDiffInSecs)
                }
                else {                    
                    $timeDiffInSecs = [int]::MaxValue
                }
            }
        }
    }

    if ($fileContainsError) {
        $tmp = GetFirstLineThatStartsWith (GetFileContentInSourceFolder TimeDiff_BtwDC.txt) "TotalSeconds"  
        if ( $tmp -eq $null ) {
            $timeDiffInSecs = [int]::MaxValue                    
        }
        else {
            $sourceNumberFormat = (GetFileContentInSourceFolder CurrentCulture.NumberFormat.csv) | ConvertFrom-Csv
            $posOfTimeDiff = $tmp.IndexOf(':')
            if ($posOfTimeDiff -eq -1) { $fileContainsError = $true }
            else {
                $posOfTimeDiff2 = $tmp.IndexOf( $sourceNumberFormat.NumberDecimalSeparator ,$posOfTimeDiff+1 )
                if ($posOfTimeDiff2 -eq -1) { $fileContainsError = $true }
                else {
                    $timeDiffInSecs_Str = $tmp.Substring( $posOfTimeDiff+1, $posOfTimeDiff2 - ($posOfTimeDiff+1) )
                
                    if ( [int]::TryParse($timeDiffInSecs_Str, [ref] $timeDiffInSecs) ) {
                        $fileContainsError = $false
                        [int]$timeDiffInSecs = [System.Math]::Abs($timeDiffInSecs)
                    }
                    else {
                        $timeDiffInSecs = [int]::MaxValue
                    }
                }
            }            
        }
    }

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="Time diff with DC"
    $dataRow.RuleDesc="The time diff between the machine and the DC should be less than 5 minutes (<= 300 secs). $(GetAnchorForExternal 'https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/maximum-tolerance-for-computer-clock-synchronization#best-practices' 'Best Practice') "
    $dataRow.RuleResult="Actual: "
    if (IsSourceScsmMgmtServer) { $dataRow.SAPCategories = "s*\other"}
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories = "dw\other"} 
    
    $dataRow.ProblemSeverity=[ProblemSeverity]::Warning

    if ($fileContainsError) {
        $dataRow.RuleResult = "Time diff between DC couldn't be measured in one of these file: $(CollectorLink TimeDiff_BtwDC.txt), $(CollectorLink TimeDiff_BtwDC_viaWin32tm.txt). <br/>$(IgnoreRuleIfText) no symptoms are happening that seem to be caused by Kerberos issues."
        $Result_Problems += $dataRow
    }
    elseif ($timeDiffInSecs -le 300) { 
        $dataRow.RuleResult += "$timeDiffInSecs seconds."
        $Result_OKs += $dataRow 
    }
    else {        
        $dataRow.RuleResult += "$timeDiffInSecs seconds! Time diff between DC is greater than 5 minutes! (Measured in these files: $(CollectorLink TimeDiff_BtwDC.txt), $(CollectorLink TimeDiff_BtwDC_viaWin32tm.txt)). <br/>$(IgnoreRuleIfText) no symptoms are happening that seem to be caused by Kerberos issues."
        $Result_Problems += $dataRow
    }
}


function Analyze_ForALL() {

#Rules for ALL roles including Console and Portal

    Check_TimeDiffWithDC

}

function Analyze_ForConsole() {
#region DO NOT REMOVE THIS! Exit immediately if Console is not installed.
if (-not (HasSourceScsmConsoleInstalled)) {
    return
}
#endregion

 #Rules for SCSM Console only 


#NotImplemented yet


}

function Check_CubeJobsStatusAndSchedule() {
#check Cube Jobs Count, Status and Schedules. 
$GetSCDWJob = ConvertFrom-Csv (GetFileContentInSourceFolder Get-SCDWJob.csv)
$CubeJobs = $GetSCDWJob | ? { $_.CategoryName -eq "CubeProcessing" }

$GetSCDWJobSchedule = ConvertFrom-Csv (GetFileContentInSourceFolder Get-SCDWJobSchedule.csv)
$cubeJobsSchedules = $GetSCDWJobSchedule | ? { $_.CategoryName -eq "CubeProcessing" }

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="DW Cube Jobs Status and Schedule"
    $dataRow.RuleDesc="Cube MPs can be removed if Cubes do not want to be used. If so, no Cube jobs will exist. Otherwise, there must be at least 6 cube jobs. All of them must be Running or Not Started."
    $dataRow.SAPCategories= "*cube*"

    if ($CubeJobs.Count -eq 0) { 
        $dataRow.RuleResult="No cube jobs exist. $(IgnoreRuleIfText) cube MPs were intentionally removed from SM side. Otherwise, this looks like a cube deployment problem. Check in the files below:<pre>
$(CollectorLink Get-SCDWJob.txt Get-SCDWJob)
$(CollectorLink Get-SCDWJob_NumberOfBatches_5.txt 'Get-SCDWJob -NumberOfBatches 5')
$(CollectorLink Get-SCDWJobSchedule.txt Get-SCDWJobSchedule)
$(CollectorLink SQL_DeploySequenceView.csv DeploySequenceView)
$(CollectorLink SQL_DeploySequenceStaging.csv DeploySequenceStaging)
$(CollectorLink SQL_DeployItemStaging.csv DeployItemStaging)
$(CollectorLink SQL_InfraBatch.csv infra.Batch)
$(CollectorLink SQL_InfraWorkItem.csv infra.WorkItem)
$(CollectorLink SQL_LockDetails.csv LockDetails)
$(CollectorLink OperationsManager.evtx 'OperationsManager event log')</pre>
"
        $dataRow.ProblemSeverity=[ProblemSeverity]::Warning 
        $Result_Problems += $dataRow
    }
    elseif ($CubeJobs.Count -lt 6) { 
        $dataRow.RuleResult="Cube jobs count is between 1 and 5. $(IgnoreRuleIfText) cube deployments are still in progress. Otherwise, this looks like a cube deployment problem. Check in the files below:<pre>
$(CollectorLink Get-SCDWJob.txt Get-SCDWJob)
$(CollectorLink Get-SCDWJob_NumberOfBatches_5.txt 'Get-SCDWJob -NumberOfBatches 5')
$(CollectorLink Get-SCDWJobSchedule.txt Get-SCDWJobSchedule)
$(CollectorLink SQL_DeploySequenceView.csv DeploySequenceView)
$(CollectorLink SQL_DeploySequenceStaging.csv DeploySequenceStaging)
$(CollectorLink SQL_DeployItemStaging.csv DeployItemStaging)
$(CollectorLink SQL_InfraBatch.csv infra.Batch)
$(CollectorLink SQL_InfraWorkItem.csv infra.WorkItem)
$(CollectorLink SQL_LockDetails.csv LockDetails)
$(CollectorLink OperationsManager.evtx 'OperationsManager event log')</pre>"
        $dataRow.ProblemSeverity=[ProblemSeverity]::Error 
        $Result_Problems += $dataRow
    }
    else {

        if ( ($CubeJobs | ? { $_.Status -in ("Running","Not Started") } ).Count -eq $CubeJobs.Count `
            -and ($cubeJobsSchedules | ? { $_.ScheduleEnabled -eq $true } ).Count -eq $cubeJobsSchedules.Count `
            -and  $cubeJobsSchedules.Count -eq $CubeJobs.Count
        ) { 
            $dataRow.RuleResult="All Cube jobs look fine."
            $dataRow.ProblemSeverity=[ProblemSeverity]::Error
            $Result_OKs += $dataRow 
        }
        elseif ( ($CubeJobs | ? { $_.Status -in ("Running","Not Started") } ).Count -ne $CubeJobs.Count ) {
            $dataRow.RuleResult = "At least one Cube batch is not in status 'Running' or 'Not Started'. $(IgnoreRuleIfText) cubes are not in use. Check in the files below:<pre>
$(CollectorLink Get-SCDWJob.txt Get-SCDWJob)
$(CollectorLink Get-SCDWJob_NumberOfBatches_5.txt 'Get-SCDWJob -NumberOfBatches 5')
$(CollectorLink Get-SCDWJobSchedule.txt Get-SCDWJobSchedule)
$(CollectorLink SQL_DeploySequenceView.csv DeploySequenceView)
$(CollectorLink SQL_DeploySequenceStaging.csv DeploySequenceStaging)
$(CollectorLink SQL_DeployItemStaging.csv DeployItemStaging)
$(CollectorLink SQL_InfraBatch.csv infra.Batch)
$(CollectorLink SQL_InfraWorkItem.csv infra.WorkItem)
$(CollectorLink SQL_LockDetails.csv LockDetails)
$(CollectorLink OperationsManager.evtx 'OperationsManager event log')</pre>"
            $dataRow.ProblemSeverity=[ProblemSeverity]::Error
            $Result_Problems += $dataRow
        }
        elseif ( ($cubeJobsSchedules | ? { $_.ScheduleEnabled -eq $true } ).Count -ne $cubeJobsSchedules.Count ) {
            $dataRow.RuleResult = "At least one Cube 'Schedule' is DISABLED in $(CollectorLink Get-SCDWJobSchedule.txt Get-SCDWJobSchedule). $(IgnoreRuleIfText) they are intentionally disabled. Otherwise, run the below to enable all cube Job Schedules:<pre>"+
            'Foreach($job in get-scdwjob) { if ($job.CategoryName -eq "CubeProcessing") {Enable-scdwjobSchedule -jobname $job.name;} } </pre>'
            $dataRow.ProblemSeverity=[ProblemSeverity]::Warning
            $Result_Problems += $dataRow
        }
        elseif (  $cubeJobsSchedules.Count -ne $CubeJobs.Count ) {
            $dataRow.RuleResult = "At least one Cube 'Schedule' is MISSING. $(IgnoreRuleIfText) cubes are not in use. Check in the files below:<pre>
$(CollectorLink Get-SCDWJobSchedule.txt Get-SCDWJobSchedule)
$(CollectorLink SQL_DeploySequenceView.csv DeploySequenceView)
$(CollectorLink SQL_DeploySequenceStaging.csv DeploySequenceStaging)
$(CollectorLink SQL_DeployItemStaging.csv DeployItemStaging)
$(CollectorLink Get-SCDWJob.txt Get-SCDWJob)
$(CollectorLink Get-SCDWJob_NumberOfBatches_5.txt 'Get-SCDWJob -NumberOfBatches 5')
$(CollectorLink SQL_InfraBatch.csv infra.Batch)
$(CollectorLink SQL_InfraWorkItem.csv infra.WorkItem)
$(CollectorLink SQL_LockDetails.csv LockDetails)
$(CollectorLink OperationsManager.evtx 'OperationsManager event log')</pre>"
            $dataRow.ProblemSeverity=[ProblemSeverity]::Error
            $Result_Problems += $dataRow
        }
    }
}

function Check_DateFormatOfExtractJobsSQLAccount() {
$linesIn_dbcc_useroptions = GetFileContentInSourceFolder ForExtractJob_dbcc_useroptions_FromDW_ToSMDB.txt 
 $isDateFormatCorrect = (GetLinesFromString ($linesIn_dbcc_useroptions)) -contains '"dateformat","mdy"' 
 $fileContainsAttention = $linesIn_dbcc_useroptions.contains('Attention!')

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="Date format of Extract Job's SQL Account"
    $dataRow.RuleDesc="The Extract Job (the one that does not start with 'DW_') reads data from SM DB every 5 minutes. There are many issues if the RunAs Account (in $(CollectorLink Get-SCSMRunAsAccount.txt)) that is connecting to SM DB (SQL info in $(CollectorLink SQL_DW_DataSources.csv)) has a dateformat other than 'mdy'. For example, in German installations it's usually 'dmy'. In this case, the 'Symptom' is: The Extract does not fail, but some data won't be picked up from the SM DB 'randomly'."
    $dataRow.RuleResult="Dateformat in SM DB for Extract Job's SQL Account is correct."
    $dataRow.SAPCategories = "dw*" 
    $dataRow.ProblemSeverity=[ProblemSeverity]::Warning

    if ( $isDateFormatCorrect -and (-not $fileContainsAttention) ) { $Result_OKs += $dataRow }
    elseif ( $isDateFormatCorrect -and $fileContainsAttention ) { 
        $dataRow.RuleResult = "The Collector did not run as Extract Job's RunAs Account. Check $(CollectorLink ForExtractJob_dbcc_useroptions_FromDW_ToSMDB.txt dbcc_useroptions) for details. <br/>$(IgnoreRuleIfText) the 'Symptom' has not happened, otherwise connect to SM DB with Extract's account and run 'dbcc useroptions', the 'dateformat' in the result must be 'mdy'."
        $dataRow.ProblemSeverity=[ProblemSeverity]::Warning
        $Result_Problems += $dataRow 
    }
    elseif ( (-not $isDateFormatCorrect) -and $fileContainsAttention ) { 
        $dataRow.RuleResult = "The Collector did not run as Extract Job's RunAs Account. Check $(CollectorLink ForExtractJob_dbcc_useroptions_FromDW_ToSMDB.txt dbcc_useroptions) for details. <br/>$(IgnoreRuleIfText) the 'Symptom' has not happened (bcz this can be false positive), otherwise connect to SM DB with Extract's account and run 'dbcc useroptions', the 'dateformat' in the result must be 'mdy'."
        $dataRow.ProblemSeverity=[ProblemSeverity]::Warning
        $Result_Problems += $dataRow 
    }

    elseif ( (-not $isDateFormatCorrect) -and (-not $fileContainsAttention) ) {        
        $dataRow.RuleResult = "The dateformat is not 'mdy' for Extract Job's RunAs Account. Check $(CollectorLink ForExtractJob_dbcc_useroptions_FromDW_ToSMDB.txt dbcc_useroptions). Most probably some data does NOT flow to the DW intermittently. This can be false positive, but better to change the Language of the Extract Job's SQL Account to 'English'."
        $dataRow.ProblemSeverity=[ProblemSeverity]::Critical
        $Result_Problems += $dataRow
    }
    else {
          $dataRow.ProblemSeverity=[ProblemSeverity]::Unclassified
          $Result_Problems += $dataRow
    }
}

function Check_DWData_IsUpTodate(){
#Check if data in DW is up-to-date
$NewestDataInSM = ConvertFrom-Csv (GetSanitizedCsv (GetFileContentInSourceFolder SQL_FromSMDB_WorkItemsCount.csv))
$NewestDataInDw = ConvertFrom-Csv (GetSanitizedCsv (GetFileContentInSourceFolder SQL_NewestWorkItemsInDW.csv)) 

$NewestIRDateInSM = ParseSqlDate ($NewestDataInSM[0].Newest)
$NewestSRDateInSM = ParseSqlDate ($NewestDataInSM[2].Newest)
$NewestCRDateInSM = ParseSqlDate ($NewestDataInSM[4].Newest)

$NewestIRDateInDWRep = ParseSqlDate ($NewestDataInDw[0].'Created at')
$NewestSRDateInDWRep = ParseSqlDate ($NewestDataInDw[3].'Created at')
$NewestCRDateInDWRep = ParseSqlDate ($NewestDataInDw[6].'Created at')

$NewestIRDateInDWDM = ParseSqlDate ($NewestDataInDw[1].'Created at')
$NewestSRDateInDWDM = ParseSqlDate ($NewestDataInDw[4].'Created at')
$NewestCRDateInDWDM = ParseSqlDate ($NewestDataInDw[7].'Created at')

$TransformCommonIssue = $false
$LoadCommonIssue = $false

$MinutesBetweenSmAndDWRep = [int]::MaxValue
$MinutesBetweenSmAndDWDM = [int]::MaxValue

$allowMinutesDelayForTransformCommon = 30*2  # Used twice the default 30 minutes. todo: Can be set later by reading from get-swdwjobschedule.csv if the default schedule has been changed.
$allowMinutesDelayForLoadCommon = 60*2  # Used twice the default 60 minutes. todo Can be set later by reading from get-swdwjobschedule.csv if the default schedule has been changed.

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="DW data is up-to-date"
    $dataRow.RuleDesc=@"
The Load.Common job brings data into DWDataMart every 60 minutes. We are checking here if data is delayed (allowing twice the delay = 120 minutes) by comparing dates between $(CollectorLink SQL_FromSMDB_WorkItemsCount.csv SMDB) and $(CollectorLink SQL_NewestWorkItemsInDW.csv DWDataMart) to verify if Load.Common is working fine.
<br/><br/>We also compare between $(CollectorLink SQL_FromSMDB_WorkItemsCount.csv SMDB) and $(CollectorLink SQL_NewestWorkItemsInDW.csv DWRepository) to check the Transform.Common job by allowing a 60 minutes delay.
<br/><br/>We do these comparisons separately for Incident, Service Request and Changes Requests.
"@
    $dataRow.SAPCategories= "*etl*" , "*Mpsync*"
    $dataRow.ProblemSeverity=[ProblemSeverity]::Warning
    
    $dataRow.RuleResult=[string]::Empty

    $minutesDiff=(Abs $NewestIRDateInDWDM.Subtract($NewestIRDateInSM).TotalMinutes)
    if ( $minutesDiff -gt $allowMinutesDelayForLoadCommon ) {                                                                                                                                                                                  
        $dataRow.RuleResult += "<li>IRs are delayed for more than $allowMinutesDelayForLoadCommon minutes by Load.Common: $(  Get-UserFriendlyTimeSpane ([timespan]::FromMinutes($minutesDiff)) )</li>"
    }
    $minutesDiff=(Abs $NewestSRDateInDWDM.Subtract($NewestSRDateInSM).TotalMinutes)
    if ( $minutesDiff -gt $allowMinutesDelayForLoadCommon ) {
        $dataRow.RuleResult += "<li>SRs are delayed for more than $allowMinutesDelayForLoadCommon minutes by Load.Common: $(  Get-UserFriendlyTimeSpane ([timespan]::FromMinutes($minutesDiff)) )</li>"
    }
    $minutesDiff=(Abs $NewestCRDateInDWDM.Subtract($NewestCRDateInSM).TotalMinutes)
    if ( $minutesDiff -gt $allowMinutesDelayForLoadCommon ) {
        $dataRow.RuleResult += "<li>CRs are delayed for more than $allowMinutesDelayForLoadCommon minutes by Load.Common: $(  Get-UserFriendlyTimeSpane ([timespan]::FromMinutes($minutesDiff)) )</li>"
    }
    #----------------------------------------------------------------------------------------------------
    $dataRow.RuleResult += "<br/>"
    #----------------------------------------------------------------------------------------------------
    $minutesDiff=(Abs $NewestIRDateInDWRep.Subtract($NewestIRDateInSM).TotalMinutes)
    if ( $minutesDiff -gt $allowMinutesDelayForTransformCommon ) {
        $dataRow.RuleResult += "<li>IRs are delayed for more than $allowMinutesDelayForTransformCommon minutes by Transform.Common: $(  Get-UserFriendlyTimeSpane ([timespan]::FromMinutes($minutesDiff)) )</li>"
    }
    $minutesDiff=(Abs $NewestSRDateInDWRep.Subtract($NewestSRDateInSM).TotalMinutes)
    if ( $minutesDiff -gt $allowMinutesDelayForTransformCommon ) {
        $dataRow.RuleResult += "<li>SRs are delayed for more than $allowMinutesDelayForTransformCommon minutes by Transform.Common: $(  Get-UserFriendlyTimeSpane ([timespan]::FromMinutes($minutesDiff)) )</li>"
    }
    $minutesDiff=(Abs $NewestCRDateInDWRep.Subtract($NewestCRDateInSM).TotalMinutes)
    if ( $minutesDiff -gt $allowMinutesDelayForTransformCommon ) {
        $dataRow.RuleResult += "<li>CRs are delayed for more than $allowMinutesDelayForTransformCommon minutes by Transform.Common: $(  Get-UserFriendlyTimeSpane ([timespan]::FromMinutes($minutesDiff)) )</li>"
    }
    #----------------------------------------------------------------------------------------------------
    if ( $dataRow.RuleResult -eq [string]::Empty ) { 
        $dataRow.RuleResult="All look fine."
        $Result_OKs += $dataRow 
    }
    else { 
        $dataRow.RuleResult += "<br/>For the root cause, check these files: $(CollectorLink Get-SCDWJobSchedule.txt Get-SCDWJobSchedule), $(CollectorLink Get-SCDWJob.txt Get-SCDWJob), $(CollectorLink Get-SCDWJob_NumberOfBatches_5.txt 'Get-SCDWJob -NumberOfBatches 5'), $(CollectorLink SQL_InfraBatch.csv 'infra.Batch'), $(CollectorLink SQL_InfraWorkItem.csv 'infra.WorkItem'), $(CollectorLink SQL_LockDetails.csv 'LockDetails') and $(CollectorLink OperationsManager.evtx 'OM event log').</br></br>$(IgnoreRuleIfText) DW is used for MIM/FIM because MIM does not use IR, SR, CR, they have their own custom work item types."
        $Result_Problems += $dataRow 
    }
}

function Check_DWJobSchedules_ExcludingCubes() {
#check DW Job Schedules (excl Cubes). Schedule counts should match with job counts.
$GetSCDWJobSchedule = ConvertFrom-Csv (GetFileContentInSourceFolder Get-SCDWJobSchedule.csv)
$jobSchedules_Wocubes = $GetSCDWJobSchedule | ? { $_.CategoryName -ne "CubeProcessing" }

$GetSCDWJob = ConvertFrom-Csv (GetFileContentInSourceFolder Get-SCDWJob.csv)
$jobs_Wocubes = $GetSCDWJob | ? { $_.CategoryName -ne "CubeProcessing" }

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="DW ETL Job Schedules (excl Cubes)"
    $dataRow.RuleDesc="The 'Schedules' for DWMaintenance, MPSyncJob, Extract*, Transform.Common and Load.* jobs must be Enabled. $(CollectorLink Get-SCDWJobSchedule.txt Get-SCDWJobSchedule)"
    $dataRow.SAPCategories= "*etl*" , "*mpsync*"
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    $dataRow.RuleResult = [string]::Empty
    if ( $jobSchedules_Wocubes.count -ne $jobs_Wocubes.Count ) {
        $dataRow.RuleResult += @"
At least one Job Schedule is MISSING! Check in the files below:><pre> 
$(CollectorLink SQL_DeploySequenceView.csv DeploySequenceView)
$(CollectorLink SQL_DeploySequenceStaging.csv DeploySequenceStaging)
$(CollectorLink SQL_DeployItemStaging.csv DeployItemStaging)
$(CollectorLink Get-SCDWJob.txt Get-SCDWJob)
$(CollectorLink Get-SCDWJobSchedule.txt Get-SCDWJobSchedule)
$(CollectorLink OperationsManager.evtx 'OperationsManager event log')</pre>
"@
    }
    elseif ( ($jobSchedules_Wocubes | ? { $_.ScheduleEnabled -eq $true } ).Count -ne $jobSchedules_Wocubes.Count) {
        $dataRow.RuleResult += "
At least one Job Schedule is DISABLED! Confirm if they are intentionally disabled. $(CollectorLink Get-SCDWJobSchedule.txt Get-SCDWJobSchedule)"+'
The below can enable all required Job Schedules:<pre>
Foreach($job in get-scdwjob) { if ($job.CategoryName -ne "CubeProcessing") {Enable-scdwjobSchedule -jobname $job.name;} }<pre>'
    }
    
    if ($dataRow.RuleResult -eq [string]::Empty) {
        $dataRow.RuleResult="All schedules (except Cubes) are enabled."
        $Result_OKs += $dataRow
    }
    else { $Result_Problems += $dataRow }
}

function Check_DWJobStatus_ExcludingCubes() {
#check DW Job Status (excl Cubes). This would inheritently check job existence, too.

$GetSCDWJob = ConvertFrom-Csv (GetFileContentInSourceFolder Get-SCDWJob.csv)

$DWMaintenance = $GetSCDWJob | ? { $_.Name -eq "DWMaintenance"}
$MPSyncJob = $GetSCDWJob | ? { $_.Name -eq "MPSyncJob"}
$Extract_DW = $GetSCDWJob | ? { $_.Name -like "Extract_DW_*"}
$Extract_Others = $GetSCDWJob | ? { $_.CategoryName -eq "Extract" -and -not ($_.Name -like "Extract_DW_*") }
$TransformCommon = $GetSCDWJob | ? { $_.Name -eq "Transform.Common"}
$LoadCommon = $GetSCDWJob | ? { $_.Name -eq "Load.Common"}
$Load_Others = $GetSCDWJob | ? { $_.CategoryName -eq "Load" -and -not ($_.Name -eq "Load.Common") }

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="DW Jobs Status (excl Cubes)"
    $dataRow.RuleDesc="The batches for DWMaintenance, MPSyncJob, (at least) 2 Extract*, Transform.Common and Load.* must be Running or Not Started. $(CollectorLink Get-SCDWJob.txt Get-SCDWJob)"
    $dataRow.RuleResult="All ETL jobs look fine."
    $dataRow.SAPCategories= "*etl*" , "*mpsync*"
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($DWMaintenance.Status -in ("Running","Not Started") `
        -and $MPSyncJob.Status -in ("Running","Not Started") `
        -and $Extract_DW.Status -in ("Running","Not Started") `
        -and ($Extract_Others | ? { $_.Status -in ("Running","Not Started") } ).Count -eq $Extract_Others.Count `
        -and $TransformCommon.Status -in ("Running","Not Started") `
        -and $LoadCommon.Status -in ("Running","Not Started")  `
        -and ($Load_Others | ? { $_.Status -in ("Running","Not Started") } ).Count -eq $Load_Others.Count 
    ) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult = @"
At least one batch is not in status: 'Running' or 'Not Started'. Check in the files below:<pre>
$(CollectorLink Get-SCDWJob.txt Get-SCDWJob)
$(CollectorLink SQL_DeploySequenceView.csv DeploySequenceView)
$(CollectorLink SQL_DeploySequenceStaging.csv DeploySequenceStaging)
$(CollectorLink SQL_DeployItemStaging.csv DeployItemStaging)
$(CollectorLink Get-SCDWJob_NumberOfBatches_5.txt 'Get-SCDWJob -NumberOfBatches 5')
$(CollectorLink SQL_InfraBatch.csv infra.Batch)
$(CollectorLink SQL_InfraWorkItem.csv infra.WorkItem)
$(CollectorLink SQL_LockDetails.csv LockDetails)
$(CollectorLink OperationsManager.evtx 'OperationsManager event log')</pre>
"@
        $Result_Problems += $dataRow
    }
}

function Check_DWMPDeploymentStatus() {
#Check DW MP Deployment Status
$DwMPs = ConvertFrom-Csv (GetSanitizedCsv (GetFileContentInSourceFolder SQL_DeploySequenceView.csv)) 

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="DW MP Deployment Status"
    $dataRow.RuleDesc="All DW MPs should have Deployment Status of Completed. $(CollectorLink SQL_DeploySequenceView.csv 'MP Deployment Status')"
    $dataRow.RuleResult="All MPs are deployed to the DW successfully."
    $dataRow.SAPCategories= "*etl*" , "*Mpsync*"
    $dataRow.ProblemSeverity=[ProblemSeverity]::Error

    if ( $DwMPs.Count -eq 0 ) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult = "At least one MP deployment has not Completed. $(IgnoreRuleIfText) MPSyncJob is still in progress. Otherwise, check in the files below:<pre>
$(CollectorLink SQL_DeploySequenceView.csv DeploySequenceView)
$(CollectorLink SQL_DeploySequenceStaging.csv DeploySequenceStaging)
$(CollectorLink SQL_DeployItemStaging.csv DeployItemStaging)
$(CollectorLink SQL_SynchronizationJobDetails.csv 'Synchronization Job Details')
$(CollectorLink Get-SCDWJob.txt Get-SCDWJob)
$(CollectorLink Get-SCDWJob_NumberOfBatches_5.txt 'Get-SCDWJob -NumberOfBatches 5')
$(CollectorLink SQL_InfraBatch.csv infra.Batch)
$(CollectorLink SQL_InfraWorkItem.csv infra.WorkItem)
$(CollectorLink SQL_LockDetails.csv LockDetails)
$(CollectorLink OperationsManager.evtx 'OperationsManager event log')</pre>"
        $Result_Problems += $dataRow
    }
}

function Check_MPSyncJobConnectivity() {
$linesIn_ForMPSyncJob_Telnet_FromDW_ToSMSDK = GetFileContentInSourceFolder ForMPSyncJob_Telnet_FromDW_ToSMSDK.txt 
 $canMPSyncJobConnect = (GetLinesFromString ($linesIn_ForMPSyncJob_Telnet_FromDW_ToSMSDK)) -like 'TcpTestSucceeded*:*True'

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="MPSyncJob Connectivity"
    $dataRow.RuleDesc="The MPSyncJob must be able to connect to the designated (mostly Primary) Management Server's OMSDK service. $(CollectorLink 'ForMPSyncJob_Telnet_FromDW_ToSMSDK.txt' Telnet)"
    $dataRow.RuleResult="Network connection test succeeded."
    $dataRow.SAPCategories = "dw*" 
    $dataRow.ProblemSeverity=[ProblemSeverity]::Error

    if ( $canMPSyncJobConnect ) { $Result_OKs += $dataRow }   
    else {        
        $dataRow.RuleResult = "Looks like TCP port 5724 test failed. Check in $(CollectorLink 'ForMPSyncJob_Telnet_FromDW_ToSMSDK.txt'). $(IgnoreRuleIfText) if MPSyncJob is not needed, maybe like in FIM/MIM."
        $Result_Problems += $dataRow
    }    
}

function Check_MPSyncJob_Progress() {
#Check "Job Progress" in SQL_SynchronizationJobDetails.csv
$fileContent = GetFileContentInSourceFolder SQL_SynchronizationJobDetails.csv
$linesInFile = GetLinesFromString $fileContent
$jobProgressIsOK = $false

    if ($linesInFile.Count -gt 1) {
        $JobProgressInFile = $linesInFile[1]
        $JobProgressInFile = $JobProgressInFile.Replace('"','')
        $parts = $JobProgressInFile.Split("/")
        if ($parts.Count -eq 2 -and $parts[0] -eq $parts[1]) { $jobProgressIsOK = $true }
    }

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="Job Progress of MPSyncJob"
    $dataRow.RuleDesc="All synchronization jobs should be Associated or Disassociated. $(CollectorLink SQL_SynchronizationJobDetails.csv 'Synchronization Job Details')"
    $dataRow.RuleResult="All look fine."
    $dataRow.SAPCategories= "*etl*" , "*Mpsync*"
    $dataRow.ProblemSeverity=[ProblemSeverity]::Error

    if ($jobProgressIsOK -eq $true  ) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult = "At least one MP is still not Associated or Disassociated. $(CollectorLink SQL_SynchronizationJobDetails.csv 'Synchronization Job Details') $(IgnoreRuleIfText) MPSyncJob is still in progress. Otherwise, check in the files below:<pre>
$(CollectorLink SQL_DeploySequenceView.csv DeploySequenceView)
$(CollectorLink SQL_DeploySequenceStaging.csv DeploySequenceStaging)
$(CollectorLink SQL_DeployItemStaging.csv DeployItemStaging)
$(CollectorLink Get-SCDWJob.txt Get-SCDWJob)
$(CollectorLink Get-SCDWJob_NumberOfBatches_5.txt 'Get-SCDWJob -NumberOfBatches 5')
$(CollectorLink SQL_InfraBatch.csv infra.Batch)
$(CollectorLink SQL_InfraWorkItem.csv infra.WorkItem)
$(CollectorLink SQL_LockDetails.csv LockDetails)
$(CollectorLink OperationsManager.evtx 'OperationsManager event log')</pre>"
        $Result_Problems += $dataRow
    }

#endregion
}

function Analyze_ForDW() {
#region DO NOT REMOVE THIS! Exit immediately if script does NOT run on a DW mgmt server.
if (-not (IsSourceScsmDwMgmtServer)) {
    return
}
#endregion

#Rules for SCSM DW server only 

 #region Get DB info, to be used by subsequent rules
    $linesIn_regValues = GetFileContentInSourceFolder SystemCenter.regValues.txt

    $DW_Rep_SQL_InstanceName = GetFirstLineThatStartsWith $linesIn_regValues '"RepositorySQLInstance"="'    
    $DW_Rep_SQL_InstanceName = $DW_Rep_SQL_InstanceName.Split("=")[1].Replace('"','')
    $DW_Rep_SQL_DbName = GetFirstLineThatStartsWith $linesIn_regValues '"RepositoryDatabaseName"="'
    $DW_Rep_SQL_DbName = $DW_Rep_SQL_DbName.Split("=")[1].Replace('"','')

    $DW_DM_SQL_InstanceName = GetFirstLineThatStartsWith $linesIn_regValues '"DataMartSQLInstance"="'    
    $DW_DM_SQL_InstanceName = $DW_DM_SQL_InstanceName.Split("=")[1].Replace('"','')
    $DW_DM_SQL_DbName = GetFirstLineThatStartsWith $linesIn_regValues '"DataMartDatabaseName"="'
    $DW_DM_SQL_DbName = $DW_DM_SQL_DbName.Split("=")[1].Replace('"','')

    $DW_CM_SQL_InstanceName = GetFirstLineThatStartsWith $linesIn_regValues '"CMDataMartSQLInstance"="'    
    $DW_CM_SQL_InstanceName = $DW_CM_SQL_InstanceName.Split("=")[1].Replace('"','')
    $DW_CM_SQL_DbName = GetFirstLineThatStartsWith $linesIn_regValues '"CMDataMartDatabaseName"="'
    $DW_CM_SQL_DbName = $DW_CM_SQL_DbName.Split("=")[1].Replace('"','')

    $DW_OM_SQL_InstanceName = GetFirstLineThatStartsWith $linesIn_regValues '"OMDataMartSQLInstance"="'    
    $DW_OM_SQL_InstanceName = $DW_OM_SQL_InstanceName.Split("=")[1].Replace('"','')
    $DW_OM_SQL_DbName = GetFirstLineThatStartsWith $linesIn_regValues '"OMDataMartDatabaseName"="'
    $DW_OM_SQL_DbName = $DW_OM_SQL_DbName.Split("=")[1].Replace('"','')
    #endregion

    Check_DWJobStatus_ExcludingCubes
    Check_DWJobSchedules_ExcludingCubes
    Check_CubeJobsStatusAndSchedule
    Check_MPSyncJob_Progress
    Check_DWMPDeploymentStatus
    Check_DWData_IsUpTodate
    Check_DateFormatOfExtractJobsSQLAccount
    Check_MPSyncJobConnectivity
}

function Check_HealthService() {

    $linesIn_get_service = ConvertFrom-Csv (GetSanitizedCsv (GetFileContentInSourceFolder get-service.csv)) 
    $HsLine = GetValueFromImportedCsv $linesIn_get_service "name" "HealthService" "Name"
    $HsService_StartMode = GetValueFromImportedCsv $linesIn_get_service "name" "HealthService" "StartMode"
    $HsService_State = GetValueFromImportedCsv $linesIn_get_service "name" "HealthService" "State"   
    
    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="HealthService"
    $dataRow.RuleDesc="Microsoft Monitoring Agent (HealthService) must be Running and Automatic started."
    $dataRow.RuleResult="HealthService is Running and Automatic."    
    if (IsSourceScsmWfMgmtServer) { $dataRow.SAPCategories = "wf*" }
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories = "dw*" }     
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($HsLine -and $HsService_State -eq "Running" -and $HsService_StartMode -eq "Auto" ) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult = 'The HealthService is either NOT Running or NOT set as Automatic or is not installed. ' + (CollectorLink get-service.csv)
        $Result_Problems += $dataRow
    }
}

function Check_OMCFG_Service() {

    $linesIn_get_service = ConvertFrom-Csv (GetSanitizedCsv (GetFileContentInSourceFolder get-service.csv)) 
    $OmCfgLine = GetValueFromImportedCsv $linesIn_get_service "name" "OMCFG" "Name"
    $OmCfgService_StartMode = GetValueFromImportedCsv $linesIn_get_service "name" "OMCFG" "StartMode"
    $OmCfgService_State = GetValueFromImportedCsv $linesIn_get_service "name" "OMCFG" "State"   
    
    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="OMCFG Service"
    $dataRow.RuleDesc="System Center Management Configuration Service (OMCFG) must be Running and Automatic started."
    $dataRow.RuleResult="OMCFG is Running and Automatic."    
    if (IsSourceScsmWfMgmtServer) { $dataRow.SAPCategories = "wf*"}
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories = "dw**" }     
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($OmCfgLine -and $OmCfgService_State -eq "Running" -and $OmCfgService_StartMode -eq "Auto" ) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult = 'The OMCFG Service is either NOT Running or NOT set as Automatic or is not installed. ' + (CollectorLink get-service.csv)
        $Result_Problems += $dataRow
    }
}

function Check_ScomAgent() {

    $line1 = GetFirstLineThatStartsWith (GetFileContentInSourceFolder AgentMGs.regValues.txt) 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Agent Management Groups\'
    $line2 = GetFirstLineThatStartsWith (GetFileContentInSourceFolder AgentMGs.regValues.txt) 'NetworkName    REG_SZ'
    
    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="SCOM Agent"
    $dataRow.RuleDesc="Scsm mgmt server should never be monitored by SCOM as an 'Agent'. Instead, 'Agentless' monitoring can be used."
    $dataRow.RuleResult="No SCOM Agent found."
    if (IsSourceScsmWfMgmtServer) { $dataRow.SAPCategories = "wf*" }
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories = "dw*" }     
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($line1.Length -eq 0 -and $line2.Length -eq 0) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult = "SCOM Agent found in $(CollectorLink AgentMGs.regValues.txt). Search for 'Microsoft Monitoring Agent' in $(GetAnchorForExternal 'https://techcommunity.microsoft.com/t5/System-Center-Blog/Troubleshooting-Service-Manager-work-item-Incident-Change/ba-p/351821' KB)"
        $Result_Problems += $dataRow
    }
}

function Analyze_ForDWAndWF() {
#region DO NOT REMOVE THIS! Exit immediately if script does NOT run on a DW or WF mgmt server.
if (-not ( (IsSourceScsmDwMgmtServer) -or (IsSourceScsmWfMgmtServer) )) {
    return
}
#endregion

 #Rules for SCSM mgmt servers excluding Secondary => only DW + WF, where SM Workflows are running

    Check_OMCFG_Service
    Check_HealthService
    Check_ScomAgent
}

function Check_CollectorsSqlPermission() {
    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="This Tool's SQL Permission"
    $dataRow.RuleDesc= "The SCSM Diagnostic Tool must have at least SELECT permission on the target DB. Otherwise, this Analysis should be considered as useless."
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical    

    $linesIn_tmpFile = ConvertFrom-Csv  ( GetSanitizedCsv  ( GetFileContentInSourceFolder SQL_MOMManagementGroupInfo.csv ) ) 
    if ([string]::IsNullOrWhiteSpace( $linesIn_tmpFile)) {
        $dataRow.RuleResult="This Analysis is <h1>'USELESS'.</H1><br/> Do <b><u>NOT</u></b> rely on the findings of this Analysis report.<br/>As an example, you can check in $(CollectorLink SQL_MOMManagementGroupInfo.csv) to confirm that the user account which ran this Tool was *NOT* able to read from a table in the DB."   
        $Result_Problems += $dataRow
    }
    else {
        $dataRow.RuleResult="Looks good. As an example, you can check in $(CollectorLink SQL_MOMManagementGroupInfo.csv) to verify if the user account that ran this Tool was able to read from a table in the DB."
        $Result_OKs += $dataRow
    }    
}

function Check_ConnectedSDKUsers() {
    $linesIn_ConnectedSDKUsers = GetLinesFromString (GetFileContentInSourceFolder ConnectedSDKUsers.txt) 
    $actualSDKClientConnections = [int]($linesIn_ConnectedSDKUsers[3])

    $maxAllowedSDKClientConnectionsPerSDKService = 30

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="Client connections to SDK Service"
    $dataRow.RuleDesc="Ideally the OMSDK service should not handle more than $maxAllowedSDKClientConnectionsPerSDKService SDK Client connections. An SDK Client can be Console, Portal, PowerShell, Runbook etc. $(CollectorLink ConnectedSDKUsers.txt)"
    $dataRow.RuleResult="Actual SDK Client connections count: $($actualSDKClientConnections.ToString())"
    if (IsSourceScsmMgmtServer) { $dataRow.SAPCategories = "s*\*perf*" , "wf*\*perf*" }
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories ="dw*\*perf*"} 
    
    $dataRow.ProblemSeverity=[ProblemSeverity]::Warning

    if ( $actualSDKClientConnections -le $maxAllowedSDKClientConnectionsPerSDKService ) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult += "<br/>Can be investigated further in $(CollectorLink netstat_abof.txt).<br/>$(IgnoreRuleIfText) if Performance of the SDK Service is NOT the main issue."
        $Result_Problems += $dataRow
    }
}

function Check_MgmtServerHW() {
    $cpuCount = 0
    $EnvVars1 = Import-Csv (GetFileNameInSourceFolder EnvVars.csv)
    [decimal]$cpuCount = GetValueFromImportedCsv $EnvVars1 "Key" "NUMBER_OF_PROCESSORS" "Value"

    $totalRamInMB = 0
    [decimal]$totalRamInMB = GetFileContentInSourceFolder TotalRAM.txt

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="Mgmt Server HW"
    $dataRow.RuleDesc="Must have min: 4 CPU, 8000 MB RAM"
    $dataRow.RuleResult="Actual: $cpuCount CPU, $totalRamInMB MB RAM" 
    if (IsSourceScsmWfMgmtServer) { $dataRow.SAPCategories =  "wf\*perf*", "s*\*perf*"}
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories = "dw\*" } 
    if (IsSourceScsmSecondaryMgmtServer) { $dataRow.SAPCategories =  "s*\*perf*"}
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($cpuCount -ge 4  -and  $totalRamInMB -ge 8000) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult += " $(GetAnchorForExternal 'https://docs.microsoft.com/en-us/system-center/scsm/system-requirements?view=sc-sm-2019#hardware' KB)"        
        $Result_Problems += $dataRow
    }
}

function Check_OMSDK_Service() {
    $linesIn_get_service = ConvertFrom-Csv (GetSanitizedCsv (GetFileContentInSourceFolder get-service.csv)) 
    $OmSdkLine = GetValueFromImportedCsv $linesIn_get_service "name" "OMSDK" "Name"
    $OmSdkService_StartMode = GetValueFromImportedCsv $linesIn_get_service "name" "OMSDK" "StartMode"
    $OmSdkService_State = GetValueFromImportedCsv $linesIn_get_service "name" "OMSDK" "State"   
    
    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="OMSDK Service"
    $dataRow.RuleDesc="System Center Data Access Service (OMSDK) must be Running and Automatic started."
    $dataRow.RuleResult="OMSDK is Running and Automatic."    
    if (IsSourceScsmWfMgmtServer) { $dataRow.SAPCategories = "s*" , "wf*" }
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories = "dw*" } 
    if (IsSourceScsmSecondaryMgmtServer) { $dataRow.SAPCategories = "s*"}   
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($OmSdkLine -and $OmSdkService_State -eq "Running" -and $OmSdkService_StartMode -eq "Auto" ) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult = 'The OMSDK Service is either NOT Running or NOT set as Automatic or is not installed. ' + (CollectorLink get-service.csv)
        $Result_Problems += $dataRow
    }
}

function Check_SPNs() {
$spn1 = GetFirstLineThatIsEqualTo (GetFileContentInSourceFolder spnSDK.txt) ("msomsdksvc/$Scsm_ComputerName")
$spn2 = GetFirstLineThatIsEqualTo (GetFileContentInSourceFolder spnSDK.txt) ("msomsdksvc/$Scsm_ComputerFqdnName")
    
    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="SPNs"
    $dataRow.RuleDesc="MsOmSdkSvc SPNs for both Computer and FQDN names must be set. $(CollectorLink spnSDK.txt SPNs)"
    $dataRow.RuleResult="Both SPNs are set"
    if (IsSourceScsmWfMgmtServer) { $dataRow.SAPCategories = "wf" }
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories = "dw"} 
    if (IsSourceScsmSecondaryMgmtServer) { $dataRow.SAPCategories = "sm*" } 
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($spn1.Length -gt 0 -and $spn2.Length -gt 0) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult = @"
         At least one of the required SPNs are missing in $(CollectorLink spnSDK.txt). $(GetAnchorForExternal 'https://blog.scsmsolutions.com/2012/11/configure-the-kerberos-for-scsm-2012-spn-and-delegation/' 'More SPN info')
<br/>To add the missing SPNs, run the below commands on the mgmt server (as a Domain Admin user):
<pre>
    setspn -A MSOMSdkSvc/%COMPUTERNAME% %COMPUTERNAME%
    setspn -A MSOMSdkSvc/%COMPUTERNAME%.%USERDNSDOMAIN% %COMPUTERNAME%</pre>
"@
        $Result_Problems += $dataRow
    }
}

function Check_SqlBroker() {
#region check SQL Broker

    $linesIn_SQL_Databases = ConvertFrom-Csv (GetSanitizedCsv (GetFileContentInSourceFolder SQL_Databases.csv)) 
    $isBrokerEnabled = GetValueFromImportedCsv $linesIn_SQL_Databases "name" $MainSQL_DbName "is_broker_enabled"
    
    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="SQL DB Broker"
    $dataRow.RuleDesc="Broker must be ENABLED"
    $dataRow.RuleResult="Broker at<br/> Instance: $MainSQL_InstanceName<br/> DB: $MainSQL_DbName<br/> is "
    if (IsSourceScsmWfMgmtServer) { $dataRow.SAPCategories = "wf\*" , "s*\*" }
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories = "*etl*","*mpsync*" } 
    if (IsSourceScsmSecondaryMgmtServer) { $dataRow.SAPCategories = "Console\Usage" } 
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($isBrokerEnabled -eq "True") {
        $dataRow.RuleResult += "enabled"
        $Result_OKs += $dataRow
    }
    else {       
        $dataRow.RuleResult += "NOT enabled! $(CollectorLink SQL_Databases.csv)" 
        $dataRow.RuleResult += " <a $(GetAnchorForExternal 'https://social.technet.microsoft.com/Forums/systemcenter/en-US/f16680c3-e906-4704-8d67-22c71c53472b/service-manager-db-sql-server-broker?forum=systemcenterservicemanager' KB)"
        $dataRow.RuleResult += ' <br/>ACTION: Enable SQL DB Broker by running this SQL. Caution: This will disconnect all SQL connections to that DB. Good to stop all SM services before.'
$tmp = @"
<pre>
    ALTER DATABASE $MainSQL_DbName SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    ALTER DATABASE $MainSQL_DbName SET ENABLE_BROKER;
    ALTER DATABASE $MainSQL_DbName SET MULTI_USER;</pre>
"@
        $dataRow.RuleResult +=  $tmp
        $Result_Problems += $dataRow
    }
#endregion
}

function Check_SqlCLR() {
# check if 'clr enabled' is 1 on the SQL instance

    $linesIn_SQL_sp_configure = ConvertFrom-Csv  ( GetSanitizedCsv  ( GetFileContentInSourceFolder SQL_sp_configure.csv ) '"xp_cmdshell' ) 
    [int]$clrEnabled = GetValueFromImportedCsv $linesIn_SQL_sp_configure "name" "clr enabled" "run_value"

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="SQL CLR"
    $dataRow.RuleDesc="CLR must be enabled on the SQL instance that is hosting the ServiceManager database. Otherwise, the Setup can fail or Console can crash, please check OperationsManager event log. The value of 'clr enabled' is in $(CollectorLink SQL_sp_configure.csv)."
    $dataRow.RuleResult="Actual: $clrEnabled"
    if (IsSourceAnyScsmMgmtServer) { $dataRow.SAPCategories =  "Console\*", "SMConfPerf\SM Setup"}
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($clrEnabled -eq 1) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult += @"
<br/>Run the below with SQL admin permissions:<pre>        
sp_configure 'clr enabled', 1
go
reconfigure<pre>
"@
        $Result_Problems += $dataRow
    }
}

function Check_SQLServerHW() {
    $cpuCount = 0
    $linesIn_SQL_Info = GetLinesFromString (GetFileContentInSourceFolder SQL_Info.csv)
    $linesIn_SQL_Info = $linesIn_SQL_Info | Select-String -Pattern '"Product",' -SimpleMatch -Context 0,1  | Out-String -Width 8000 
    $linesIn_SQL_Info = $linesIn_SQL_Info.Replace(">","")
    $linesIn_SQL_Info = GetLinesFromString $linesIn_SQL_Info 
    $SQL_Info = ConvertFrom-Csv $linesIn_SQL_Info 
    [decimal]$cpuCount = $SQL_Info.Processors

    $totalRamInMB = 0
    [decimal]$totalRamInMB = $SQL_Info.PhysicalMemory

    $linesIn_SQL_sp_configure = ConvertFrom-Csv  ( GetSanitizedCsv  ( GetFileContentInSourceFolder SQL_sp_configure.csv ) '"xp_cmdshell' ) 
    [decimal]$totalRamInMB_Configured = GetValueFromImportedCsv $linesIn_SQL_sp_configure "name" "max server memory (MB)" "run_value"

    #if user was not sysadmin then "max server memory (MB)" is 0, therefore we'll ignore it
    if ($totalRamInMB_Configured -ne 0 -and ($totalRamInMB_Configured -lt $totalRamInMB) ) { $totalRamInMB = $totalRamInMB_Configured}

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="SQL Server HW"
    $dataRow.RuleDesc="Must have min: 8 CPU, 8000 MB RAM"
    $dataRow.RuleResult="Actual: $cpuCount CPU, $totalRamInMB MB RAM"
    if (IsSourceScsmWfMgmtServer) { $dataRow.SAPCategories =  "wf\*perf*", "s*\*perf*"}
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories = "dw\*" } 
    if (IsSourceScsmSecondaryMgmtServer) { $dataRow.SAPCategories =  "s*\*perf*"} 
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($cpuCount -ge 8  -and  $totalRamInMB -ge 8000) { $Result_OKs += $dataRow }
    else {        
        $dataRow.RuleResult += " $(GetAnchorForExternal 'https://docs.microsoft.com/en-us/system-center/scsm/system-requirements?view=sc-sm-2019#hardware' KB)"        
        $Result_Problems += $dataRow
    }
}

function Check_TimeDiffBetweenMSAndSQL() {
 #check time diff (for SM server roles)  #TODO

    $timeDiffInSecs = [int]::MaxValue
    $fileContainsError = $true

    [string]$tmp = GetFileContentInSourceFolder TimeDiff_BtwMS_AndSQL_viaWin32tm.txt
    $fileContainsError = $tmp.contains(': 0x')
    if (-not $fileContainsError) {
        $posOfTimeDiff = $tmp.IndexOf(', -'); 
        if ($posOfTimeDiff -eq -1) { $posOfTimeDiff = $tmp.IndexOf(', +') }

        if ($posOfTimeDiff -eq -1) { $fileContainsError = $true }
        else {
            $posOfTimeDiff2 = $tmp.IndexOf('.',$posOfTimeDiff+2)
            if ($posOfTimeDiff2 -eq -1) { $fileContainsError = $true }
            else {
                $timeDiffInSecs_Str = $tmp.Substring( $posOfTimeDiff+2, $posOfTimeDiff2 - ($posOfTimeDiff+2) )
                
                if ( [int]::TryParse($timeDiffInSecs_Str, [ref] $timeDiffInSecs) ) {
                    $fileContainsError = $false
                    [int]$timeDiffInSecs = [System.Math]::Abs($timeDiffInSecs)
                }
                else {                    
                    $timeDiffInSecs = [int]::MaxValue
                }
            }
        }
    }

    if ($fileContainsError) {
        $tmp = GetFirstLineThatStartsWith (GetFileContentInSourceFolder TimeDiff_BtwMS_AndSQL.txt) "TotalSeconds"  
        if ( $tmp -eq $null ) {
            $timeDiffInSecs = [int]::MaxValue                    
        }
        else {
            $sourceNumberFormat = (GetFileContentInSourceFolder CurrentCulture.NumberFormat.csv) | ConvertFrom-Csv
            $posOfTimeDiff = $tmp.IndexOf(':')
            if ($posOfTimeDiff -eq -1) { $fileContainsError = $true }
            else {
                $posOfTimeDiff2 = $tmp.IndexOf( $sourceNumberFormat.NumberDecimalSeparator ,$posOfTimeDiff+1 )
                if ($posOfTimeDiff2 -eq -1) { $fileContainsError = $true }
                else {
                    $timeDiffInSecs_Str = $tmp.Substring( $posOfTimeDiff+1, $posOfTimeDiff2 - ($posOfTimeDiff+1) )
                
                    if ( [int]::TryParse($timeDiffInSecs_Str, [ref] $timeDiffInSecs) ) {
                        $fileContainsError = $false
                        [int]$timeDiffInSecs = [System.Math]::Abs($timeDiffInSecs)
                    }
                    else {
                        $timeDiffInSecs = [int]::MaxValue
                    }
                }
            }            
        }
    }

    if ($fileContainsError) {

        $MS_Utc = [datetime]::MinValue
        $SQL_Utc = [datetime]::MinValue

        $MS_Utc_Str = (GetFileContentInSourceFolder Get-UtcDate.txt).Trim()
        if ( [datetime]::TryParseExact($MS_Utc_Str,"yyyy-MM-dd__HH:mm.ss.fff", $null, [System.Globalization.DateTimeStyles]::None, [ref] $MS_Utc) ) {
            $SQL_Utc_Csv = ConvertFrom-Csv (GetSanitizedCsv (GetFileContentInSourceFolder SQL_Date.csv))
            $SQL_Utc_Str = $SQL_Utc_Csv.UtcTime
            if ( [datetime]::TryParseExact($SQL_Utc_Str,"yyyy-MM-dd__HH:mm.ss.fff", $null, [System.Globalization.DateTimeStyles]::None, [ref] $SQL_Utc) ) {
                
                $fileContainsError = $false
                $timeDiffInSecs = $MS_Utc.Subtract($SQL_Utc).TotalSeconds
                [int]$timeDiffInSecs = [System.Math]::Abs($timeDiffInSecs)
            }
            else {  $fileContainsError = $true  }         
        }
        else {  $fileContainsError = $true  } 
    }

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="Time diff between MS and SQL"
    $dataRow.RuleDesc="The time diff between the machine and the SQL box should be less than 5 minutes (<= 300 secs). $(GetAnchorForExternal 'https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/maximum-tolerance-for-computer-clock-synchronization#best-practices' 'Best Practice') "
    $dataRow.RuleResult="Actual: "
    if (IsSourceScsmMgmtServer) { $dataRow.SAPCategories = "s*\other" }
    if (IsSourceScsmDwMgmtServer) { $dataRow.SAPCategories = "dw\other" } 
    $dataRow.ProblemSeverity=[ProblemSeverity]::Warning

    if ($fileContainsError) {
        $dataRow.RuleResult = "Time diff between MS and SQL couldn't be measured from these files: $(CollectorLink TimeDiff_BtwMS_AndSQL.txt), $(CollectorLink TimeDiff_BtwMS_AndSQL_viaWin32tm.txt), $(CollectorLink Get-UtcDate.txt), $(CollectorLink SQL_Date.csv). <br/>$(IgnoreRuleIfText) no symptoms are happening that seem to be caused by Kerberos issues."
        $Result_Problems += $dataRow
    }
    elseif ($timeDiffInSecs -le 300) { 
        $dataRow.RuleResult += "$timeDiffInSecs seconds."
        $Result_OKs += $dataRow 
    }
    else {        
        $dataRow.RuleResult += "$timeDiffInSecs seconds! Time diff between MS and SQL is greater than 5 minutes! (Measured in these files: $(CollectorLink TimeDiff_BtwMS_AndSQL.txt), $(CollectorLink TimeDiff_BtwMS_AndSQL_viaWin32tm.txt), $(CollectorLink Get-UtcDate.txt), $(CollectorLink SQL_Date.csv)). <br/>$(IgnoreRuleIfText) no symptoms are happening that seem to be caused by Kerberos issues."
        $Result_Problems += $dataRow
    }
}

function Analyze_ForDWAndWFAndSecondary() {
#region DO NOT REMOVE THIS! Exit immediately if script does NOT run on a DW or WF or Secondary mgmt server.
if (-not (IsSourceAnyScsmMgmtServer)) {
    return
}
#endregion

 #Rules for All SCSM mgmt servers => WF + Secondary + DW

#region Not a rule: Get DB info to be used in subsequent rules. This applies to ServiceManager and DWStagingAndConfig as well.
    $linesIn_regValues = GetFileContentInSourceFolder SystemCenter.regValues.txt

    $MainSQL_InstanceName = GetFirstLineThatStartsWith $linesIn_regValues '"DatabaseServerName"="'    
    $MainSQL_InstanceName = $MainSQL_InstanceName.Split("=")[1].Replace('"','')
    $MainSQL_DbName = GetFirstLineThatStartsWith $linesIn_regValues '"DatabaseName"="'
    $MainSQL_DbName = $MainSQL_DbName.Split("=")[1].Replace('"','')
#endregion

    Check_CollectorsSqlPermission
    Check_MgmtServerHW
    Check_SQLServerHW
    Check_SqlBroker
    Check_SqlCLR
    Check_SPNs
    Check_OMSDK_Service
    Check_ConnectedSDKUsers
    Check_TimeDiffBetweenMSAndSQL
} 

function Analyze_ForPortal() {
#region DO NOT REMOVE THIS! Exit immediately if Portal is not installed.
if (-not (HasSourceScsmPortalInstalled)) {
    return
}
#endregion

 #Rules for SCSM Portal only 

#NotImplemented yet

}

function Analyze_ForSecondary() {
#region DO NOT REMOVE THIS! Exit immediately if script does NOT run on a Secondary mgmt server.
if (-not (IsSourceScsmSecondaryMgmtServer)) {
    return
}
#endregion

#Rules for SCSM Secondary MS only 

}

function Analyze_ForWF() {
#region DO NOT REMOVE THIS! Exit immediately if script does NOT run on a WF mgmt server.
if (-not (IsSourceScsmWfMgmtServer)) {
    return
}
#endregion

#Rules for SCSM WF server only 

    #Check_ExchangeConnectorFilesInSMInstallationFolder

}

function Check_ConnectorStatus() {
$dataRow = GetEmptyResultRow
    $dataRow.RuleName="Connector Status"
    $dataRow.RuleDesc=@"
Enabled connectors should have Status = 'Finished Success'. $(CollectorLink SQL_Connectors.csv)
"@
    $dataRow.RuleResult="Below are the Connectors which are enabled but have NOT completed with success. $(IgnoreRuleIfText) they were executing while Collector was running."
    $dataRow.SAPCategories = "Connector*" 
    $dataRow.ProblemSeverity=[ProblemSeverity]::Warning
    
    $linesIn_SQL_Connectors = ConvertFrom-Csv (GetSanitizedCsv ( GetFileContentInSourceFolder SQL_Connectors.csv) ) 
    $anyConnectorFailed = $false
    foreach($row in $linesIn_SQL_Connectors) {
        if ($row.Enabled -eq 'TRUE' -and $row.Status -ne 'Finished Success') {
            $dataRow.RuleResult += "<li>$($row.Name)</li>"
            $anyConnectorFailed = $true
        }
    }

    if (-not $anyConnectorFailed ) { 
        $dataRow.RuleResult="Connectors have completed successfully."
        $Result_OKs += $dataRow 
    }   
    else {
        $Result_Problems += $dataRow
    } 
 }

function Check_CustomRelationshipTypes() {
 $dataRow = GetEmptyResultRow
    $dataRow.RuleName="Custom Relationship Types"
    $dataRow.RuleDesc=@"
    Custom Relationship Types with MaxCardinality=1 Targets should be excluded, if they are really not needed. Otherwise, WFs can lag and Consoles can face slowness. Please correlate with 'ECL row count' rule.
<br/>More detailed info in the Appendix of this $(GetAnchorForExternal 'https://techcommunity.microsoft.com/t5/system-center-blog/troubleshooting-workflow-performance-and-delays/ba-p/347510' 'KB article.')
<br/>Query results are in $(CollectorLink SQL_TroubleshootingWorkflowPerformanceandDelays.csv)
"@
    $dataRow.SAPCategories = "wf*" 
    $dataRow.RuleResult = @"
    Non-excluded Custom Relationship Types have been found. Please correlate with 'ECL row count' rule, because ECL table can get bigger because of this issue. It has to be confirmed, if they really need to be excluded. If so, run the below SQL script to fix this issue.
    <br/>$(IgnoreRuleIfText) currently no WF slowness exists, but it's strongly recommended to fix this before getting into issues.<br/>
"@
    $dataRow.ProblemSeverity=[ProblemSeverity]::Error

    $linesIn_SQL_TroubleshootingWorkflowPerformanceandDelays = ConvertFrom-Csv (GetSanitizedCsv ( GetFileContentInSourceFolder SQL_TroubleshootingWorkflowPerformanceandDelays.csv) ) 
    $IncorrectRowcount = 0
    $itemsToInsert = ""
    foreach($row in $linesIn_SQL_TroubleshootingWorkflowPerformanceandDelays) {
        if ($row.CountOfSourcesForSameTarget -eq '!') {
            $itemsToInsert+=",('$($row.RelationshipTypeId)','$($row.RelatedEntityId)')<br/>" 
            $IncorrectRowcount++
        }
    }
    if ($IncorrectRowcount -gt 0) {
        $itemsToInsert = $itemsToInsert.Remove(0,1)
    }

    if ($IncorrectRowcount -eq 0) {
        $dataRow.RuleResult="No incorrect Custom Relationship Types found."
        $Result_OKs += $dataRow 
    }
    else {
        $dataRow.RuleResult += "<br/>INSERT INTO ExcludedRelatedEntityChangeLog (RelationshipTypeId, TargetTypeId) VALUES<br/> $itemsToInsert"
        $Result_Problems += $dataRow
    }
}

function Check_DelayedWorkflows_2019UR2Only() {

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="Delayed Workflows (2019 UR2 only)"
    $dataRow.RuleDesc=@"
Due to bug #829977, workflows are delayed because the MonitoringHost.exe process is intermittently crashing. Event ID 1026 is also logged in the event viewer together with UnauthorizedAccessException.
This only happens with 2019 UR2 where a stored procedure is causing this issue. A SQL script has been released to fix this stored procedure in the $(GetAnchorForExternal 'https://support.microsoft.com/en-us/topic/update-rollup-2-for-system-center-service-manager-2019-kb4558753-9211f013-33a5-fee4-ea18-d4c35befa831' 'UR2 article') 'Known issues in this update' section.
"@
    $dataRow.RuleResult="The stored procedure is fine. $(CollectorLink SQL_ForRFH_829977.csv)"
    $dataRow.SAPCategories = "wf*" 
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    $spIsCorrect = $false
    $spContent = (GetFileContentInSourceFolder SQL_ForRFH_829977.csv)
    [string]$contentToCheck = ( GetSubstringFromString $spContent '@SaclIsOn' '@RowCount' -includeEndingText $true )
    $contentToCheck = ( GetSubstringFromString $contentToCheck 'As' '@RowCount' )
    $contentToCheck = $contentToCheck.Replace("DECLARE","").Trim()

    if ([string]::IsNullOrWhiteSpace($contentToCheck)) { 
        $spIsCorrect = $true 
    }
    elseif ( $contentToCheck.StartsWith('/*') ){ 
        $spIsCorrect = $true 
    }

    if ($spIsCorrect ) { $Result_OKs += $dataRow }   
    else {        
        $dataRow.RuleResult = @"
The stored procedure $(CollectorLink SQL_ForRFH_829977.csv) seems to be wrong and is most likely causing workflows to be delayed.
The SQL script $(GetAnchorForExternal 'https://download.microsoft.com/download/3/d/5/3d54d436-3da9-4181-b74c-5a3031998657/Workaround_UnauthorizedAccessException.sql' 'SQL script workaround') needs to executed after applying UR2.
<br/><b>Important:</b> It is mandatory to run the workaround SQL script after applying UR2 onto the Primary (WF) management server. However, if UR2 is applied later onto Secondary management server(s) then the 'wrong' stored procedure will come back into the SM database.
Therefore, it's important to run the workaround SQL script <u>after</u> the last patched management server. It's OK to run the workaround SQL script several times.
"@
        $Result_Problems += $dataRow
    } 
}
 

function Check_ECLRowCount() {
[long]$tolerance_EclRowcountInMillions = 20

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="ECL row count"
    $dataRow.RuleDesc=@"
The EntityChangeLog (ECL) table should have < $tolerance_EclRowcountInMillions million rows. Otherwise, WFs can lag and Consoles can face slowness.
<br/>Row count for all tables are in $(CollectorLink SQL_TableSizeInfo.csv)
"@
    $dataRow.SAPCategories = "wf*" 
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    $linesIn_SQL_TableSizeInfo = ConvertFrom-Csv (GetSanitizedCsv ( GetFileContentInSourceFolder SQL_TableSizeInfo.csv) ) 
    [long]$EclRowcount = ($linesIn_SQL_TableSizeInfo | ? { ($_.Name -eq "[dbo].[EntityChangeLog]") -or ($_.Name -eq "EntityChangeLog") }).rows
    $dataRow.RuleResult="ECL rowcount is $(WithThousandSeparators $EclRowcount)."

    if ($EclRowcount -le $tolerance_EclRowcountInMillions*1000000) {
        $Result_OKs += $dataRow 
    }
    else {
        $Result_Problems += $dataRow
    }
}

function Check_GroomingAndPurging() {
 $dataRow = GetEmptyResultRow
    $dataRow.RuleName="Grooming and Purging"
    $dataRow.RuleDesc=@"
Data needs to be groomed and purged periodically. The table InternalJobHistory should have rows with StatusCode = 1.<br/>
In addition, grooming rules should run in their expected intervals. If not, WFs can lag and Consoles can face slowness. Please correlate with rule 'ECL row count' and overall SQL performance.
<br/>All info in $(CollectorLink SQL_InternalJobHistory.csv)
"@
    $dataRow.SAPCategories = "wf*"   
    $dataRow.ProblemSeverity=[ProblemSeverity]::Warning

    $anyIssuesFoundInGroomOrPurge = $false
    $dataRow.RuleResult="Commands which have problems in $(CollectorLink SQL_InternalJobHistory.csv):"

    $linesIn_SQL_InternalJobHistory = ConvertFrom-Csv (GetSanitizedCsv ( GetFileContentInSourceFolder SQL_InternalJobHistory.csv) ) 
    $isTheFirstRowInGroup = $true
    $groupNo = 1
    foreach ($groomRow in $linesIn_SQL_InternalJobHistory) {
        if ($groomRow.StatusCode -eq "StatusCode") {
            $isTheFirstRowInGroup = $true
            $groupNo++
            continue;
        }
        if ($isTheFirstRowInGroup) {
            $isTheFirstRowInGroup = $false

            if ($groomRow.StatusCode -ne "1") {
                $anyIssuesFoundInGroomOrPurge = $true
                $dataRow.RuleResult += "<li>$($groomRow.Command)</li>"
            }
            else {
                $groomIntervalInMinutes = 15
                if ($groupNo -ge 4) {
                    $groomIntervalInMinutes = 60*24 #daily
                } 
                [datetime]$lastGroomDateUtc = ParseSqlDate $groomRow.TimeFinished
                if ( $inputDateTimeUtc.Subtract($lastGroomDateUtc).TotalMinutes -gt ($groomIntervalInMinutes*2) ) { # we tolerate twice of the $groomIntervalInMinutes
                    $anyIssuesFoundInGroomOrPurge = $true
                    $dataRow.RuleResult += "<li>$($groomRow.Command)</li>"
                }                
            }
        }        
    }

    if (-not $anyIssuesFoundInGroomOrPurge) {
        $dataRow.RuleResult="Grooming and Purging are working fine."
        $Result_OKs += $dataRow 
    }
    else {
        $dataRow.RuleResult += "<br/><br/>$(IgnoreRuleIfText) there are no performance issues, however it is strongly suggest to fix this issue."
        $Result_Problems += $dataRow
    }
}

function Check_SqlCLRonRegisteredDWSql() {
# check if 'clr enabled' is 1 on the registered DW SQL instance

    $registeredDwInfo = ConvertFrom-Csv ( GetSanitizedCsv  ( GetFileContentInSourceFolder SQL_RegisteredDwInfo.csv ) )

    if ($registeredDwInfo.'DW mgmt server name' -eq $null) { # no DW registered, therefore no need to run this rule.
        return
    }

    $linesIn_SQL_sp_configure_FromRegisteredDwSQL = ConvertFrom-Csv  ( GetSanitizedCsv  ( GetFileContentInSourceFolder SQL_sp_configure_FromRegisteredDwSQL.csv ) '"xp_cmdshell' ) 
    [int]$clrEnabledOnRegisteredDwSQL = GetValueFromImportedCsv $linesIn_SQL_sp_configure_FromRegisteredDwSQL "name" "clr enabled" "run_value"

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="SQL CLR on registered DW/SQL"
    $dataRow.RuleDesc="CLR must be enabled on the registered Data Warehouse SQL instance. Otherwise, the Setup can fail or Console can crash, please check OperationsManager event log. The value of 'clr enabled' is in $(CollectorLink SQL_sp_configure_FromRegisteredDwSQL.csv)."
    $dataRow.RuleResult="Actual: $clrEnabledOnRegisteredDwSQL"
    if (IsSourceAnyScsmMgmtServer) { $dataRow.SAPCategories =  "Console\*", "SMConfPerf\SM Setup"}
    $dataRow.ProblemSeverity=[ProblemSeverity]::Critical

    if ($clrEnabledOnRegisteredDwSQL -eq 1) { $Result_OKs += $dataRow }
    else {            
        $dataRow.ProblemSeverity=[ProblemSeverity]::Critical
        $dataRow.RuleResult += @"
        <br/>Run the below with SQL admin permissions:<pre>        
        sp_configure 'clr enabled', 1
        go
        reconfigure<pre>
"@            
        $Result_Problems += $dataRow
    }
}

function Check_WorkflowsMinutesBehind() {
 $tolerance_MinutesBehind = 15

    $dataRow = GetEmptyResultRow
    $dataRow.RuleName="Workflows Minutes Behind"
    $dataRow.RuleDesc=@"
This rule checks if workflows are lagging for more than $tolerance_MinutesBehind minutes. More in this $(GetAnchorForExternal 'https://techcommunity.microsoft.com/t5/system-center-blog/troubleshooting-workflow-performance-and-delays/ba-p/347510' KB) article.
<br/>All WF lagging info is in $(CollectorLink SQL_WorkflowMinutesBehind.csv)
"@
    $dataRow.RuleResult="No workflows are lagging."
    $dataRow.SAPCategories = "wf*" 
    $dataRow.ProblemSeverity=[ProblemSeverity]::Error

    $WfMinutesBehindIsHigh = $true

    $linesIn_SQL_WorkflowMinutesBehind = ConvertFrom-Csv (GetSanitizedCsv ( GetFileContentInSourceFolder SQL_WorkflowMinutesBehind.csv ) ) 
    $max_MinutesBehind = [long]::MaxValue
    [long]::TryParse($linesIn_SQL_WorkflowMinutesBehind[0]."Minutes Behind", [ref] $max_MinutesBehind) | Out-Null
    $WfMinutesBehindIsHigh = ($max_MinutesBehind -gt $tolerance_MinutesBehind)

    if (-not $WfMinutesBehindIsHigh ) { 
        $dataRow.RuleResult += " Max minutes: $max_MinutesBehind"
        $Result_OKs += $dataRow 
    }   
    else {        
        $dataRow.RuleResult = @" 
        Looks like workflows are lagging for more than $max_MinutesBehind minutes. $(IgnoreRuleIfText) if a same 'lagging' rule exists in $(CollectorLink SQL_WorkflowMinutesBehind_Original.csv) with a lower Minutes Behind value.
"@
        $Result_Problems += $dataRow
    } 
}

function Analyze_ForWFAndSecondary() {
#region DO NOT REMOVE THIS! Exit immediately if script does NOT run on a WF or Secondary mgmt server.
if (-not (IsSourceScsmMgmtServer) ) {
    return
}
#endregion


 #Rules for WF + Secondary
 #Note: Despite that a secondary MS does not run the WFs, as WF related info was collected (from db) we are analyzing them here (as much as we can), too.

    Check_ECLRowCount
    Check_CustomRelationshipTypes
    Check_WorkflowsMinutesBehind
    Check_ConnectorStatus
    Check_GroomingAndPurging
    if ( $SCSM_Version -eq '10.19.1035.101' ) { Check_DelayedWorkflows_2019UR2Only }
    Check_SqlCLRonRegisteredDWSql
}

function Analyze($resultingZipFile_FullPath) {

#region Preferences about Analyzer behavior

$displaySapCategories = $false #todo: get feedback if this should be $true
$resultingZipFileName_ShouldHaveNewTime = $false  
#$compressTheResults = $false #todo: get feedback if this should be $true
$compressTheResults = $true #todo: get feedback if this should be $false
$removeCollectorResultZipFile = $false   #todo: get feedback if this should be $true
$useProtocolHandler_OpenDefAppByFileExt = $true   #todo
#$openFindingsHtmlAtTheEnd = $true
$openFindingsHtmlAtTheEnd = $false
$openCollectorFolderAtTheEnd = $false #todo: get feedback if this should be $true

$findingsHtml_FileName = "Findings.html"
$collector_FolderName = "Collector"
$analyzer_FolderName = "Analyzer"
$findingsPS1_FileName = "ShowTheFindings.ps1"
#endregion

#region initial tasks

#getting the result zip path of the Collector (even though the zip file does not exist!)
$collectorResultZipPath = $resultingZipFile_FullPath

$analyzerVersion = $toolVersion # "1.0.0.9"   
$minRequiredInputVersion = $toolVersion # "1.0.5.20"

# For accessibility
$errorForegroundColor="DarkGray"
$errorBackgroundColor="Black"
$host.privatedata.ErrorForegroundColor = $errorForegroundColor  

#PS Preferences
$PSDefaultParameterValues['out-file:width'] = 2000
$FormatEnumerationLimit = -1 #prevents truncation of column values if no fit
$ProgressPreference = 'SilentlyContinue'

# setting vars to handle input file
$inputPrefix =  "SCSM_DIAG"
$collectorStartingText = "(Please ignore any Warning and Errors)"
$collectorEndingText = "Collection completed at "
$analyzerStartingText = "Now running the Rules..."
$analyzerEndingText = "SCSM Diagnostic Tool completed at "

#region setting if DEBUG
if ($debugmode) {
    $useProtocolHandler_OpenDefAppByFileExt = $true
    $openCollectorFolderAtTheEnd = $false
    $removeCollectorResultZipFile = $false
    $compressTheResults = $false
}
#endregion

$telemetry = GetEmptyTelemetryRow

#region Preparing folders
    $telemetry.AnalysisID = (Split-Path -Path $collectorResultZipPath -Leaf).Replace(".zip","")
                        
    $resultFolderPath = Split-Path -Path $collectorResultZipPath
    if ($resultingZipFileName_ShouldHaveNewTime) {
        $resultPrefix = "SCSM_ANALYSIS_"
    }
    else {
        $resultPrefix = ""
    }
    $resultFolderName = "$($resultPrefix)"

    if ($resultingZipFileName_ShouldHaveNewTime) {
        $resultFolderName += (Get-Date).ToString("yyyy-MM-dd__HH.mm.ss.fff")    
    }
    else {
        $resultFolderName += (Split-Path -Path $collectorResultZipPath -Leaf).Replace(".zip","")
    }

    #now starting the rules...
    $telemetry.Start_DateTimeUtc = (Get-Date).ToUniversalTime()  #todo: this was actually set in GetEmptyTelemetryRow

    $resultFolder = Join-Path -Path $resultFolderPath -ChildPath "$resultFolderName\$analyzer_FolderName" 

    Start-Transcript -Path "$resultFolder\Transcript.txt" -NoClobber | Out-Null
    $startingDateTime = (Get-Date).ToString("yyyy-MM-dd__HH.mm.ss.fff")  
    Write-Host ""
    CopyFileToTargetFolder $scriptFilePath # -subFolderName $analyzer_FolderName

    $inputFolder = Join-Path ($resultFolder) "..\$collector_FolderName"
#endregion    

$inputVersion = GetFirstLine ( GetFileContentInSourceFolder CollectorVersion.txt )
#$telemetry.Abort_Reason = 0 #todo

$currentBackgroundColor = $host.UI.RawUI.BackgroundColor.ToString()
if ($currentBackgroundColor -eq "-1") { $currentBackgroundColor = "DarkBlue" }
Write-Host $analyzerStartingText -ForegroundColor $currentBackgroundColor #not to see in PS window but still in the transcript file

#region checking registry for $useProtocolHandler_OpenDefAppByFileExt
$useProtocolHandler_OpenDefAppByFileExt = $false
$reg_OpenDefAppByFileExt_UrlProtocolExists = Get-Item -Path 'Registry::HKEY_CLASSES_ROOT\OpenDefAppByFileExt' -ErrorAction Ignore
if ($reg_OpenDefAppByFileExt_UrlProtocolExists) {
    $reg_OpenDefAppByFileExt_UrlProtocolExists = $reg_OpenDefAppByFileExt_UrlProtocolExists.GetValueNames().Contains("URL Protocol") 

    $reg_OpenDefAppByFileExt_commandValue = (Get-ItemProperty -Path 'Registry::HKEY_CLASSES_ROOT\OpenDefAppByFileExt\shell\open\command'  -ErrorAction Ignore ).'(default)'
    if ($reg_OpenDefAppByFileExt_commandValue) {
        $reg_OpenDefAppByFileExt_commandExists = ( $reg_OpenDefAppByFileExt_commandValue.StartsWith('cmd.exe /C ') -and $reg_OpenDefAppByFileExt_commandValue.Contains('OpenDefAppByFileExt.ps1') )
        $useProtocolHandler_OpenDefAppByFileExt = ($reg_OpenDefAppByFileExt_UrlProtocolExists -and $reg_OpenDefAppByFileExt_commandExists)
    }
}
#endregion

#region prepare Beginning part of $findingsHtml_FileName
$imgNowExpanded = "data:image/svg+xml;base64,PHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgZm9jdXNhYmxlPSJmYWxzZSIgZGF0YS1wcmVmaXg9ImZhcyIgZGF0YS1pY29uPSJjaGV2cm9uLXVwIiBjbGFzcz0ic3ZnLWlubGluZS0tZmEgZmEtY2hldnJvbi11cCBmYS13LTE0IiByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDQ0OCA1MTIiPjxwYXRoIGZpbGw9ImN1cnJlbnRDb2xvciIgZD0iTTI0MC45NzEgMTMwLjUyNGwxOTQuMzQzIDE5NC4zNDNjOS4zNzMgOS4zNzMgOS4zNzMgMjQuNTY5IDAgMzMuOTQxbC0yMi42NjcgMjIuNjY3Yy05LjM1NyA5LjM1Ny0yNC41MjIgOS4zNzUtMzMuOTAxLjA0TDIyNCAyMjcuNDk1IDY5LjI1NSAzODEuNTE2Yy05LjM3OSA5LjMzNS0yNC41NDQgOS4zMTctMzMuOTAxLS4wNGwtMjIuNjY3LTIyLjY2N2MtOS4zNzMtOS4zNzMtOS4zNzMtMjQuNTY5IDAtMzMuOTQxTDIwNy4wMyAxMzAuNTI1YzkuMzcyLTkuMzczIDI0LjU2OC05LjM3MyAzMy45NDEtLjAwMXoiPjwvcGF0aD48L3N2Zz4="
$imgNowCollapsed = "data:image/svg+xml;base64,PHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgZm9jdXNhYmxlPSJmYWxzZSIgZGF0YS1wcmVmaXg9ImZhcyIgZGF0YS1pY29uPSJjaGV2cm9uLWRvd24iIGNsYXNzPSJzdmctaW5saW5lLS1mYSBmYS1jaGV2cm9uLWRvd24gZmEtdy0xNCIgcm9sZT0iaW1nIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NDggNTEyIj48cGF0aCBmaWxsPSJjdXJyZW50Q29sb3IiIGQ9Ik0yMDcuMDI5IDM4MS40NzZMMTIuNjg2IDE4Ny4xMzJjLTkuMzczLTkuMzczLTkuMzczLTI0LjU2OSAwLTMzLjk0MWwyMi42NjctMjIuNjY3YzkuMzU3LTkuMzU3IDI0LjUyMi05LjM3NSAzMy45MDEtLjA0TDIyNCAyODQuNTA1bDE1NC43NDUtMTU0LjAyMWM5LjM3OS05LjMzNSAyNC41NDQtOS4zMTcgMzMuOTAxLjA0bDIyLjY2NyAyMi42NjdjOS4zNzMgOS4zNzMgOS4zNzMgMjQuNTY5IDAgMzMuOTQxTDI0MC45NzEgMzgxLjQ3NmMtOS4zNzMgOS4zNzItMjQuNTY5IDkuMzcyLTMzLjk0MiAweiI+PC9wYXRoPjwvc3ZnPg=="
$imgThumpsUp = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAABZlJREFUaEPNWltsFGUU/s4/uzR4DaIogUSpgkRJ2W2BYnygmiiJiWF3IS2oBF8AoaVbEMQn00QFE6DdXUVt8MF4gRSls6iJGh948QIl7RaMUkjVqBCw3Aq0QLu7c8xMO7WXnZ1/trtr962d83/n+845e+bMmSVk4TN//+774hMSTxK4lJhna5pSSKRNZsJtOjwxupnFRSGSvzNRO1gcdsWVQ0fLK8+N1T1lCrCg6Z3JcWjPM2krCTQvQ5yjAD52s7K3OVB1MRMMxwKKDkSmuwRv1phXE9EtmTgddUZDDwvewy5t57FnN51xgiktoKShwZ2ccnM9gd8AyCiNbH+Y+bog2nG1gLZ3PFPdK4MvJaDoYOhhReNGQMyVAR2zDaNNg1JxLFB1yg7LVoBXDS0F8GGuom5FkBnXhMCqVl9QTScirQCPGnkRzHuI4LKLRC6uMzhJTFWxQPB9K3xLAcXRyFpmtjyYC8JpMKtj/uDbqa6nFKCXDQONBFLyTDSlOz0TAC9r82+MjjQYJaD4YN1DWlK0ENEd44H8fxy4WySV+S3LNrQP5TVMwCP7aycUuO9szlu3cRghAseoc2Jpy9q1cfPoMAHeptCrINruEDev5kzY0uYL7hwlYO6XddNEn3ISArfmlZFjZ9wtNJ7VsnTjWf3oYAaK1XCIgaBjvP/nQF3MH3x5UIA+mPUh8VfWZpsMROmRnOhy43pisLytUTT0uEm5Xx8AjQx4myLVIA5n4DcrR3QSrxQtQtnUQqz+vgmne67Y4hKjqjUQ3G0I8Kiho2MYiW2d2Y0COvmKwv4x658b12RFNMf8wVIqOVA/VSM6AyLbuWhMTFMcNiNvkjdNpEQwc1zBVPJEw88R49Nsk7PD08lvnVuG8hlFKU2/+vsEXmv5Li0MES8nbzQUBlO1ncNsXreKvOnjRFcn1v2g4mo8/SMBg0NUrNZ/yxBPZ5Ogk5ofaStLvv8cf00eNfwbAYWyAkrunob2rvPoSfTJHhm0syubny+dQ+VPUXTH5bBZow7yqmH9YfouGTZPTZuJbfMW49SVC1IpHoqZrbIZismMC7oAvdAm2AkwySskDFMnqc4F+f4K4l4pAYunz8KbJYshRnRaPeXrf4ymLadsl82wQA8IsC2h4KOPY9XMkpRJSicip+SNBOACedRQB4EetOscW4oWYfnA3VKmc+SsbIY4N77Esm1UJyQrIh/kB9uokxuZjAj9O/HS7NLB2UYmW3YNxOq6cSPzqpEVAO+VBbGr68u9NzCpYKLl98VJn7fjREAFzTkYutedxFknw5xdJlI5dtJ27YgPtND+YU7/w6uGmwHMlzo4YORERNbJA9CIDx/z1TxmCtgAIOJEgG4rIyIX5I17GHFlm6/mXUOAsevn5J+ZPNCnE5Er8hj5SKmL8KihegLVOM2CVSZyRt4gSLti/urNpm/jX2NdqwzNRC7J61trd8I1y3w9NXyxFY1sBfNbmWTBjEbggTn45vSpjMZtOb+8Oeav2WXaDhOgv4XhKTeOMMgrB5ZvK2oVnQULLVeLOp3xvNxNCsw7vqTm5NCwpdxEFEfDfo35s/G0XieBQGxJzRcjc265SilWw2sYaMh3kYzyx8wsaE2bL/hBKi5pd0Hj4RWTIFHZ6qu2DKTtMsuj1vvA4iMi3J7PbDDzVVKwMlXZ2H4HRhL1fB6eKRRuzF93olYSiYrWJZs67IJmmwEToOxQraura1IlGK/nKhvmi+6b8cvbfi2vldqtSAswhei71CSJLcRYk8nslDKiGnog0OCKu3Y4/QGIYwEmAX0ATFBihabRC0S8wMnzhIHBzJrAEUWjT3oTyX2/lG+6ZFcujruQLGBR03tTXKL3CY2xkAmzFY1mMOEeoP/nNgC6iXE+KfgPYrQLwuGEVnDoeGBdp6wPK7t/AUlevUYaHW1LAAAAAElFTkSuQmCC"

$findings_Part0 = @'
<html><head><style>
table { border-collapse: collapse; } 	
th, td { padding: 4px; text-align: left; border: 1px solid black; } 	
tr:hover {background-color: #EFDEDE;} 	
p {margin-top:50px;}	
h2 {color: black}

.table-header {   background-color: #11594A; color:white; }	
.table-header-critical {   	background-color: #FF6900; color: #000000; }	
.table-header-error {   	background-color: #FFC000; color: #000000; }
.table-header-warning {   	background-color: lightblue; color: #000000; }
.table-header-unclassified {background-color: #08B3CC; color: #000000; }
.table-header-passedRule {  background-color: #006400; color: #FFFFFF; }	

.critical-info { 	background-color: red; 	color: yellow; } 	
.error-info { 	background-color: orange; 	color: white; } 	
.warning-info { 	background-color: yellow; 	color: black; } 	
.ok-info { 	background-color: green; 	color: white; } 

.table-col-hide {display: none;}

</style>
'@
$findings_Part0 += @"
<script>
  function getCollectorUrl() {
		var wholeUrl = window.location.toString();
		var hashPart = window.location.hash.toString();
		var partToReplace = '$findingsHtml_FileName' + hashPart
		var collectorFolderName = '../$collector_FolderName'
		var newValue = wholeUrl.replace(partToReplace,collectorFolderName)        
        return newValue;
    }
  function getAnalyzerUrl() {
		var wholeUrl = window.location.toString();
		var hashPart = window.location.hash.toString();
		var partToReplace = '$findingsHtml_FileName' + hashPart
		var analyzerFolderName = './'
		var newValue = wholeUrl.replace(partToReplace,analyzerFolderName)        
        return newValue;
    }
    function toggleElement(elem) {

        var x = document.getElementById(elem);

        if (x.style.display === "none") {
            x.style.display = "block";
            x.previousSibling.childNodes[0].src = "$imgNowExpanded";
        } else {
            x.style.display = "none";
            x.previousSibling.childNodes[0].src = "$imgNowCollapsed";
        }
    }

</script>

</head><body>
"@
if ($displaySapCategories) {
    $findings_Part0 = $findings_Part0.Replace(".table-col-hide {display: none;}","");
}
AppendOutputToFileInTargetFolder $findings_Part0 $findingsHtml_FileName 

$findings_PartH1 = @'
<h1 style="color:black; text-align:center">SCSM Diagnostic Tool</h1>
'@
AppendOutputToFileInTargetFolder $findings_PartH1 $findingsHtml_FileName 

#endregion

#endregion

#region Get SM env info
#region init for Sm env info
$smEnvInfoRows = @()
#endregion

#region Get SM version

#region Populate some known SM versions
$SCSM_Versions = @{}
$SCSM_Versions.Add("10.22.1068.0","2022 RTM")
$SCSM_Versions.Add("10.19.1035.137","2019 UR4")
$SCSM_Versions.Add("10.19.1035.101","2019 UR2")
$SCSM_Versions.Add("10.19.1035.73","2019 UR1")
$SCSM_Versions.Add("10.19.1035.0","2019 RTM")
$SCSM_Versions.Add("7.5.7487.0","2016 RTM")
$SCSM_Versions.Add("7.5.7487.37","2016 UR2")
$SCSM_Versions.Add("7.5.7487.64","2016 UR3")
$SCSM_Versions.Add("7.5.7487.89","2016 UR4")
$SCSM_Versions.Add("7.5.7487.130","2016 UR5")
$SCSM_Versions.Add("7.5.7487.161","2016 UR7")
$SCSM_Versions.Add("7.5.7487.176","2016 UR8")
$SCSM_Versions.Add("7.5.7487.210","2016 UR9")
$SCSM_Versions.Add("7.5.7487.231","2016 UR10")
$SCSM_Versions.Add("7.5.3079.0","2012 R2 RTM")
$SCSM_Versions.Add("7.5.3079.61","2012 R2 UR2")
$SCSM_Versions.Add("7.5.3079.148","2012 R2 UR3")
$SCSM_Versions.Add("7.5.3079.236","2012 R2 UR4")
$SCSM_Versions.Add("7.5.3079.315","2012 R2 UR5")
$SCSM_Versions.Add("7.5.3079.367","2012 R2 UR6")
$SCSM_Versions.Add("7.5.3079.402","2012 R2 UR6.Hotfix")
$SCSM_Versions.Add("7.5.3079.442","2012 R2 UR7")
$SCSM_Versions.Add("7.5.3079.607","2012 R2 UR9")
$SCSM_Versions.Add("7.5.3079.768","2012 R2 UR14")
#endregion

#$linesIn_SCSM_Version = GetLinesFromString (GetFileContentInSourceFolder_WithAbort SCSM_Version.txt)
$linesIn_SCSM_Version = GetLinesFromString (GetFileContentInSourceFolder SCSM_Version.txt)
$searchStrForSCSMProduct = 'Microsoft System Center Service Manager'  #that should work for 2016+
$lineIn_SCSM_Version = $linesIn_SCSM_Version | Select-String -Pattern $searchStrForSCSMProduct -SimpleMatch | Out-String

if ( [string]::IsNullOrWhiteSpace($lineIn_SCSM_Version) ) {
    $searchStrForSCSMProduct = 'Microsoft System Center 2016 Service Manager'
    $lineIn_SCSM_Version = $linesIn_SCSM_Version | Select-String -Pattern $searchStrForSCSMProduct -SimpleMatch | Out-String
}
if ( [string]::IsNullOrWhiteSpace($lineIn_SCSM_Version) ) {
    $searchStrForSCSMProduct = 'Microsoft System Center 2012 R2 Service Manager'
    $lineIn_SCSM_Version = $linesIn_SCSM_Version | Select-String -Pattern $searchStrForSCSMProduct -SimpleMatch | Out-String
}
if ( [string]::IsNullOrWhiteSpace($lineIn_SCSM_Version) ) {
    $searchStrForSCSMProduct = 'Microsoft System Center 2012 - Service Manager'
    $lineIn_SCSM_Version = $linesIn_SCSM_Version | Select-String -Pattern $searchStrForSCSMProduct -SimpleMatch | Out-String
}

$SCSM_Version = $lineIn_SCSM_Version.Replace($searchStrForSCSMProduct,'').Trim()

if (-not (Is4PartVersionValid $SCSM_Version) ) {
    #region try reading from SCSM_Version.csv, if exists
        if (Test-Path (GetFileNameInSourceFolder SCSM_Version.csv) ) {
            $linesIn_SCSM_Version = ConvertFrom-Csv (GetFileContentInSourceFolder SCSM_Version.csv)
            $SCSM_Version = GetValueFromImportedCsv $linesIn_SCSM_Version Publisher "Microsoft Corporation" DisplayVersion
        }
    #endregion
}

$SCSM_VersionUserFriendly = $SCSM_Version
if ( [string]::IsNullOrWhiteSpace( $SCSM_Versions[$SCSM_Version] ) ) {
    $SCSM_VersionUserFriendly += " found in $(CollectorLink SCSM_Version.txt). Check here for old $(GetAnchorForExternal 'https://social.technet.microsoft.com/wiki/contents/articles/4226.system-center-service-manager-list-of-build-numbers.aspx' 'Versions')"
}
else {
    $SCSM_VersionUserFriendly += " ($($SCSM_Versions[$SCSM_Version]))"
}

$smEnvRow=GetEmptySmEnvRow
$smEnvRow.SmEnvInfo="Version"
$smEnvRow.SMEnvValue=$SCSM_VersionUserFriendly
$smEnvInfoRows += $smEnvRow
#endregion
#region Detect components like WF, DW, 2ndMS, Portal etc.
#$linesIn_ScsmRolesFound = GetFileContentInSourceFolder_WithAbort ScsmRolesFound.txt
$linesIn_ScsmRolesFound = GetFileContentInSourceFolder ScsmRolesFound.txt
$ScsmRolesFound = @() #bcz a machine can host multiple roles like mgmt server + Console
if ($linesIn_ScsmRolesFound.Contains("Primary/Workflow")) {$ScsmRolesFound += "WF"}
if ($linesIn_ScsmRolesFound.Contains("Secondary")) {$ScsmRolesFound += "2ndMS"}
if ($linesIn_ScsmRolesFound.Contains("DW")) {$ScsmRolesFound += "DW"}

if ($ScsmRolesFound.Length -eq 0) {
    $ScsmRolesFound += "UNK"
}
$telemetry.MainComponent = $ScsmRolesFound[0]
$smEnvRow=GetEmptySmEnvRow
$smEnvRow.SmEnvInfo="Component detected"
$smEnvRow.SMEnvValue=$ScsmRolesFound
$smEnvInfoRows += $smEnvRow
#endregion
#region Get Computer Name
$Scsm_ComputerName = ""
$EnvVars1 = Import-Csv (GetFileNameInSourceFolder EnvVars.csv)
$Scsm_ComputerName = GetValueFromImportedCsv $EnvVars1 "Key" "COMPUTERNAME" "Value"

$smEnvRow=GetEmptySmEnvRow
$smEnvRow.SmEnvInfo="Computer Name"
$smEnvRow.SMEnvValue=$Scsm_ComputerName
$smEnvInfoRows += $smEnvRow
#endregion
#region Get Computer FQDN Name
$Scsm_ComputerFqdnName = ""
$Scsm_ComputerFqdnName = GetFirstLine ( GetFileContentInSourceFolder Hostname_fqdn.txt )
if ( $Scsm_ComputerFqdnName -eq "") {
    $EnvVars1 = Import-Csv (GetFileNameInSourceFolder EnvVars.csv)
    $Scsm_ComputerFqdnName = GetValueFromImportedCsv $EnvVars1 "Key" "USERDNSDOMAIN" "Value"
    $Scsm_ComputerFqdnName = "$Scsm_ComputerName.$Scsm_ComputerFqdnName"
}
$smEnvRow=GetEmptySmEnvRow
$smEnvRow.SmEnvInfo="Computer FQDN Name"
$smEnvRow.SMEnvValue=$Scsm_ComputerFqdnName
$smEnvInfoRows += $smEnvRow
#endregion
#region Get Time with TZ
$smEnvRow=GetEmptySmEnvRow
$smEnvRow.SmEnvInfo="Computer local Time + TZ"
$smEnvRow.SMEnvValue= GetLinesFromString (GetFileContentInSourceFolder Get-Date.txt)
$smEnvInfoRows += $smEnvRow
#endregion
#region Get OS Info + Locale
$smEnvRow=GetEmptySmEnvRow
$smEnvRow.SmEnvInfo="OS Info"
$msinfo32Content = GetFileContentInSourceFolder msinfo32.txt
[string]$tmp = GetFirstLineThatStartsWith $msinfo32Content "OS Name`t" -doTrim $false
if ($tmp -eq $null) {
    $smEnvRow.SMEnvValue = "?"
}
else {
    $smEnvRow.SMEnvValue = $tmp.Replace("OS Name`t","")
}
$smEnvRow.SMEnvValue += "<br/>Locale: "
[string]$tmp = GetFirstLineThatStartsWith $msinfo32Content "Locale`t" -doTrim $false
if ($tmp -eq $null) {
    $smEnvRow.SMEnvValue += "?"
}
else {
    $smEnvRow.SMEnvValue += $tmp.Replace("Locale`t","")
}

$smEnvRow.SMEnvValue += "<br/>More in $(CollectorLink msinfo32.txt)"
$smEnvInfoRows += $smEnvRow
#endregion
#region Get SQL Info
$smEnvRow=GetEmptySmEnvRow
$smEnvRow.SmEnvInfo="SQL Server Info"
$linesIn_SQL_Info = GetLinesFromString( GetFileContentInSourceFolder SQL_Info.csv )
if ($linesIn_SQL_Info.Count -lt 1) {
    $smEnvRow.SMEnvValue = "?"
}
else {
    $smEnvRow.SMEnvValue = $linesIn_SQL_Info[1].Substring(1)
}
$smEnvRow.SMEnvValue += "<br/>More in $(CollectorLink SQL_Info.csv)"
$smEnvInfoRows += $smEnvRow
#endregion
#endregion

#region set Culture specific stuff
    $inputDateTimeUtcString = (GetFileContentInSourceFolder Get-UtcDate.txt).Trim()    
    [datetime]$inputDateTimeUtc = [datetime]::ParseExact($inputDateTimeUtcString.Trim(), "yyyy-MM-dd__HH:mm.ss.fff", $null)
    $inputDateTimeString = (GetFileContentInSourceFolder Get-Date.txt).Trim()    
    [datetime]$inputDateTime = [datetime]::ParseExact($inputDateTimeString.Trim(), "yyyy-MM-dd__HH:mm.ss.fff zzz", $null)
    
    #the below will be used later in Number and Date operations
    $sourceDateTimeFormat = (GetFileContentInSourceFolder CurrentCulture.DateTimeFormat.csv) | ConvertFrom-Csv
    $sourceNumberFormat = (GetFileContentInSourceFolder CurrentCulture.NumberFormat.csv) | ConvertFrom-Csv
#endregion

#region Init before running rules   
New-Variable -Name Result_Problems -Value @() -Force -Option AllScope
New-Variable -Name Result_OKs -Value @() -Force -Option AllScope

    #region set SAP Categories
    $SAPCategories = @()  
    #region SAP list for Administrator Console Issues
    $pr= [cProblemCategory]::new("Console","Administrator Console Issues", $null)
    $SAPCategories += $pr
        $SAPCategories += [cProblemCategory]::new("Console\Connectivity", "Administrator Console Issues\Connection failure issues", $pr);
        $SAPCategories += [cProblemCategory]::new("Console\Display Driver", "Administrator Console Issues\Display driver issues", $pr);
        $SAPCategories += [cProblemCategory]::new("Console\Other", "Administrator Console Issues\Other", $pr);
        $SAPCategories += [cProblemCategory]::new("Console\Usage", "Administrator Console Issues\Usage issues", $pr);
    #endregion  
    #region SAP list for Authoring     #ignored because Analyzer does not handle Authoring issues (for now)
    #$pr= [cProblemCategory]::new("Authoring","Authoring", $null)    
    #endregion
    #region SAP list for Connectors
    $pr= [cProblemCategory]::new("Connector","Connectors", $null)
    $SAPCategories += $pr
        $SAPCategories += [cProblemCategory]::new("Connector\AD", "Connectors\Active Directory Connector", $pr);
        $SAPCategories += [cProblemCategory]::new("Connector\SCCM", "Connectors\Configurations Manager Connector", $pr);
        $SAPCategories += [cProblemCategory]::new("Connector\CSV Import", "Connectors\CSV import", $pr);
        $SAPCategories += [cProblemCategory]::new("Connector\Exch", "Connectors\Exchange Connector", $pr);
        $SAPCategories += [cProblemCategory]::new("Connector\SCOM Alert", "Connectors\Operations Manager Alert Connector", $pr);
        $SAPCategories += [cProblemCategory]::new("Connector\SCOM CI", "Connectors\Operations Manager Configuration Item (CI) Connector", $pr);
        $SAPCategories += [cProblemCategory]::new("Connector\SCO", "Connectors\Orchestrator Connector", $pr);
        $SAPCategories += [cProblemCategory]::new("Connector\Other", "Connectors\Other", $pr);
        $SAPCategories += [cProblemCategory]::new("Connector\VMM", "Connectors\Virtual Machine Manager Connector", $pr);
    #endregion
    #region SAP list for Data Warehouse and Reporting
    $pr= [cProblemCategory]::new("DW","Data Warehouse and Reporting", $null)
    $SAPCategories += $pr
        $SAPCategories += [cProblemCategory]::new("DW\Reg", "Data Warehouse and Reporting\Data warehouse registration or unregistration", $pr);
        $SAPCategories += [cProblemCategory]::new("DW\Perf", "Data Warehouse and Reporting\DW Server performance", $pr);
        $SAPCategories += [cProblemCategory]::new("DW\ETL", "Data Warehouse and Reporting\Extract, transform, and load job", $pr);
        $SAPCategories += [cProblemCategory]::new("DW\MPSyncJob", "Data Warehouse and Reporting\MPSyncJob", $pr);
        $SAPCategories += [cProblemCategory]::new("DW\Cube", "Data Warehouse and Reporting\Online analytical processing (OLAP) cube", $pr);
        $SAPCategories += [cProblemCategory]::new("DW\Other", "Data Warehouse and Reporting\Other", $pr);
        $SAPCategories += [cProblemCategory]::new("DW\Report", "Data Warehouse and Reporting\Reporting", $pr);
    #endregion
    #region SAP list for Self-Service Portal
    $pr= [cProblemCategory]::new("SSP","Self-Service Portal", $null)
    $SAPCategories += $pr        
        $SAPCategories += [cProblemCategory]::new("SSP\Activity", "Self-Service Portal\Activities issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Announcement", "Self-Service Portal\Announcement issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Certificate", "Self-Service Portal\Certificate issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Approval", "Self-Service Portal\Change approval issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Client Conf", "Self-Service Portal\Client configuration issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Clients", "Self-Service Portal\Clients", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Submit", "Self-Service Portal\Incident creation issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\KB", "Self-Service Portal\Knowledge Base article issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Other", "Self-Service Portal\Other", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Customization", "Self-Service Portal\Portal customization issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Perf", "Self-Service Portal\Portal performance", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Portals", "Self-Service Portal\Portals", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\RO", "Self-Service Portal\Request offering", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\RB", "Self-Service Portal\Runbook integration", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\SO", "Self-Service Portal\Service offering", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\SW Prov", "Self-Service Portal\Software provisioning issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SSP\Website", "Self-Service Portal\Website issues", $pr);
    #endregion
    #region SAP list for Service Manager Components
    $pr= [cProblemCategory]::new("SMComp","Service Manager Components", $null)
    $SAPCategories += $pr
        $SAPCategories += [cProblemCategory]::new("SMComp\Activities", "Service Manager Components\Activities issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\Business Services", "Service Manager Components\Business Services or service maps", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\CR", "Service Manager Components\Change request issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\CI", "Service Manager Components\Configuration items issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\Connector", "Service Manager Components\Connector issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\Grooming", "Service Manager Components\Grooming issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\IR", "Service Manager Components\Incident issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\KA", "Service Manager Components\Knowledge article issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\MP", "Service Manager Components\Management pack issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\Notification", "Service Manager Components\Notification issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\Other", "Service Manager Components\Other", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\PR", "Service Manager Components\Problem management issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\Related Items", "Service Manager Components\Related items issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\Task", "Service Manager Components\Task issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\Template", "Service Manager Components\Template issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMComp\Workflow", "Service Manager Components\Workflow issues", $pr);
    #endregion
    #region SAP list for Service Manager Configuration and Performance
    $pr= [cProblemCategory]::new("SMConfPerf","Service Manager Configuration and Performance", $null)
    $SAPCategories += $pr
        $SAPCategories += [cProblemCategory]::new("SMConfPerf\Console Setup", "Service Manager Configuration and Performance\Administrator Console setup issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMConfPerf\DW", "Service Manager Configuration and Performance\Data warehouse setup issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMConfPerf\DCM", "Service Manager Configuration and Performance\Desired Configuration Management (DCM) issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMConfPerf\Other", "Service Manager Configuration and Performance\Other", $pr);
        $SAPCategories += [cProblemCategory]::new("SMConfPerf\Perf", "Service Manager Configuration and Performance\Performance issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMConfPerf\Security", "Service Manager Configuration and Performance\Security", $pr);
        $SAPCategories += [cProblemCategory]::new("SMConfPerf\SM Setup", "Service Manager Configuration and Performance\Service Manager setup issues", $pr);
        $SAPCategories += [cProblemCategory]::new("SMConfPerf\SSP Setup", "Service Manager Configuration and Performance\Web Portal setup issues", $pr);
    #endregion
    #region SAP list for Setup and Disaster Recovery
    $pr= [cProblemCategory]::new("SetupDR","Setup and Disaster Recovery", $null)
    $SAPCategories += $pr
        $SAPCategories += [cProblemCategory]::new("SetupDR\Admin", "Setup and Disaster Recovery\Administration space", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Authentication", "Setup and Disaster Recovery\Authentication", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Authoring Tool", "Setup and Disaster Recovery\Authoring Tool deployment", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Console crash", "Setup and Disaster Recovery\Console crash", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\DW cmdlet", "Setup and Disaster Recovery\Data warehouse cmdlet", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\DW install", "Setup and Disaster Recovery\Data warehouse server deployment", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\DR", "Setup and Disaster Recovery\Disaster recovery", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Encryption keys", "Setup and Disaster Recovery\Encryption keys", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Standalone Component Installer", "Setup and Disaster Recovery\Standalone Component Installer", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Installation: Unified Installer", "Setup and Disaster Recovery\Installation: Unified Installer", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Other", "Setup and Disaster Recovery\Other", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Partner solutions", "Setup and Disaster Recovery\Partner solutions", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\SSP install", "Setup and Disaster Recovery\Portal deployment", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Run As account", "Setup and Disaster Recovery\Run As account", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Security role", "Setup and Disaster Recovery\Security role", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Service crash", "Setup and Disaster Recovery\Service crash", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\SM cmdlet", "Setup and Disaster Recovery\Service Manager cmdlet", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Console install", "Setup and Disaster Recovery\Service Manager Console deployment", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Console Perf", "Setup and Disaster Recovery\Service Manager Console performance", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\SM install", "Setup and Disaster Recovery\Service Manager Server deployment", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\Slow SDK startup", "Setup and Disaster Recovery\Slow Data Access Service startup", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\DB Perf", "Setup and Disaster Recovery\SQL Server performance", $pr);
        $SAPCategories += [cProblemCategory]::new("SetupDR\SharePoint SSP WCS install", "Setup and Disaster Recovery\Web Content Server deployment", $pr);
    #endregion
    #region SAP list for Workflows
    $pr= [cProblemCategory]::new("WF","Workflows", $null)
    $SAPCategories += $pr
        $SAPCategories += [cProblemCategory]::new("WF\CR", "Workflows\Change management", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\Chargeback", "Workflows\Chargeback", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\CI", "Workflows\Configuration management", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\Duplicate emails", "Workflows\Duplicate email notification", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\IR", "Workflows\Incident management", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\MS Perf", "Workflows\Management Server performance", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\Notification templates", "Workflows\Notification templates", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\PR", "Workflows\Problem management", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\RR", "Workflows\Release management", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\SLA", "Workflows\Service level management", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\SR", "Workflows\Service requests", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\SMTP conf", "Workflows\SMTP channel", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\Conf", "Workflows\Workflow configuration", $pr);
        $SAPCategories += [cProblemCategory]::new("WF\Perf", "Workflows\Workflow performance", $pr);
    #endregion
    #endregion 
[cSAPCategoryHelper]::SAPCategoryList = $SAPCategories

#endregion

    Analyze_Rules

#region Writing Findings.html

#region write FindingsAtAGlance
$writeSummaryOfFindings = $false # KH: Stopped to show this to prevent noise in $findingsHtml_FileName
if ($writeSummaryOfFindings) {
 #region Findings By Severity
$findings_FindingsBySeverity_Top = @'
<p><h2>Findings by Severity</h2><table>
<tr><th class="table-header">Severity</th><th class="table-header">Count</th></tr>
'@
AppendOutputToFileInTargetFolder $findings_FindingsBySeverity_Top $findingsHtml_FileName 

$findings_FindingsBySeverity_Rows = @'
<tr><td class="critical-info">Critical Errors</td><td><a href="#Critical">|CriticalErrors|</a></td></tr>
<tr><td class="error-info">Error</td><td><a href="#Errors">|Errors|</a></td></tr>
<tr><td class="warning-info">Warning</td><td><a href="#Warnings">|Warnings|</a></td></tr>
<tr><td class="ok-info">OKs</td><td><a href="#OKs">|OKs|</a></td></tr>
'@
$findings_FindingsBySeverity_Rows = $findings_FindingsBySeverity_Rows.Replace("|CriticalErrors|", $Result_CriticalErrors.Count.ToString()).Replace("|Errors|", $Result_Errors.Count.ToString()).Replace("|Warnings|",$Result_Warnings.Count.ToString()).Replace("|OKs|",$Result_OKs.Count.ToString())
AppendOutputToFileInTargetFolder $findings_FindingsBySeverity_Rows $findingsHtml_FileName 

$findings_FindingsBySeverity_Bottom = @'
</table></p>
'@
AppendOutputToFileInTargetFolder $findings_FindingsBySeverity_Bottom $findingsHtml_FileName 
 #endregion

 #region Findings By ProblemCategory
$findings_FindingsByProblemCategory_Top = @'
<p><h2>Findings by Problem Scope</h2><table>
<tr><th class="table-header">Scope</th><th class="table-header">Count</th></tr>
'@
AppendOutputToFileInTargetFolder $findings_FindingsByProblemCategory_Top $findingsHtml_FileName 

$findings_FindingsByProblemCategory_Rows = ''
$ProblemCategoryNames = [ProblemCategory].GetEnumNames() 

foreach ($ProblemCategoryName in $ProblemCategoryNames) {
    $scopeCount = $Result_Problems.Where( {
        $_.ProblemCategory.ToString() -eq $ProblemCategoryName
    } ).Count
    $scopeCount = if ($scopeCount -eq 0) {""} else {$scopeCount.ToString()}
    $findings_FindingsByProblemCategory_Rows += '<tr><td>'+ $ProblemCategoryName +'</td><td>'+ $scopeCount +'</td></tr>'
}

$findings_FindingsByProblemCategory_Rows = $findings_FindingsByProblemCategory_Rows.Replace("|CriticalErrors|", $Result_CriticalErrors.Count.ToString()).Replace("|Errors|", $Result_Errors.Count.ToString()).Replace("|Warnings|",$Result_Warnings.Count.ToString()).Replace("|OKs|",$Result_OKs.Count.ToString())
AppendOutputToFileInTargetFolder $findings_FindingsByProblemCategory_Rows $findingsHtml_FileName 

$findings_FindingsByProblemCategory_Bottom = @'
</table></p>
'@
AppendOutputToFileInTargetFolder $findings_FindingsByProblemCategory_Bottom $findingsHtml_FileName 
 #endregion
}
#endregion

#region write FindingDetails

 #region writing Problems into separate sections
 if ($Result_Problems.Count -eq 0) {
    $problemsFoundBanner = @"
        <h2 style='text-align: left'><img style="width:20px; margin-right: 5px" src="$imgThumpsUp"/><span> Good, none of the rules could find any problem. </span><img style="width:20px; margin-right: 5px" src="$imgThumpsUp" /></h2>
"@ 
    AppendOutputToFileInTargetFolder $problemsFoundBanner $findingsHtml_FileName
 }
 else {    
    foreach( $problemSeverity in [ProblemSeverity]::Critical, [ProblemSeverity]::Error, [ProblemSeverity]::Warning, [ProblemSeverity]::Unclassified ) {
        
        $problemCountForCurrentSeverity = 0
        foreach($Result_Problem in $Result_Problems) {
            if ($Result_Problem.ProblemSeverity -eq $problemSeverity) { 
                $problemCountForCurrentSeverity++ 
            }
        }
        if ($problemCountForCurrentSeverity -gt 0) {                
            
            $severityCaption = switch ($problemSeverity) {
                Critical  { "<p><h2 onclick=""toggleElement('div-criticals');"" style=""cursor: pointer;"" title=""Toggle expand/collapse""><img style=""width:15px; margin-right: 5px"" src=""$imgNowCollapsed"" alt=""Toggle expand/collapse"" /><span style=""background-color:#FF6900; color:black"">CRITICAL PROBLEMS ($problemCountForCurrentSeverity)</span></h2><div id=""div-criticals"" style=""display:none""><br/><div style=""font-size:15px; color:black"">These are NON-ignorable errors. They have to be fixed.</div>"; break }       
                Error     { "<p><h2 onclick=""toggleElement('div-errors');"" style=""cursor: pointer;"" title=""Toggle expand/collapse""   ><img style=""width:15px; margin-right: 5px"" src=""$imgNowCollapsed"" alt=""Toggle expand/collapse"" /><span style=""background-color:#FFC000; color:black"">ERRORS ($problemCountForCurrentSeverity)              </span></h2><div id=""div-errors"" style=""display:none"">   <br/><div style=""font-size:15px; color:black"">They contain '$(IgnoreRuleIfText)' but when not ignored, they are severe Errors.</div>" ; break }
                Warning   { "<p><h2 onclick=""toggleElement('div-warnings');"" style=""cursor: pointer;"" title=""Toggle expand/collapse"" ><img style=""width:15px; margin-right: 5px"" src=""$imgNowCollapsed"" alt=""Toggle expand/collapse"" /><span style=""background-color:lightblue; color:black"">Warnings ($problemCountForCurrentSeverity)        </span></h2><div id=""div-warnings"" style=""display:none""> <br/><div style=""font-size:15px; color:black"">They contain '$(IgnoreRuleIfText)' but when not ignored, they are not necessarily severe errors.</div>" ; break }
                Default   { "<p><h2 onclick=""toggleElement('div-unclassifieds');"" style=""cursor: pointer;""><pre>------------ !!!  UNCLASSIFIED PROBLEMS FOUND  !!!  ---------</pre></h2><div id=""div-unclassifieds""><h3>The below have wrong Severity assigned. Need to be fixed in Analyzer code.</h3>" ; break }
            }            
            $tableStyle = "border-style: double; border-color: " 
            $tableStyle += switch ($problemSeverity) {
                Critical  { "#FF6900" ; break }       
                Error     { "#FFC000" ; break }      
                Warning   { "lightblue" ; break }      
                Default   { "#006400" ; break }   
            }
            AppendOutputToFileInTargetFolder "$severityCaption<table style='$tableStyle'>" $findingsHtml_FileName

            $severityHeaderStyle = switch ($problemSeverity) {
                Critical  { "table-header-critical" ; break }       
                Error     { "table-header-error" ; break }      
                Warning   { "table-header-warning" ; break }      
                Default   { "table-header-unclassified" ; break }      
            }
            $findings_FindingDetails_Top = @"
            <tr class="$severityHeaderStyle">
<!--            <th>Severity</th> -->
            <th class="table-col-hide">Case SAP Category</th>
            <th>Rule</th>
            <th>Definition</th>
            <th>Finding</th>
            </tr>
"@   
            AppendOutputToFileInTargetFolder $findings_FindingDetails_Top $findingsHtml_FileName 

            foreach($Result_Problem in $Result_Problems) {
                if ($Result_Problem.ProblemSeverity -eq $problemSeverity) {
                    $findings_FindingDetails_Row = '<tr>'
                    #$findings_FindingDetails_Row += "<td>" + $Result_Problem.ProblemSeverity +"</td>"
                    $findings_FindingDetails_Row += "<td class='table-col-hide'>" + $Result_Problem.SAPCategories +"</td>"
                    $findings_FindingDetails_Row += "<td>" + $Result_Problem.RuleName +"</td>"
                    $findings_FindingDetails_Row += "<td>" + $Result_Problem.RuleDesc +"</td>"
                    $findings_FindingDetails_Row += "<td>" + $Result_Problem.RuleResult +"</td>"
                    $findings_FindingDetails_Row += '</tr>'
                    AppendOutputToFileInTargetFolder $findings_FindingDetails_Row $findingsHtml_FileName 
                }
            }
            AppendOutputToFileInTargetFolder '</table></div></p>' $findingsHtml_FileName             
        }
    }
}

 #endregion

 #region writing Passed Rules
 AppendOutputToFileInTargetFolder "<p><h3 onclick=""toggleElement('div-passedRules');"" style=""cursor: pointer;"" title=""Toggle expand/collapse""><img style=""width:15px; margin-right: 5px"" src=""$imgNowCollapsed"" alt=""Toggle expand/collapse"" /><span>Passed Rules ($($Result_OKs.Count))</span></h3><div id=""div-passedRules"" style=""display: none""><table>" $findingsHtml_FileName
 $findings_FindingDetails_Top = @"       
        <tr>
        <th class="table-header-passedRule">Severity</th>
        <th class="table-header-passedRule table-col-hide">Case SAP Category</th>
        <th class="table-header-passedRule">Rule</th>
        <th class="table-header-passedRule">Definition</th>
        <th class="table-header-passedRule">Finding</th>
        </tr>
"@   
AppendOutputToFileInTargetFolder $findings_FindingDetails_Top $findingsHtml_FileName 

foreach($Result_Problem in $Result_OKs) {

    $findings_FindingDetails_Row = '<tr>'
    $findings_FindingDetails_Row += "<td>" + $Result_Problem.ProblemSeverity +"</td>"
    $findings_FindingDetails_Row += "<td class='table-col-hide'>" + $Result_Problem.SAPCategories +"</td>"
    $findings_FindingDetails_Row += "<td>" + $Result_Problem.RuleName +"</td>"
    $findings_FindingDetails_Row += "<td>" + $Result_Problem.RuleDesc +"</td>"
    $findings_FindingDetails_Row += "<td>" + $Result_Problem.RuleResult +"</td>"
    $findings_FindingDetails_Row += '</tr>'
    AppendOutputToFileInTargetFolder $findings_FindingDetails_Row $findingsHtml_FileName 
}
$findings_FindingDetails_Bottom = '</table></div></p>'
AppendOutputToFileInTargetFolder $findings_FindingDetails_Bottom $findingsHtml_FileName 
 #endregion
 
#endregion
#region write ScsmEnvInfo
$findings_ScsmEnvInfo = @"
<p>
    <h3 onclick="toggleElement('div-ScsmEnvInfo');" 
        style="cursor: pointer;" 
        title="Toggle expand/collapse"
    ><img style="width:15px; margin-right: 5px" 
            src="$imgNowCollapsed" 
                alt="Toggle expand/collapse" 
    />
    <span>SCSM Environment Info</span>
    </h3><div id="div-ScsmEnvInfo" style="display: none">
        <table>
        <tr>
        <th class="table-header">Info</th>
        <th class="table-header">Value</th>
        </tr>
"@
foreach($smEnvInfoRow in $smEnvInfoRows) {
    $findings_ScsmEnvInfo += "<tr><td>$($smEnvInfoRow.SmEnvInfo)</td><td>$($smEnvInfoRow.SmEnvValue)</td></tr>" 
}

#Check CollectorIssues
$collectorTranscriptFileName = (Get-ChildItem -Path $inputFolder -Filter Transcript*.txt).FullName
$collectorTranscriptContent = [System.IO.File]::ReadAllText($collectorTranscriptFileName)
$collectorIssuesString = ( GetSubstringFromString $collectorTranscriptContent $collectorStartingText $collectorEndingText )
if (-not [string]::IsNullOrWhiteSpace($collectorIssuesString)) {
    $telemetry.CollectorIssues = 1
    $findings_ScsmEnvInfo += "<tr><td>Collector had issues.<br/>This can cause 'false positive' analysis results!</td><td>Check in $(CollectorLink (Get-ChildItem -Path $inputFolder -Filter Transcript*.txt).Name)</td></tr>"
}

$findings_ScsmEnvInfo+= "</table></div></p>"

AppendOutputToFileInTargetFolder $findings_ScsmEnvInfo $findingsHtml_FileName 
#endregion

#region write AnalysisInfo...

$findings_AnalysisInfo = @"
<p>
    <h3 onclick="toggleElement('div-AnalysisInfo');" style="cursor: pointer" title="Toggle expand/collapse"
    ><img style="width:15px; margin-right: 5px" src="$imgNowCollapsed" alt="Toggle expand/collapse" />
    <span>Diagnostic Tool Info</span>
    </h3><div id='div-AnalysisInfo' style='display: none'>
            <table>
                <tr><th class="table-header">Info</th><th class="table-header">Value</th></tr>
                <tr><td>Collected files</td><td>|CollectorFolder|</td></tr>
               <!-- <tr><td>Collector original zip location</td><td>|CollectorZip|</td></tr> -->
                <tr><td>Diagnostic Version</td><td>|CollectorVersion|</td></tr>
                <tr><td>Diagnostic Date</td><td>|AnalysisDate|</td></tr>
                <!-- <tr><td>Analyzer Version</td><td>|AnalyzerVersion|</td></tr> -->
                |AnalyzerIssues|
            </table>
        </div>
</p>
"@
$findings_AnalysisInfo = $findings_AnalysisInfo.Replace("|CollectorFolder|",$(CollectorLink '' 'open Collector folder'))
#$findings_AnalysisInfo = $findings_AnalysisInfo.Replace("|CollectorZip|",$collectorResultZipPath)
$findings_AnalysisInfo = $findings_AnalysisInfo.Replace("|CollectorVersion|",$inputVersion)
$findings_AnalysisInfo = $findings_AnalysisInfo.Replace("|AnalysisDate|",$(Get-Date).ToString("yyyy-MM-dd__HH:mm.ss.fff zzz"))
#$findings_AnalysisInfo = $findings_AnalysisInfo.Replace("|AnalyzerVersion|", $analyzerVersion)
#closing the table for $findings_AnalysisInfo has been moved to the ENDING section right after stop-transcript
#endregion

#endregion

#region The ENDING Section

#cd (Split-Path $MyInvocation.MyCommand.Definition)
Write-Host ""
$completionDateTime = (Get-Date).ToString("yyyy-MM-dd__HH.mm.ss.fff")  
Write-Host "$analyzerEndingText $completionDateTime. (local time)"
$script:SQLResultSetCounter = $null
Stop-Transcript | out-null

#Check AnalyzerIssues
$analyzerTranscriptContent = [System.IO.File]::ReadAllText("$resultFolder\Transcript.txt")
$analyzerIssuesString = ( GetSubstringFromString $analyzerTranscriptContent $analyzerStartingText $analyzerEndingText )
if (-not [string]::IsNullOrWhiteSpace($analyzerIssuesString)) {
    $telemetry.AnalyzerIssues = 1
   # $findings_AnalysisInfo = $findings_AnalysisInfo.Replace("|AnalyzerIssues|", "<tr><td>Analyzer had issues!</td><td>Check in $(CollectorLink '../Analyzer/Transcript.txt' 'Transcript.txt')</td></tr>")
    $findings_AnalysisInfo = $findings_AnalysisInfo.Replace("|AnalyzerIssues|", "<tr><td>Analyzer had issues!</td><td>Check in $(AnalyzerLink 'Transcript.txt')</td></tr>")
}
else {
    $findings_AnalysisInfo = $findings_AnalysisInfo.Replace("|AnalyzerIssues|","")
}
AppendOutputToFileInTargetFolder $findings_AnalysisInfo $findingsHtml_FileName 
AppendOutputToFileInTargetFolder '</body></html>' $findingsHtml_FileName  

$findingsPS1_Content = "Start-Process .\$analyzer_FolderName\$findingsHtml_FileName"
Set-Content -Path (Join-Path -Path (Split-Path $resultFolder -Parent) -ChildPath $findingsPS1_FileName ) -Value $findingsPS1_Content

WriteTelemetry

#$ProgressPreference = 'Continue'
if ($removeCollectorResultZipFile) {
    Remove-Item $collectorResultZipPath
}

if (-not $debugmode) {
if ($compressTheResults) {
    Write-Host "Now compressing..." -ForegroundColor Yellow
        
    if ( $PSVersionTable.PSVersion.Major -lt 4 ) { 
        Compress-ZipFile  (Split-Path $resultFolder -Parent) $resultingZipFile_FullPath 
    }
    else {
        MakeNewZipFile (Split-Path $resultFolder -Parent) $resultingZipFile_FullPath 
    } 
   
    Remove-Item -Path (Split-Path $resultFolder -Parent) -Force -Recurse > $null
}
}

#endregion

return $resultingZipFile_FullPath

}

#region  function definitions added by Analyzer
function GetFileContentInSourceFolder($fileName, $subFolderName) {
    if ($subFolderName) {
        $fileName = Join-Path $subFolderName $fileName    
    }

    Get-Content -Path (Join-Path -Path $inputFolder -ChildPath $fileName) | Out-String    
}
function GetFileNameInSourceFolder($fileName) {
    return Join-Path -Path $inputFolder -ChildPath $fileName
}
<#
function GetFileContentInSourceFolder_WithAbort ($fileName, $subFolderName) {
    $result = GetFileContentInSourceFolder $fileName $subFolderName
   
    if (-not $result) {
        DisplayErrorText "$fileName  does not exist in Collector zip! Aborting ..."
        StopExecuting
    }
    $result
}
#>
function GetLinesFromString_WithTrimOption($inputString, $doTrim) {
    $lines = $inputString.Split( [Environment]::NewLine, [Stringsplitoptions]::RemoveEmptyEntries )
    if (-not $doTrim) { 
        return $lines 
    }
    else {
        [string[]]$result = @()
        foreach( $line in $lines ) {
            $result += $line.Trim()
        }
        return $result
    }
}
function GetLinesFromString($inputString, $doTrim=$true) {
    GetLinesFromString_WithTrimOption $inputString $doTrim    
}
function IsSourceAnyScsmMgmtServer() { #includes WF, Secondary and DW 
    ((IsSourceScsmMgmtServer) -or (IsSourceScsmDwMgmtServer))
}
function IsSourceScsmMgmtServer() {  #includes WF, Secondary, excluding DW
    ((IsSourceScsmWfMgmtServer) -or (IsSourceScsmSecondaryMgmtServer))
}
function IsSourceScsmDwMgmtServer() {
    $ScsmRolesFound.Contains("DW")
}
function IsSourceScsmWfMgmtServer() {
    $ScsmRolesFound.Contains("WF")
}
function IsSourceScsmSecondaryMgmtServer() {
    $ScsmRolesFound.Contains("2ndMS")
}

function HasSourceScsmConsoleInstalled() {
    return $false #todo
}
function HasSourceScsmPortalInstalled() {
    return $false #todo
}

function GetSanitizedCsv($strInput, $getAllNonEmptyLinesBeforeThisValue) {
    if (-not $getAllNonEmptyLinesBeforeThisValue) { $getAllNonEmptyLinesBeforeThisValue = '/*------------------------'}

    $sb = [System.Text.StringBuilder]::new()
    $lines = GetLinesFromString $strInput

    foreach($line in $lines) {
        if ($line.StartsWith($getAllNonEmptyLinesBeforeThisValue)) {break;}
        [void]$sb.AppendLine($line)
    }
    $sb.ToString()
}
function GetValueFromImportedCsv($psObject1, $columnNameToSearchIn, $valueToSearch, $columnNameWithValueToReturn) {
#this is just a helper function to filter a single object from a list based on equality and return only the first one.
#it returns the same like:   ($psObject1 | ? { $_.<$columnNameToSearchIn> -eq <$valueToSearch> } | Select-Object <$columnNameWithValueToReturn> -First 1 ).<$columnNameWithValueToReturn> 

    foreach($row in $psObject1.GetEnumerator()) {
       
            if ( ($row | Select-Object -ExpandProperty $columnNameToSearchIn) -eq $valueToSearch) {
                $row | Select-Object -ExpandProperty $columnNameWithValueToReturn
                break
            }   
    }
}
function GetFirstLineThatStartsWith($strInput, $valueToSearch, $doTrim=$true) {
    foreach($line in (GetLinesFromString $strInput $doTrim)) {        
        if ($line.StartsWith($valueToSearch,[System.StringComparison]::InvariantCultureIgnoreCase)) { $line;  break; }
    }
}
function GetFirstLineThatIsEqualTo($strInput, $valueToSearch) {
    foreach($line in (GetLinesFromString $strInput)) {        
        if ($line.Equals($valueToSearch,[System.StringComparison]::InvariantCultureIgnoreCase)) { $line;  break; }
    }
}
function GetFirstLineThatContains($strInput, $valueToSearch) {
    foreach($line in (GetLinesFromString $strInput)) {        
        if ( $line.ToLower().Contains($valueToSearch.ToLower()) ) { $line;  break; }
    }
}
function GetFirstLine($strInput) {
    if ($strInput.Length -eq 0) { $strInput;return; }
    [string[]]$tmp = GetLinesFromString $strInput
    $tmp[0]
}
function GetSubstringFromString([string]$content, [string]$startingText, [string]$endingText, [bool]$includeStartingText=$false, [bool]$includeEndingText=$false) {

    if ([string]::IsNullOrWhiteSpace($content)) { return ""; }
    if ([string]::IsNullOrWhiteSpace($startingText)) { return ""; }
    if ([string]::IsNullOrWhiteSpace($endingText)) { return ""; }

    $startingLoc = $content.IndexOf($startingText)
    if ($startingLoc -eq -1) { return ""; }
    if (-not $includeStartingText) { $startingLoc += $startingText.Length }

    $endingLoc = $content.IndexOf($endingText)
    if ($endingLoc -eq -1) { return ""; }
    if ($includeEndingText) { $endingLoc += $endingText.Length }

    $distance = $endingLoc - $startingLoc
    if ($distance -lt 0) { return ""; }

    $content.Substring($startingLoc, $distance)    
}

class cProblemCategory
{
    [ValidateNotNullOrEmpty()][string]$Name
    [ValidateNotNullOrEmpty()][string]$DisplayName
    [cProblemCategory]$Parent

    cProblemCategory(
        [string]$Name,
        [string]$DisplayName,
        [cProblemCategory]$Parent
    ){
        $this.Name = $Name
        $this.DisplayName = $DisplayName
        $this.Parent = $Parent
    }

    [string]ToString(){
        return ("{0}" -f $this.DisplayName)
    }
}

class cSAPCategoryHelper
{
    static [cProblemCategory[]]$SAPCategoryList

    static [cProblemCategory[]]GetSAPCategory($categoryName) {
        #return  $Global:SAPCategories.Where( { $_.Name -like $categoryName } )
        return  [cSAPCategoryHelper]::SAPCategoryList.Where( { $_.Name -like $categoryName } )
    }
    static [cProblemCategory[]]GetSAPCategory_ByDisplayName($categoryDisplayName) {
        #return  $Global:SAPCategories.Where( { $_.DisplayName -like $categoryDisplayName } )
        return  [cSAPCategoryHelper]::SAPCategoryList.Where( { $_.DisplayName -like $categoryDisplayName } )
    }
}
<#
[Flags()] enum ProblemCategory { # todo: absolete, delete
    Console = 1
    Authoring = 2
    Connectors = 4
    DWAndReporting = 8
    Portal = 16
    SMComponents = 32
    SMConfigurationAndPerformance = 64
    SetupAndDisasterRecovery = 128
    Workflows = 256
    Unclassified = 512 
}
#>
[Flags()] enum ProblemSeverity { 
    Critical = 1
    Error = 2
    Warning = 4    
    Unclassified = 1024 
}
class cData
{
    [string]$RuleName
    [string]$RuleDesc
    [string]$RuleResult
  #  [ProblemCategory]$ProblemCategory  # todo: absolete, delete
    [ProblemSeverity]$ProblemSeverity

    [cProblemCategory[]]$ProblemCategories

    cData(){
        $this | Add-Member -Name SAPCategories -MemberType ScriptProperty -Value {    # This is the getter
           
            $result = [string]::Empty
            foreach($SAPCategory in $this.ProblemCategories) {
                $result += "<li>$SAPCategory</li>"
            }
            return $result

        } -SecondValue {                                                              # This is the setter
            param([string[]]$valueList)
            
            foreach($value in $valueList) {
                $tmp = [cSAPCategoryHelper]::GetSAPCategory_ByDisplayName($value)
                if ($tmp.Length -eq 0) {
                    $tmp = [cSAPCategoryHelper]::GetSAPCategory($value)
                }
                if ($tmp.Length -eq 0) {
                    $tmp =  [cProblemCategory]::new("#UNDEFINED_SAP#","#UNDEFINED_SAP#",$null)
                }                
                $this.ProblemCategories +=  $tmp                
            }

        } -Force
    }
}
function GetEmptyResultRow() {

    return [cData]$dataRow = New-Object cData -Property @{
        RuleName=""
        RuleDesc=""
        RuleResult=""
    #    ProblemCategory=[ProblemCategory]::Unclassified  # todo: absolete, delete
        ProblemSeverity=[ProblemSeverity]::Unclassified

        ProblemCategories=$null
    }
}
function GetEmptySmEnvRow() {
    return [pscustomobject]$smEnvRow = [pscustomobject]@{SmEnvInfo="";SmEnvValue="";}
}
<#
function StopExecuting() {
    WriteTelemetry
    CleanUpTempFolders
    Read-Host " "
    Exit
}
#>
function DisplayErrorText($errorString) {
    Write-Host -ForegroundColor $errorForegroundColor -BackgroundColor $errorBackgroundColor $errorString
}
function CleanUpTempFolders() {   #todo  
    try {  Stop-Transcript | out-null } catch {}
   # if ($resultFolder -ne $null) { Remove-Item $resultFolder -Recurse }
}
function CollectorLink( [string]$tagUrl, [string]$tagDisplayName ) {
    if ([string]::IsNullOrEmpty($tagDisplayName.Trim())) {
        $tagDisplayName = $tagUrl
    }
    $result = GetAnchorForCollector $tagUrl $tagDisplayName
    $result
}
function GetAnchorForCollector([string]$tagUrl, [string]$tagDisplayName) {
    if ($useProtocolHandler_OpenDefAppByFileExt) {
         "<a href=""#"" onclick=""javascript: window.open('OpenDefAppByFileExt:'+getCollectorUrl()+'/$tagUrl','_blank');return false;"">$tagDisplayName</a>"
    }
    else {
         "<a href=""#"" onclick=""javascript: window.open(''+getCollectorUrl()+'/$tagUrl','_blank');return false;"">$tagDisplayName</a>"
    }
}
function AnalyzerLink( [string]$tagUrl, [string]$tagDisplayName ) {
    if ([string]::IsNullOrEmpty($tagDisplayName.Trim())) {
        $tagDisplayName = $tagUrl
    }
    $result = GetAnchorForAnalyzer $tagUrl $tagDisplayName
    $result
}
function GetAnchorForAnalyzer([string]$tagUrl, [string]$tagDisplayName) {
    if ($useProtocolHandler_OpenDefAppByFileExt) {
         "<a href=""#"" onclick=""javascript: window.open('OpenDefAppByFileExt:'+getAnalyzerUrl()+'/$tagUrl','_blank');return false;"">$tagDisplayName</a>"
    }
    else {
         "<a href=""#"" onclick=""javascript: window.open(''+getAnalyzerUrl()+'/$tagUrl','_blank');return false;"">$tagDisplayName</a>"
    }
}
function GetAnchorForExternal([string]$tagUrl, [string]$tagDisplayName) {
    if ([string]::IsNullOrEmpty($tagDisplayName.Trim())) {
        $tagDisplayName = $tagUrl
    }
    "<a target='_blank' href='$tagUrl'>$tagDisplayName</a>"
}
function IgnoreRuleIfText() {
    '<b>Ignore this rule if</b>'
}

#the properties sequence in class Telemetry is VERY IMPORTANT !! Don't change/delete them. If new data is needed, just add to the end.
class Telemetry {
    [int]$IssuesFound    #calculated in WriteTelemetry()
    [string]$User	#set in GetEmptyTelemetryRow()
    [string]$AnalyzerVersion	#set in WriteTelemetry()
    [string]$AnalysisID	#set as the Collector file name
    [string]$Start_DateTimeUtc	#set in GetEmptyTelemetryRow() and then again later when not aborted and rules starts running
    [int]$Start_Method #obsolete
    [int]$End_Result #calculated in WriteTelemetry()
    [string]$End_DateTimeUtc	#set in WriteTelemetry(), means either the time of abortion or successful completion
    [string]$Abort_Reason	#obsolete
    [string]$MainComponent	#set
    [int]$HasConsole #will be set later if Collector brings in Console specific data, otherwise default 0	 #todo
    [int]$HasPortal	#will be set later if Collector brings in Portal specific data, otherwise default 0 #todo
    [int]$DurationInSeconds	#calculated in WriteTelemetry()
    [string]$CollectorVersion	#set in WriteTelemetry()
    [int]$CriticalCount	#set in WriteTelemetry()
    [int]$ErrorCount	#set in WriteTelemetry()
    [int]$WarningCount	#set in WriteTelemetry()
    [int]$AnalyzerIssues	#set just after stopping transcript
    [int]$CollectorIssues #set, just before writing the Analysis Info section
    [string]$SMFullVersion #set in WriteTelemetry()
    [int]$CollectorVersionOld #obsolete
    [int]$IsOneDriveEnabled #obsolete
    [int]$AnalyzerStartedFromOneDrive #obsolete
    [int]$IsProtocolHandlerInstalled  #set in WriteTelemetry()
}
function GetEmptyTelemetryRow() {

    return [Telemetry]$TelemetryRow = New-Object Telemetry -Property @{
        Start_DateTimeUtc = ((Get-Date).ToUniversalTime())
       # User = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name  #todo
    }
}
function IsOneDriveEnabled([bool]$showText=$false) {
    return $false #obsolete   
}
function DoesAnalyzerShortcutExist([bool]$showText=$false) {
    return $false #obsolete
}
function WriteTelemetry() {
    
    #region Write computed telemetry properties
        $telemetry.AnalyzerVersion = $analyzerVersion
        $telemetry.End_Result = if ( $telemetry.Abort_Reason -gt 0 ) { 1 } 
        $telemetry.End_DateTimeUtc = (Get-Date).ToUniversalTime()
        $telemetry.DurationInSeconds = ([datetime]$telemetry.End_DateTimeUtc).Subtract(([datetime]$telemetry.Start_DateTimeUtc)).TotalSeconds
        $telemetry.CollectorVersion = $inputVersion

        foreach($Result_Problem in $Result_Problems) {
            if ($Result_Problem.ProblemSeverity -eq [ProblemSeverity]::Critical) {
                $telemetry.CriticalCount++ 
            }
            elseif ($Result_Problem.ProblemSeverity -eq [ProblemSeverity]::Error) {
                $telemetry.ErrorCount++ 
            }
            elseif ($Result_Problem.ProblemSeverity -eq [ProblemSeverity]::Warning) { 
                $telemetry.WarningCount++ 
            }
            else { $telemetry.CriticalCount++ } #=>  [ProblemSeverity]::Unclassified
        }
        $telemetry.IssuesFound = if ($telemetry.CriticalCount + $telemetry.ErrorCount + $telemetry.WarningCount -eq 0) {0} else {1}
        $telemetry.SMFullVersion = $SCSM_Version  
        $telemetry.Start_DateTimeUtc = ([datetime]$telemetry.Start_DateTimeUtc).ToString("yyyy-MM-dd HH:mm:ss") #better to read in Excel
        $telemetry.End_DateTimeUtc = ([datetime]$telemetry.End_DateTimeUtc).ToString("yyyy-MM-dd HH:mm:ss") #better to read in Excel
        #$telemetry.IsOneDriveEnabled = if ( IsOneDriveEnabled ) { 1 } else { 0 }  #obsolete
        $telemetry.IsProtocolHandlerInstalled = if ( $useProtocolHandler_OpenDefAppByFileExt ) { 1 } else { 0 }

    #endregion
    $newTelemetryContent = [string]::Join("`t",  $telemetry.PSObject.Properties.Value )

    if (-not $debugmode) {
        $telemetryFilePath = "" #todo
    } else {
        $telemetryFilePath = "" #todo [System.IO.Path]::Combine($currentPS1Path, "Extra\Telemetry")
    }

    do {
        $newTelemetryFileName = [System.IO.Path]::Combine( $telemetryFilePath , "run_"+ ((Get-Date).ToUniversalTime().ToString("yyyy-MM-dd__HH.mm.ss.fff")+".txt"))
    } while (Test-Path $newTelemetryFileName)

    # Add-Content -Path $newTelemetryFileName -Value $newTelemetryContent #todo
}
function ParseSqlDate([string]$dateString) {
    [datetime]$result = [datetime]::ParseExact($dateString, "$($sourceDateTimeFormat.ShortDatePattern) $($sourceDateTimeFormat.LongTimePattern)" ,$null)
    $result
}

function Is4PartVersionValid([string]$inputStr) {
$result = $true
    try {
        [Int32[]]$inputVersionParts = $inputStr.Split(".")
        if ($inputVersionParts.Count -ne 4) {
            $result = $false
        } 
        if (($inputVersionParts | Measure-Object -Sum).Sum -eq 0) {
            $result = $false
        } 
    }
    catch {
        $result = $false
    }
$result
}
#endregion

function Analyze_Rules() {

Analyze_ForDWAndWFAndSecondary
Analyze_ForWFAndSecondary
Analyze_ForDWAndWF
Analyze_ForWF
Analyze_ForDW
Analyze_ForSecondary
Analyze_ForConsole
Analyze_ForPortal
Analyze_ForALL

#region Navigate through all collected files and share finding+suggestions (optional: they can be later moved up to their related section )

 #region Checking folders
  #ERRORLOG -> #TODO
  #Health Service State -> to be consumed by engineer manually, if needed
  #LocaleMetaData -> to be used while processing event logs
  #MPXml -> to be consumed by engineer manually, if needed
  #OpsMgrTrace -> to be consumed by engineer manually, if needed
  #SCSM_SetupLogFiles -> #TODO
  #SMTrace -> to be consumed by engineer manually, if needed
  #TLS -> #TODO
 #endregion

 #region Checking files, which are not procesed YET

 #Application.evtx -> first get last SCSM restart datetime (based on events in OM log) then check here  #todo
 #ConnectorEclLogSettings.txt -> #TODO
 #DotNetFwV3.5.txt -> no need to check this file #todo: or may be just check if 3.5 is installed
 #DotNetFwV4.txt -> should be >= 4.5.1 but ideally better to have >= 4.7 or even 4.8, code like below would help #todo
    <#
    

Get-ChildItem 'HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full' |
Get-ItemProperty -name Version,Release -EA 0 |
Select  @{
  name="Version"
  expression={
      switch -regex ($_.Release) {
        "378389" { [Version]"4.5" }
        "378675|378758" { [Version]"4.5.1" }
        "379893" { [Version]"4.5.2" }
        "393295|393297" { [Version]"4.6" }
        "394254|394271" { [Version]"4.6.1" }
        "394802|394806" { [Version]"4.6.2" }
        "460798|460805" { [Version]"4.7"  }
        "461308|461310" { [Version]"4.7.1" }
       "461808|461814"{ [Version]?4.7.2? }
        "528040|528049|528372" { [Version]"4.8"}       
      }
    }
} 

    #>
 #EmailSendingRules.txt -> #TODO  

 #Get-Process_OnlyActiveOnes.txt -> #TODO
 #Get-Process_Top10_ByCPU.txt -> #TODO
 #Get-Process_Top10_ByWorkingSet.txt -> #TODO
 #Get-Process_WithAllDetails.txt -> #TODO
 #Get-Process_WithCurrentCPU.txt -> #TODO

 #Get-SCDWInfraLocation.txt -> #TODO
 #Get-SCDWJob.csv -> #TODO
 #Get-SCDWJob.txt -> #TODO
 #Get-SCDWJob_NumberOfBatches_5.txt -> #TODO
 #Get-SCDWJobSchedule.csv -> #TODO
 #Get-SCDWJobSchedule.txt -> #TODO
 #Get-SCSMAllowList.txt -> #TODO
 #Get-SCSMChannel.txt -> #TODO
 #Get-SCSMConnector.txt -> #TODO
 #Get-SCSMEmailTemplate.txt -> #TODO
 #Get-SCSMRunAsAccount.txt -> #TODO
 #Get-SCSMSetting.txt -> #TODO
 #Get-SCSMUserRole_WithAllDetails.csv -> #TODO
 #Get-SCSMWorkflow.txt -> #TODO
 #Get-UtcDate.txt -> #TODO
 #IsRunningAsElevated.txt -> #TODO
 #LanguageInfo.txt -> #TODO
 #LocalSecurityPolicy_UserRightsAssignment.txt -> #TODO
 #MachineStartTime.txt -> #TODO
 #msinfo32.txt -> #TODO
 #netstat_abof.txt -> #TODO
 #OperationsManager.evtx -> #TODO
 #Ping_FromSM_ToDW.txt -> #TODO
 #Ping_FromSM_ToSQL.txt -> #TODO
 #Ping_FromSMDW_ToSQL.txt -> #TODO
 #Ping_localhost_5724.txt -> #TODO
 #ProgramVersions.txt -> #TODO
 #PSCompatibleVersions.txt -> #TODO
 #PSVersionTable.txt -> #TODO
 #SCSM_Files.csv -> #TODO
 #SCSM_Version.txt -> #TODO
 #ScsmRolesFound.txt -> #TODO
 #ServerManagementGroups.regValues.txt -> #TODO
 #spnHS.txt -> #TODO
 #spnSDK.txt -> #TODO
 #spnX.txt -> #TODO
 #SQL_AdvancedTypeProjections.csv -> #TODO
 #SQL_BackupInfo.csv -> #TODO
 #SQL_CurrentlyRunningQueries.csv -> #TODO
 #SQL_database_scoped_configurations_IfGe2016.csv -> #TODO
 #SQL_DatabaseFiles.csv -> #TODO
 #SQL_Databases.csv -> #TODO
 #SQL_Date.csv -> #TODO
 #SQL_Dbcc_Useroptions.csv -> #TODO
 #SQL_DbUsersInfo.csv -> #TODO
 #SQL_DCM.csv -> #TODO
 #SQL_DelayedImplicitPermissions.csv -> #TODO
 #SQL_DeployItemStaging.csv -> #TODO
 #SQL_DeploySequenceStaging.csv -> #TODO
 #SQL_DeploySequenceView.csv -> #TODO
 #SQL_dm_os_schedulers.csv -> #TODO
 #SQL_dm_os_sys_info.csv -> #TODO
 #SQL_dm_os_wait_stats.csv -> #TODO
 #SQL_DW_DataSources.csv -> #TODO
 #SQL_DwDMDataRetention.csv -> #TODO
 #SQL_DWEtlConfiguration_CMDWDataMart.csv -> #TODO
 #SQL_DWEtlConfiguration_DWDataMart.csv -> #TODO
 #SQL_DWEtlConfiguration_DWRep.csv -> #TODO
 #SQL_DWEtlConfiguration_OMDWDataMart.csv -> #TODO
 #SQL_DWEtlWarehouseEntityGroomingHistory_CMDWDataMart.csv -> #TODO
 #SQL_DWEtlWarehouseEntityGroomingHistory_DWDataMart.csv -> #TODO
 #SQL_DWEtlWarehouseEntityGroomingHistory_DWRep.csv -> #TODO
 #SQL_DWEtlWarehouseEntityGroomingHistory_OMDWDataMart.csv -> #TODO
 #SQL_DWEtlWarehouseEntityGroomingInfo_CMDWDataMart.csv -> #TODO
 #SQL_DWEtlWarehouseEntityGroomingInfo_DWDataMart.csv -> #TODO
 #SQL_DWEtlWarehouseEntityGroomingInfo_DWRep.csv -> #TODO
 #SQL_DWEtlWarehouseEntityGroomingInfo_OMDWDataMart.csv -> #TODO
 #SQL_DWFactConstraintsIssue_CMDWDatamart.csv -> #TODO
 #SQL_DWFactConstraintsIssue_CMDWDatamart_ForDebugging.csv -> #TODO
 #SQL_DWFactConstraintsIssue_DWDatamart.csv -> #TODO
 #SQL_DWFactConstraintsIssue_DWDatamart_ForDebugging.csv -> #TODO
 #SQL_DWFactConstraintsIssue_DWRep.csv -> #TODO
 #SQL_DWFactConstraintsIssue_DWRep_ForDebugging.csv -> #TODO
 #SQL_DWFactConstraintsIssue_OMDWDatamart.csv -> #TODO
 #SQL_DWFactConstraintsIssue_OMDWDatamart_ForDebugging.csv -> #TODO
 #SQL_DWFactEntityUpgradeIssue_CMDWDataMart.csv -> #TODO
 #SQL_DWFactEntityUpgradeIssue_DWDataMart.csv -> #TODO
 #SQL_DWFactEntityUpgradeIssue_DWRep.csv -> #TODO
 #SQL_DWFactEntityUpgradeIssue_OMDWDataMart.csv -> #TODO
 #SQL_etl.WarehouseColumn.csv -> #TODO
 #SQL_etl.WarehouseEntity.csv -> #TODO
 #SQL_etl.WarehouseModule.csv -> #TODO
 #SQL_etl.WarehouseModuleDependency.csv -> #TODO
 #SQL_etl.WarehouseModuleDependency_Combined.csv -> #TODO
 #SQL_Event1209.csv -> #TODO
 #SQL_FKIssuesInDW_CMDWDatamart.csv -> #TODO
 #SQL_FKIssuesInDW_DWDatamart.csv -> #TODO
 #SQL_FKIssuesInDW_OMDWDatamart.csv -> #TODO
 #SQL_ForRFH_430445.csv -> #TODO
 #SQL_FragmentationInfo.csv -> #TODO
 #SQL_FromSMDB_MOMManagementGroupInfo.csv -> #TODO
 #SQL_FromSMDB_PatchInfo.csv -> #TODO
 #SQL_FromSMDB_WorkItemsCount.csv -> #TODO
 #SQL_FromSMDB_WorkItemsCount_ByMonth.csv -> #TODO
 #SQL_Get-SCSMUserRole.csv -> #TODO
 #SQL_GroomingConfiguration.csv -> #TODO
 #SQL_GroomingConfiguration_Log.csv -> #TODO
 #SQL_Indexes.csv -> #TODO
 #SQL_indexes_CMDWDataMart.csv -> #TODO
 #SQL_indexes_DWDataMart.csv -> #TODO
 #SQL_indexes_DWRep.csv -> #TODO
 #SQL_indexes_OMDWDataMart.csv -> #TODO
 #SQL_information_schema_columns.csv -> #TODO
 #SQL_information_schema_columns_CMDWDataMart.csv -> #TODO
 #SQL_information_schema_columns_DWDataMart.csv -> #TODO
 #SQL_information_schema_columns_DWRep.csv -> #TODO
 #SQL_information_schema_columns_OMDWDataMart.csv -> #TODO
 #SQL_InfraBatch.csv -> #TODO
 #SQL_InfraBatch_Recent20000.csv -> #TODO
 #SQL_InfraBatchHistory_Recent20000.csv -> #TODO
 #SQL_InfraProcess.csv -> #TODO
 #SQL_InfraProcessHistory.csv -> #TODO
 #SQL_InfraWorkItem.csv -> #TODO
 #SQL_InfraWorkItem_Recent20000.csv -> #TODO
 #SQL_InfraWorkItemDAG.csv -> #TODO
 #SQL_InfraWorkItemHistory_Recent20000.csv -> #TODO
 #SQL_LockDetails.csv -> #TODO
 #SQL_LoginsInfo.csv -> #TODO
 #SQL_ManagedType.csv -> #TODO
 #SQL_ManagedTypeProperty.csv -> #TODO
 #SQL_ManagementPack.csv -> #TODO
 #SQL_ManagementPackHistory.csv -> #TODO
 #SQL_NewestWorkItemsInDW.csv -> #TODO
 #SQL_NotificationTemplate.csv -> #TODO
 #SQL_OldestWorkItemsInDW.csv -> #TODO
 #SQL_PartitionAndGroomingSettings.csv -> #TODO
 #SQL_PatchInfo.csv -> #TODO
 #SQL_Queues.csv -> #TODO
 #SQL_RegisteredDwInfo.csv -> #TODO
 #SQL_Rules.csv -> #TODO
 #SQL_ScsmMonitoringMP_Grooming.csv -> #TODO
 #SQL_ScsmMonitoringMP_Lfx.csv -> #TODO
 #SQL_ScsmMonitoringMP_Workflows.csv -> #TODO
 #SQL_SMDB_Info.txt -> #TODO
 #SQL_sp_helplogins.csv -> #TODO
 #SQL_SSAS_Info.csv -> #TODO
 #SQL_SSRS_Info.csv -> #TODO
 #SQL_SynchronizationJobDetails.csv -> #TODO
 #SQL_TableSizeInfo_CMDWDataMart.csv -> #TODO
 #SQL_TableSizeInfo_DWDataMart.csv -> #TODO
 #SQL_TableSizeInfo_DWRepository.csv -> #TODO
 #SQL_TableSizeInfo_OMDWDataMart.csv -> #TODO
 #SQL_UsersWithMissingImpliedPermissionsOnReviewActivities.csv -> #TODO
 #SQL_UsersWithMissingImpliedPermissionsOnWorkItems.csv -> #TODO
 #SQL_WF_and_2ndaryMS.csv -> #TODO
 #SQL_WorkItemsCount.csv -> #TODO
 #SQL_WorkItemsCount_ByMonth.csv -> #TODO
 #SQL_WorkItemsInDW_ByMonth.csv -> #TODO
 #SsasCubes.txt -> #TODO
 #SsasDataSources.txt -> #TODO
 #SsasDataSourceViews.txt -> #TODO
 #SsasDB.txt -> #TODO
 #SsasDimensions.txt -> #TODO
 #Ssrs-AllItems.csv -> #TODO
 #Ssrs-TestUrl.txt -> #TODO
 #Ssrs-version.txt -> #TODO
 #System.evtx -> #TODO
 #SystemCenter.regPermissions.txt -> #TODO
 #SystemCenter.regValues.txt -> #TODO
 #Telnet_FromSM_ToDW.txt -> #TODO
 #Telnet_FromSM_ToSQL.txt -> #TODO
 #Telnet_FromSMDW_ToSQL.txt -> #TODO
 #Telnet_localhost_5724.txt -> #TODO
 #TotalRAM.txt -> #TODO
 #Transcript*.txt -> #TODO
 #WER.regValues.txt -> #TODO
 #WER_Files.txt -> #TODO

 #endregion

#endregion

}

function Finish($resultingZipFile_FullPath) {

    cls    

    Write-Host @"
*************************** --- IMPORTANT NOTICE --- **************************
The script is designed to collect information that will help Microsoft Customer Support Services (CSS) troubleshoot an issue you may be experiencing.
The collected zip file may contain Personally Identifiable Information (PII) and/or sensitive data, such as (but not limited to) paths to files, paths to registry keys, process names, host names, user names and IP addresses.
You can send the zip file to Microsoft CSS using a secure file transfer tool. Info about Secure File Exchange: https://docs.microsoft.com/en-US/troubleshoot/azure/general/secure-file-exchange-transfer-files.
Please discuss this with your support professional and also any concerns you may have.
By sending the zip file to Microsoft Support you accept that you are aware of the content of the zip file.
*******************************************************************************
"@
    Write-Host -NoNewline "Please send file "; Write-Host -NoNewline -ForegroundColor Yellow $resultingZipFile_FullPath; Write-Host " to Microsoft Support."
    Write-Host ""
    Write-Host "Press ENTER to navigate to the resulting zip file..." -ForegroundColor Cyan
    Read-Host " "  
      
    start (join-path $env:Windir explorer.exe) -ArgumentList "/select, ""$resultingZipFile_FullPath"""
}



function main() {

#region Setting the Script Scope vars
    [string]$scriptFilePath = ""
    [string]$toolVersion = "0.0.0.1"
    [bool]$debugmode = $false

    if ( (dir function:).Name -contains "GetToolVersion" ) { 
        $scriptFilePath = $MyInvocation.PSCommandPath 
        $toolVersion = GetToolVersion
    }
    else {
        # this means, we are starting debug in main.ps1 instead of a single big ps1 and therefore ALL functions are NOT loaded yet.

        $toolVersion = Get-Content -Path (Join-Path -Path (Split-Path $PSScriptRoot -Parent) -ChildPath version.txt)

        #We want to Debug/Develop in a location other than the Source Code. That's not to clutter within the development folder.
        $localDebugFolder = (Join-Path (Split-Path $PSScriptRoot -Parent) -ChildPath LocalDebug) 
        $scriptFilePath = Join-Path $localDebugFolder (Split-Path $PSCommandPath -Leaf)
        Copy-Item -Path $PSCommandPath -Destination $scriptFilePath -Force

        # We need to "load" all other function definitions in order be called        
        Get-ChildItem -Path $PSScriptRoot -Filter *.ps1 -Recurse -Exclude main.ps1 | % { . $_.FullName }
    }
#endregion

#region resetting the PS environment
    Remove-Variable * -ErrorAction SilentlyContinue -Exclude PSDefaultParameterValues, debugmode, scriptFilePath, toolVersion
    Remove-Module *; 
    $Error.Clear(); 
    Get-job | Remove-Job -Force
    $host.privatedata.ErrorForegroundColor ="DarkGray"  # For accessibility
    $global:ProgressPreference = 'SilentlyContinue'
#endregion 

    Set-PSDebug -Strict # from now on, all variables must be explicitly declared before they are used   

    Set-Location (Split-Path $scriptFilePath)  # setting current directory here once. Should not be changed anywhere else. 

    if (Initialize) {

        #region Collect
        $collectorResultingZipFile_FullPath = Collect
        #endregion

        #region Analyze
        $analyzerResultingZipFile_FullPath = Analyze $collectorResultingZipFile_FullPath
        #endregion

        Finish $analyzerResultingZipFile_FullPath
    }
    else {    
        Read-Host " "
    }
}

main;


